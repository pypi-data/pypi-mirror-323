# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/python@6.27.1)
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from io import IOBase
from typing import (
    IO,
    Any,
    Callable,
    Dict,
    List,
    Optional,
    TypeVar,
    Union,
    cast,
    overload,
)

from azure.core.exceptions import (
    ClientAuthenticationError,
    HttpResponseError,
    ResourceExistsError,
    ResourceNotFoundError,
    ResourceNotModifiedError,
    map_error,
)
from azure.core.pipeline import PipelineResponse
from azure.core.rest import HttpRequest, HttpResponse
from azure.core.tracing.decorator import distributed_trace
from azure.core.utils import case_insensitive_dict

from .._serialization import Serializer

if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore
JSON = MutableMapping[str, Any]  # pylint: disable=unsubscriptable-object
T = TypeVar("T")
ClsType = Optional[
    Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]
]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False


def build_tokens_current_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/tokens/current"

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_datasets_label_request(dataset_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/labels"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_datasets_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    name: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if name is not None:
        _params["name"] = _SERIALIZER.query("name", name, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_datasets_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_datasets_get_request(dataset_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_datasets_delete_request(dataset_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/delete"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_datasets_upload_request(
    dataset_id: str, artifact_path: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/upload/{artifact_path}"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
        "artifact_path": _SERIALIZER.url("artifact_path", artifact_path, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_datasets_finalize_request(dataset_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/finalize"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_datasets_downlinks_request(dataset_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/downlinks"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_datasets_documentation_request(dataset_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/documentation"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_datasets_edit_documentation_request(  # pylint: disable=name-too-long
    dataset_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/{dataset_id}/documentation"
    path_format_arguments = {
        "dataset_id": _SERIALIZER.url("dataset_id", dataset_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_datasets_query_documentation_request(  # pylint: disable=name-too-long
    *, query: Optional[str] = None, id: Optional[str] = None, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/datasets/documentation"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_evaluations_label_request(evaluation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/evaluations/{evaluation_id}/labels"
    path_format_arguments = {
        "evaluation_id": _SERIALIZER.url("evaluation_id", evaluation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_evaluations_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    dataset: Optional[str] = None,
    inference_service: Optional[str] = None,
    inference_service_name: Optional[str] = None,
    model: Optional[str] = None,
    model_name: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/evaluations"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if dataset is not None:
        _params["dataset"] = _SERIALIZER.query("dataset", dataset, "str")
    if inference_service is not None:
        _params["inferenceService"] = _SERIALIZER.query(
            "inference_service", inference_service, "str"
        )
    if inference_service_name is not None:
        _params["inferenceServiceName"] = _SERIALIZER.query(
            "inference_service_name", inference_service_name, "str"
        )
    if model is not None:
        _params["model"] = _SERIALIZER.query("model", model, "str")
    if model_name is not None:
        _params["modelName"] = _SERIALIZER.query("model_name", model_name, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_evaluations_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/evaluations"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_evaluations_get_request(evaluation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/evaluations/{evaluation_id}"
    path_format_arguments = {
        "evaluation_id": _SERIALIZER.url("evaluation_id", evaluation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_evaluations_delete_request(evaluation_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/evaluations/{evaluation_id}/delete"
    path_format_arguments = {
        "evaluation_id": _SERIALIZER.url("evaluation_id", evaluation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_evaluations_downlinks_request(
    evaluation_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/evaluations/{evaluation_id}/downlinks"
    path_format_arguments = {
        "evaluation_id": _SERIALIZER.url("evaluation_id", evaluation_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_inferenceservices_label_request(
    service_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices/{service_id}/labels"
    path_format_arguments = {
        "service_id": _SERIALIZER.url("service_id", service_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_inferenceservices_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    name: Optional[str] = None,
    model: Optional[str] = None,
    model_name: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if name is not None:
        _params["name"] = _SERIALIZER.query("name", name, "str")
    if model is not None:
        _params["model"] = _SERIALIZER.query("model", model, "str")
    if model_name is not None:
        _params["modelName"] = _SERIALIZER.query("model_name", model_name, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_inferenceservices_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_inferenceservices_get_request(service_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices/{service_id}"
    path_format_arguments = {
        "service_id": _SERIALIZER.url("service_id", service_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_inferenceservices_delete_request(
    service_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices/{service_id}/delete"
    path_format_arguments = {
        "service_id": _SERIALIZER.url("service_id", service_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_inferenceservices_documentation_request(  # pylint: disable=name-too-long
    service_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices/{service_id}/documentation"
    path_format_arguments = {
        "service_id": _SERIALIZER.url("service_id", service_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_inferenceservices_edit_documentation_request(  # pylint: disable=name-too-long
    service_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferenceservices/{service_id}/documentation"
    path_format_arguments = {
        "service_id": _SERIALIZER.url("service_id", service_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_label_request(
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}/labels"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    name: Optional[str] = None,
    inference_service: Optional[str] = None,
    inference_service_name: Optional[str] = None,
    model: Optional[str] = None,
    model_name: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if name is not None:
        _params["name"] = _SERIALIZER.query("name", name, "str")
    if inference_service is not None:
        _params["inferenceService"] = _SERIALIZER.query(
            "inference_service", inference_service, "str"
        )
    if inference_service_name is not None:
        _params["inferenceServiceName"] = _SERIALIZER.query(
            "inference_service_name", inference_service_name, "str"
        )
    if model is not None:
        _params["model"] = _SERIALIZER.query("model", model, "str")
    if model_name is not None:
        _params["modelName"] = _SERIALIZER.query("model_name", model_name, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_inferencesessions_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_get_request(session_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_delete_request(
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}/delete"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_terminate_request(  # pylint: disable=name-too-long
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}/terminate"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_infer_request(
    session_id: str, inference_endpoint: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}/infer/{inference_endpoint}"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
        "inference_endpoint": _SERIALIZER.url(
            "inference_endpoint", inference_endpoint, "str"
        ),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_token_request(
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}/token"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_inferencesessions_ready_request(
    session_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/inferencesessions/{session_id}/ready"
    path_format_arguments = {
        "session_id": _SERIALIZER.url("session_id", session_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_measurements_label_request(measurement_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements/{measurement_id}/labels"
    path_format_arguments = {
        "measurement_id": _SERIALIZER.url("measurement_id", measurement_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_measurements_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    method: Optional[str] = None,
    method_name: Optional[str] = None,
    dataset: Optional[str] = None,
    evaluation: Optional[str] = None,
    inference_service: Optional[str] = None,
    model: Optional[str] = None,
    inputs: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if method is not None:
        _params["method"] = _SERIALIZER.query("method", method, "str")
    if method_name is not None:
        _params["methodName"] = _SERIALIZER.query("method_name", method_name, "str")
    if dataset is not None:
        _params["dataset"] = _SERIALIZER.query("dataset", dataset, "str")
    if evaluation is not None:
        _params["evaluation"] = _SERIALIZER.query("evaluation", evaluation, "str")
    if inference_service is not None:
        _params["inferenceService"] = _SERIALIZER.query(
            "inference_service", inference_service, "str"
        )
    if model is not None:
        _params["model"] = _SERIALIZER.query("model", model, "str")
    if inputs is not None:
        _params["inputs"] = _SERIALIZER.query("inputs", inputs, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_measurements_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_measurements_get_request(measurement_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements/{measurement_id}"
    path_format_arguments = {
        "measurement_id": _SERIALIZER.url("measurement_id", measurement_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_measurements_delete_request(
    measurement_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements/{measurement_id}/delete"
    path_format_arguments = {
        "measurement_id": _SERIALIZER.url("measurement_id", measurement_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_measurements_downlinks_request(
    measurement_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements/{measurement_id}/downlinks"
    path_format_arguments = {
        "measurement_id": _SERIALIZER.url("measurement_id", measurement_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_measurements_logs_request(measurement_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/measurements/{measurement_id}/logs"
    path_format_arguments = {
        "measurement_id": _SERIALIZER.url("measurement_id", measurement_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_methods_label_request(method_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods/{method_id}/labels"
    path_format_arguments = {
        "method_id": _SERIALIZER.url("method_id", method_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_methods_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    name: Optional[str] = None,
    output_kind: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if name is not None:
        _params["name"] = _SERIALIZER.query("name", name, "str")
    if output_kind is not None:
        _params["outputKind"] = _SERIALIZER.query("output_kind", output_kind, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_methods_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_methods_get_request(method_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods/{method_id}"
    path_format_arguments = {
        "method_id": _SERIALIZER.url("method_id", method_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_methods_delete_request(method_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods/{method_id}/delete"
    path_format_arguments = {
        "method_id": _SERIALIZER.url("method_id", method_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_methods_documentation_request(method_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods/{method_id}/documentation"
    path_format_arguments = {
        "method_id": _SERIALIZER.url("method_id", method_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_methods_edit_documentation_request(
    method_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/methods/{method_id}/documentation"
    path_format_arguments = {
        "method_id": _SERIALIZER.url("method_id", method_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_models_label_request(model_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{model_id}/labels"
    path_format_arguments = {
        "model_id": _SERIALIZER.url("model_id", model_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_models_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    name: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if name is not None:
        _params["name"] = _SERIALIZER.query("name", name, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_models_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_models_get_request(model_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{model_id}"
    path_format_arguments = {
        "model_id": _SERIALIZER.url("model_id", model_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_models_delete_request(model_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{model_id}/delete"
    path_format_arguments = {
        "model_id": _SERIALIZER.url("model_id", model_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_models_documentation_request(model_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{model_id}/documentation"
    path_format_arguments = {
        "model_id": _SERIALIZER.url("model_id", model_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_models_edit_documentation_request(
    model_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/models/{model_id}/documentation"
    path_format_arguments = {
        "model_id": _SERIALIZER.url("model_id", model_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_modules_label_request(module_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/labels"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_modules_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    name: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if name is not None:
        _params["name"] = _SERIALIZER.query("name", name, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_modules_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_modules_get_request(module_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_modules_delete_request(module_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/delete"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_modules_upload_request(
    module_id: str, artifact_path: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/upload/{artifact_path}"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
        "artifact_path": _SERIALIZER.url("artifact_path", artifact_path, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_modules_finalize_request(module_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/finalize"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_modules_downlinks_request(module_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/downlinks"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_modules_documentation_request(module_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/documentation"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_modules_edit_documentation_request(
    module_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/modules/{module_id}/documentation"
    path_format_arguments = {
        "module_id": _SERIALIZER.url("module_id", module_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_usecases_get_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/usecases/{id}"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_usecases_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/usecases"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_usecases_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/usecases"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_usecases_label_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/usecases/{id}/labels"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_usecases_edit_documentation_request(
    id: str, **kwargs: Any
) -> HttpRequest:  # pylint: disable=name-too-long
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/usecases/{id}/documentation"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_usecases_delete_request(id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/usecases/{id}/delete"
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_reports_label_request(report_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports/{report_id}/labels"
    path_format_arguments = {
        "report_id": _SERIALIZER.url("report_id", report_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_reports_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    report: Optional[str] = None,
    dataset: Optional[str] = None,
    evaluation: Optional[str] = None,
    inference_service: Optional[str] = None,
    model: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if report is not None:
        _params["report"] = _SERIALIZER.query("report", report, "str")
    if dataset is not None:
        _params["dataset"] = _SERIALIZER.query("dataset", dataset, "str")
    if evaluation is not None:
        _params["evaluation"] = _SERIALIZER.query("evaluation", evaluation, "str")
    if inference_service is not None:
        _params["inferenceService"] = _SERIALIZER.query(
            "inference_service", inference_service, "str"
        )
    if model is not None:
        _params["model"] = _SERIALIZER.query("model", model, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_reports_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_reports_get_request(report_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports/{report_id}"
    path_format_arguments = {
        "report_id": _SERIALIZER.url("report_id", report_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_reports_delete_request(report_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports/{report_id}/delete"
    path_format_arguments = {
        "report_id": _SERIALIZER.url("report_id", report_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_reports_downlinks_request(report_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports/{report_id}/downlinks"
    path_format_arguments = {
        "report_id": _SERIALIZER.url("report_id", report_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_reports_logs_request(report_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/reports/{report_id}/logs"
    path_format_arguments = {
        "report_id": _SERIALIZER.url("report_id", report_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_safetycases_label_request(safetycase_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases/{safetycase_id}/labels"
    path_format_arguments = {
        "safetycase_id": _SERIALIZER.url("safetycase_id", safetycase_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PATCH", url=_url, headers=_headers, **kwargs)


def build_safetycases_query_request(
    *,
    query: Optional[str] = None,
    id: Optional[str] = None,
    account: Optional[str] = None,
    status: Optional[str] = None,
    reason: Optional[str] = None,
    labels: Optional[str] = None,
    method: Optional[str] = None,
    method_name: Optional[str] = None,
    dataset: Optional[str] = None,
    evaluation: Optional[str] = None,
    inference_service: Optional[str] = None,
    model: Optional[str] = None,
    inputs: Optional[str] = None,
    **kwargs: Any,
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
    _params = case_insensitive_dict(kwargs.pop("params", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases"

    # Construct parameters
    if query is not None:
        _params["query"] = _SERIALIZER.query("query", query, "str")
    if id is not None:
        _params["id"] = _SERIALIZER.query("id", id, "str")
    if account is not None:
        _params["account"] = _SERIALIZER.query("account", account, "str")
    if status is not None:
        _params["status"] = _SERIALIZER.query("status", status, "str")
    if reason is not None:
        _params["reason"] = _SERIALIZER.query("reason", reason, "str")
    if labels is not None:
        _params["labels"] = _SERIALIZER.query("labels", labels, "str")
    if method is not None:
        _params["method"] = _SERIALIZER.query("method", method, "str")
    if method_name is not None:
        _params["methodName"] = _SERIALIZER.query("method_name", method_name, "str")
    if dataset is not None:
        _params["dataset"] = _SERIALIZER.query("dataset", dataset, "str")
    if evaluation is not None:
        _params["evaluation"] = _SERIALIZER.query("evaluation", evaluation, "str")
    if inference_service is not None:
        _params["inferenceService"] = _SERIALIZER.query(
            "inference_service", inference_service, "str"
        )
    if model is not None:
        _params["model"] = _SERIALIZER.query("model", model, "str")
    if inputs is not None:
        _params["inputs"] = _SERIALIZER.query("inputs", inputs, "str")

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(
        method="GET", url=_url, params=_params, headers=_headers, **kwargs
    )


def build_safetycases_create_request(**kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    content_type: Optional[str] = kwargs.pop(
        "content_type", _headers.pop("Content-Type", None)
    )
    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases"

    # Construct headers
    if content_type is not None:
        _headers["Content-Type"] = _SERIALIZER.header(
            "content_type", content_type, "str"
        )
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="POST", url=_url, headers=_headers, **kwargs)


def build_safetycases_get_request(safetycase_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases/{safetycase_id}"
    path_format_arguments = {
        "safetycase_id": _SERIALIZER.url("safetycase_id", safetycase_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_safetycases_delete_request(safetycase_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases/{safetycase_id}/delete"
    path_format_arguments = {
        "safetycase_id": _SERIALIZER.url("safetycase_id", safetycase_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="PUT", url=_url, headers=_headers, **kwargs)


def build_safetycases_downlinks_request(
    safetycase_id: str, **kwargs: Any
) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases/{safetycase_id}/downlinks"
    path_format_arguments = {
        "safetycase_id": _SERIALIZER.url("safetycase_id", safetycase_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


def build_safetycases_logs_request(safetycase_id: str, **kwargs: Any) -> HttpRequest:
    _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})

    accept = _headers.pop("Accept", "application/json")

    # Construct URL
    _url = "/safetycases/{safetycase_id}/logs"
    path_format_arguments = {
        "safetycase_id": _SERIALIZER.url("safetycase_id", safetycase_id, "str"),
    }

    _url: str = _url.format(**path_format_arguments)  # type: ignore

    # Construct headers
    _headers["Accept"] = _SERIALIZER.header("accept", accept, "str")

    return HttpRequest(method="GET", url=_url, headers=_headers, **kwargs)


class TokensOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`tokens` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def current(self, **kwargs: Any) -> JSON:
        """Verify the signature of the provied token and return its JSON body.

        Verify the signature of the provied token and return its JSON body.

        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "created": "2020-02-20 00:00:00",
                    "expires": "2020-02-20 00:00:00",
                    "id": "str",
                    "subject": "str",
                    "grants": [
                        {
                            "functions": [
                                "str"
                            ],
                            "resources": [
                                "str"
                            ],
                            "accounts": [
                                "str"
                            ],
                            "entities": [
                                "str"
                            ]
                        }
                    ],
                    "secret": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_tokens_current_request(
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class DatasetsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`datasets` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        dataset_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Dataset.

        Update labels for an existing Dataset.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        dataset_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Dataset.

        Update labels for an existing Dataset.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(
        self, dataset_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Update labels for an existing Dataset.

        Update labels for an existing Dataset.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_datasets_label_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Datasets matching a query.

        Get all Datasets matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "artifacts": [
                            {
                                "path": "str",
                                "digest": {
                                    "md5": "str"
                                },
                                "kind": "str"
                            }
                        ],
                        "id": "str",
                        "name": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "kind": "Dataset",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "status": "str",
                        "views": [
                            {
                                "id": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "viewOf": "str",
                                "adapterPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            }
                        ]
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_datasets_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Dataset.

        Create a Dataset.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "schemaVersion": "0.1",
                    "views": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Dataset",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str",
                    "views": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ]
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Dataset.

        Create a Dataset.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Dataset",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str",
                    "views": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ]
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a Dataset.

        Create a Dataset.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "schemaVersion": "0.1",
                    "views": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Dataset",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str",
                    "views": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_datasets_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Get a Dataset by its key.

        Get a Dataset by its key.

        Raises a 404 error if no entity exists with that key.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Dataset",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str",
                    "views": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ]
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_get_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Mark a Dataset for deletion.

        Mark a Dataset for deletion.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_delete_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def upload(self, dataset_id: str, artifact_path: str, **kwargs: Any) -> JSON:
        """Get a signed URL to which the given artifact can be uploaded.

        Get a signed URL to which the given artifact can be uploaded.

        :param dataset_id: Required.
        :type dataset_id: str
        :param artifact_path: Required.
        :type artifact_path: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "method": "str",
                    "url": "str",
                    "headers": {
                        "str": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_upload_request(
            dataset_id=dataset_id,
            artifact_path=artifact_path,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def finalize(self, dataset_id: str, **kwargs: Any) -> Any:
        """Indicate that all dataset artifacts have been uploaded.

        Indicate that all dataset artifacts have been uploaded.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_datasets_finalize_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def downlinks(self, dataset_id: str, **kwargs: Any) -> List[JSON]:
        """Get a list of signed GET URLs from which Dataset artifacts can be downloaded.

        Get a list of signed GET URLs from which Dataset artifacts can be downloaded.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        },
                        "signedURL": {
                            "method": "str",
                            "url": "str",
                            "headers": {
                                "str": "str"
                            }
                        }
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_datasets_downlinks_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def documentation(self, dataset_id: str, **kwargs: Any) -> JSON:
        """Get the documentation associated with a Dataset.

        Get the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key.

        :param dataset_id: Required.
        :type dataset_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_datasets_documentation_request(
            dataset_id=dataset_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def edit_documentation(
        self,
        dataset_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Dataset.

        Edit the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @overload
    def edit_documentation(
        self,
        dataset_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Dataset.

        Edit the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @distributed_trace
    def edit_documentation(
        self, dataset_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        """Edit the documentation associated with a Dataset.

        Edit the documentation associated with a Dataset.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param dataset_id: Required.
        :type dataset_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_datasets_edit_documentation_request(
            dataset_id=dataset_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def query_documentation(
        self, *, query: Optional[str] = None, id: Optional[str] = None, **kwargs: Any
    ) -> List[JSON]:
        """Get all Documentation matching a query and that pertains to Datasets.

        Get all Documentation matching a query and that pertains to Datasets.

        Currently, only the ``.id`` field is queryable.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "entity": "str",
                        "fullPage": "str",
                        "schemaVersion": "0.1",
                        "summary": "str",
                        "title": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_datasets_query_documentation_request(
            query=query,
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore


class EvaluationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`evaluations` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        evaluation_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Evaluation.

        Update labels for an existing Evaluation.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        evaluation_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Evaluation.

        Update labels for an existing Evaluation.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(
        self, evaluation_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Update labels for an existing Evaluation.

        Update labels for an existing Evaluation.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_evaluations_label_request(
            evaluation_id=evaluation_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        dataset: Optional[str] = None,
        inference_service: Optional[str] = None,
        inference_service_name: Optional[str] = None,
        model: Optional[str] = None,
        model_name: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Evaluations matching a query.

        Get all Evaluations matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword inference_service_name: Default value is None.
        :paramtype inference_service_name: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword model_name: Default value is None.
        :paramtype model_name: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "dataset": "str",
                        "id": "str",
                        "inferenceSession": {
                            "inferenceService": {
                                "account": "str",
                                "id": "str",
                                "interface": {
                                    "endpoint": "str",
                                    "outputSchema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "inputPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ],
                                    "outputPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                },
                                "name": "str",
                                "builder": {
                                    "kind": "str",
                                    "args": [
                                        "str"
                                    ]
                                },
                                "model": {
                                    "account": "str",
                                    "artifact": {
                                        "kind": "str",
                                        "huggingFaceCache": {
                                            "repoID": "str",
                                            "revision": "str"
                                        }
                                    },
                                    "id": "str",
                                    "name": "str",
                                    "storage": {
                                        "medium": "str"
                                    }
                                },
                                "outputViews": [
                                    {
                                        "id": "str",
                                        "schema": {
                                            "arrowSchema": "str",
                                            "dyffSchema": {
                                                "components": [
                                                    "str"
                                                ],
                                                "schemaVersion":
                                                  "0.1"
                                            },
                                            "jsonSchema": {}
                                        },
                                        "viewOf": "str",
                                        "adapterPipeline": [
                                            {
                                                "kind": "str",
                                                "configuration": {}
                                            }
                                        ]
                                    }
                                ],
                                "runner": {
                                    "kind": "str",
                                    "resources": {
                                        "storage": "str",
                                        "memory": "str"
                                    },
                                    "accelerator": {
                                        "kind": "str",
                                        "gpu": {
                                            "hardwareTypes": [
                                                "str"
                                            ],
                                            "count": 1,
                                            "memory": "str"
                                        }
                                    },
                                    "args": [
                                        "str"
                                    ],
                                    "image": {
                                        "digest": "str",
                                        "host": "str",
                                        "name": "str",
                                        "tag": "str"
                                    }
                                }
                            },
                            "accelerator": {
                                "kind": "str",
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"
                                    ],
                                    "count": 1,
                                    "memory": "str"
                                }
                            },
                            "expires": "2020-02-20 00:00:00",
                            "replicas": 1,
                            "useSpotPods": True
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "inferenceSessionReference": "str",
                        "kind": "Evaluation",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "replications": 1,
                        "schemaVersion": "0.1",
                        "status": "str",
                        "workersPerReplica": 0
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_evaluations_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            dataset=dataset,
            inference_service=inference_service,
            inference_service_name=inference_service_name,
            model=model,
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an Evaluation.

        Create an Evaluation.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "dataset": "str",
                    "inferenceSession": {
                        "inferenceService": "str",
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "expires": "2020-02-20 00:00:00",
                        "replicas": 1,
                        "useSpotPods": True
                    },
                    "inferenceSessionReference": "str",
                    "replications": 1,
                    "schemaVersion": "0.1",
                    "workersPerReplica": 0
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "id": "str",
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "expires": "2020-02-20 00:00:00",
                        "replicas": 1,
                        "useSpotPods": True
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "inferenceSessionReference": "str",
                    "kind": "Evaluation",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "replications": 1,
                    "schemaVersion": "0.1",
                    "status": "str",
                    "workersPerReplica": 0
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an Evaluation.

        Create an Evaluation.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "id": "str",
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "expires": "2020-02-20 00:00:00",
                        "replicas": 1,
                        "useSpotPods": True
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "inferenceSessionReference": "str",
                    "kind": "Evaluation",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "replications": 1,
                    "schemaVersion": "0.1",
                    "status": "str",
                    "workersPerReplica": 0
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create an Evaluation.

        Create an Evaluation.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "dataset": "str",
                    "inferenceSession": {
                        "inferenceService": "str",
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "expires": "2020-02-20 00:00:00",
                        "replicas": 1,
                        "useSpotPods": True
                    },
                    "inferenceSessionReference": "str",
                    "replications": 1,
                    "schemaVersion": "0.1",
                    "workersPerReplica": 0
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "id": "str",
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "expires": "2020-02-20 00:00:00",
                        "replicas": 1,
                        "useSpotPods": True
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "inferenceSessionReference": "str",
                    "kind": "Evaluation",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "replications": 1,
                    "schemaVersion": "0.1",
                    "status": "str",
                    "workersPerReplica": 0
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_evaluations_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, evaluation_id: str, **kwargs: Any) -> JSON:
        """Get an Evaluation by its key.

        Get an Evaluation by its key.

        Raises a 404 error if no entity exists with that key.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "id": "str",
                    "inferenceSession": {
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "expires": "2020-02-20 00:00:00",
                        "replicas": 1,
                        "useSpotPods": True
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "inferenceSessionReference": "str",
                    "kind": "Evaluation",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "replications": 1,
                    "schemaVersion": "0.1",
                    "status": "str",
                    "workersPerReplica": 0
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_evaluations_get_request(
            evaluation_id=evaluation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, evaluation_id: str, **kwargs: Any) -> JSON:
        """Mark an Evaluation for deletion.

        Mark an Evaluation for deletion.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_evaluations_delete_request(
            evaluation_id=evaluation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def downlinks(self, evaluation_id: str, **kwargs: Any) -> List[JSON]:
        """Get a list of signed GET URLs from which Evaluation artifacts can be
        downloaded.

        Get a list of signed GET URLs from which Evaluation artifacts can be downloaded.

        :param evaluation_id: Required.
        :type evaluation_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        },
                        "signedURL": {
                            "method": "str",
                            "url": "str",
                            "headers": {
                                "str": "str"
                            }
                        }
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_evaluations_downlinks_request(
            evaluation_id=evaluation_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore


class InferenceservicesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`inferenceservices` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        service_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing InferenceService.

        Update labels for an existing InferenceService.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        service_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing InferenceService.

        Update labels for an existing InferenceService.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(
        self, service_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Update labels for an existing InferenceService.

        Update labels for an existing InferenceService.

        :param service_id: Required.
        :type service_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferenceservices_label_request(
            service_id=service_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        model: Optional[str] = None,
        model_name: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all InferenceServices matching a query.

        Get all InferenceServices matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword model_name: Default value is None.
        :paramtype model_name: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "id": "str",
                        "interface": {
                            "endpoint": "str",
                            "outputSchema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "inputPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ],
                            "outputPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        },
                        "name": "str",
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "builder": {
                            "kind": "str",
                            "args": [
                                "str"
                            ]
                        },
                        "creationTime": "2020-02-20 00:00:00",
                        "kind": "InferenceService",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "model": {
                            "account": "str",
                            "artifact": {
                                "kind": "str",
                                "huggingFaceCache": {
                                    "repoID": "str",
                                    "revision": "str"
                                }
                            },
                            "id": "str",
                            "name": "str",
                            "storage": {
                                "medium": "str"
                            }
                        },
                        "outputViews": [
                            {
                                "id": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "viewOf": "str",
                                "adapterPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            }
                        ],
                        "reason": "str",
                        "runner": {
                            "kind": "str",
                            "resources": {
                                "storage": "str",
                                "memory": "str"
                            },
                            "accelerator": {
                                "kind": "str",
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"
                                    ],
                                    "count": 1,
                                    "memory": "str"
                                }
                            },
                            "args": [
                                "str"
                            ],
                            "image": {
                                "digest": "str",
                                "host": "str",
                                "name": "str",
                                "tag": "str"
                            }
                        },
                        "schemaVersion": "0.1",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_inferenceservices_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            model=model,
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an InferenceService.

        Create an InferenceService.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "interface": {
                        "endpoint": "str",
                        "outputSchema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "name": "str",
                    "builder": {
                        "kind": "str",
                        "args": [
                            "str"
                        ]
                    },
                    "model": "str",
                    "outputViews": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ],
                    "runner": {
                        "kind": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "args": [
                            "str"
                        ],
                        "image": {
                            "digest": "str",
                            "host": "str",
                            "name": "str",
                            "tag": "str"
                        }
                    },
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "interface": {
                        "endpoint": "str",
                        "outputSchema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "builder": {
                        "kind": "str",
                        "args": [
                            "str"
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "InferenceService",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": {
                        "account": "str",
                        "artifact": {
                            "kind": "str",
                            "huggingFaceCache": {
                                "repoID": "str",
                                "revision": "str"
                            }
                        },
                        "id": "str",
                        "name": "str",
                        "storage": {
                            "medium": "str"
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ],
                    "reason": "str",
                    "runner": {
                        "kind": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "args": [
                            "str"
                        ],
                        "image": {
                            "digest": "str",
                            "host": "str",
                            "name": "str",
                            "tag": "str"
                        }
                    },
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an InferenceService.

        Create an InferenceService.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "interface": {
                        "endpoint": "str",
                        "outputSchema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "builder": {
                        "kind": "str",
                        "args": [
                            "str"
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "InferenceService",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": {
                        "account": "str",
                        "artifact": {
                            "kind": "str",
                            "huggingFaceCache": {
                                "repoID": "str",
                                "revision": "str"
                            }
                        },
                        "id": "str",
                        "name": "str",
                        "storage": {
                            "medium": "str"
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ],
                    "reason": "str",
                    "runner": {
                        "kind": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "args": [
                            "str"
                        ],
                        "image": {
                            "digest": "str",
                            "host": "str",
                            "name": "str",
                            "tag": "str"
                        }
                    },
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create an InferenceService.

        Create an InferenceService.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "interface": {
                        "endpoint": "str",
                        "outputSchema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "name": "str",
                    "builder": {
                        "kind": "str",
                        "args": [
                            "str"
                        ]
                    },
                    "model": "str",
                    "outputViews": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ],
                    "runner": {
                        "kind": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "args": [
                            "str"
                        ],
                        "image": {
                            "digest": "str",
                            "host": "str",
                            "name": "str",
                            "tag": "str"
                        }
                    },
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "interface": {
                        "endpoint": "str",
                        "outputSchema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "builder": {
                        "kind": "str",
                        "args": [
                            "str"
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "InferenceService",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": {
                        "account": "str",
                        "artifact": {
                            "kind": "str",
                            "huggingFaceCache": {
                                "repoID": "str",
                                "revision": "str"
                            }
                        },
                        "id": "str",
                        "name": "str",
                        "storage": {
                            "medium": "str"
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ],
                    "reason": "str",
                    "runner": {
                        "kind": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "args": [
                            "str"
                        ],
                        "image": {
                            "digest": "str",
                            "host": "str",
                            "name": "str",
                            "tag": "str"
                        }
                    },
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferenceservices_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, service_id: str, **kwargs: Any) -> JSON:
        """Get an InferenceService by its key.

        Get an InferenceService by its key.

        Raises a 404 error if no entity exists with that key.

        :param service_id: Required.
        :type service_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "interface": {
                        "endpoint": "str",
                        "outputSchema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "inputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ],
                        "outputPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "builder": {
                        "kind": "str",
                        "args": [
                            "str"
                        ]
                    },
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "InferenceService",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": {
                        "account": "str",
                        "artifact": {
                            "kind": "str",
                            "huggingFaceCache": {
                                "repoID": "str",
                                "revision": "str"
                            }
                        },
                        "id": "str",
                        "name": "str",
                        "storage": {
                            "medium": "str"
                        }
                    },
                    "outputViews": [
                        {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        }
                    ],
                    "reason": "str",
                    "runner": {
                        "kind": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "args": [
                            "str"
                        ],
                        "image": {
                            "digest": "str",
                            "host": "str",
                            "name": "str",
                            "tag": "str"
                        }
                    },
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferenceservices_get_request(
            service_id=service_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, service_id: str, **kwargs: Any) -> JSON:
        """Mark an InferenceService for deletion.

        Mark an InferenceService for deletion.

        :param service_id: Required.
        :type service_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferenceservices_delete_request(
            service_id=service_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def documentation(self, service_id: str, **kwargs: Any) -> JSON:
        """Get the documentation associated with an InferenceService.

        Get the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key.

        :param service_id: Required.
        :type service_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferenceservices_documentation_request(
            service_id=service_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def edit_documentation(
        self,
        service_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with an InferenceService.

        Edit the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @overload
    def edit_documentation(
        self,
        service_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with an InferenceService.

        Edit the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param service_id: Required.
        :type service_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @distributed_trace
    def edit_documentation(
        self, service_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        """Edit the documentation associated with an InferenceService.

        Edit the documentation associated with an InferenceService.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param service_id: Required.
        :type service_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferenceservices_edit_documentation_request(
            service_id=service_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class InferencesessionsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`inferencesessions` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        session_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing InferenceSession.

        Update labels for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        session_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing InferenceSession.

        Update labels for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(
        self, session_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Update labels for an existing InferenceSession.

        Update labels for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferencesessions_label_request(
            session_id=session_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        inference_service: Optional[str] = None,
        inference_service_name: Optional[str] = None,
        model: Optional[str] = None,
        model_name: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all InferenceSessions matching a query.

        Get all InferenceSessions matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword inference_service_name: Default value is None.
        :paramtype inference_service_name: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword model_name: Default value is None.
        :paramtype model_name: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "id": "str",
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "expires": "2020-02-20 00:00:00",
                        "kind": "InferenceSession",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "replicas": 1,
                        "schemaVersion": "0.1",
                        "status": "str",
                        "useSpotPods": True
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_inferencesessions_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            inference_service=inference_service,
            inference_service_name=inference_service_name,
            model=model,
            model_name=model_name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an InferenceSession.

        Create an InferenceSession.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "inferenceService": "str",
                    "accelerator": {
                        "kind": "str",
                        "gpu": {
                            "hardwareTypes": [
                                "str"
                            ],
                            "count": 1,
                            "memory": "str"
                        }
                    },
                    "expires": "2020-02-20 00:00:00",
                    "replicas": 1,
                    "schemaVersion": "0.1",
                    "useSpotPods": True
                }

                # response body for status code(s): 200
                response == {
                    "inferencesession": {
                        "account": "str",
                        "id": "str",
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "expires": "2020-02-20 00:00:00",
                        "kind": "InferenceSession",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "replicas": 1,
                        "schemaVersion": "0.1",
                        "status": "str",
                        "useSpotPods": True
                    },
                    "token": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create an InferenceSession.

        Create an InferenceSession.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "inferencesession": {
                        "account": "str",
                        "id": "str",
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "expires": "2020-02-20 00:00:00",
                        "kind": "InferenceSession",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "replicas": 1,
                        "schemaVersion": "0.1",
                        "status": "str",
                        "useSpotPods": True
                    },
                    "token": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create an InferenceSession.

        Create an InferenceSession.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "inferenceService": "str",
                    "accelerator": {
                        "kind": "str",
                        "gpu": {
                            "hardwareTypes": [
                                "str"
                            ],
                            "count": 1,
                            "memory": "str"
                        }
                    },
                    "expires": "2020-02-20 00:00:00",
                    "replicas": 1,
                    "schemaVersion": "0.1",
                    "useSpotPods": True
                }

                # response body for status code(s): 200
                response == {
                    "inferencesession": {
                        "account": "str",
                        "id": "str",
                        "inferenceService": {
                            "account": "str",
                            "id": "str",
                            "interface": {
                                "endpoint": "str",
                                "outputSchema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "inputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ],
                                "outputPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            },
                            "name": "str",
                            "builder": {
                                "kind": "str",
                                "args": [
                                    "str"
                                ]
                            },
                            "model": {
                                "account": "str",
                                "artifact": {
                                    "kind": "str",
                                    "huggingFaceCache": {
                                        "repoID": "str",
                                        "revision": "str"
                                    }
                                },
                                "id": "str",
                                "name": "str",
                                "storage": {
                                    "medium": "str"
                                }
                            },
                            "outputViews": [
                                {
                                    "id": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "viewOf": "str",
                                    "adapterPipeline": [
                                        {
                                            "kind": "str",
                                            "configuration": {}
                                        }
                                    ]
                                }
                            ],
                            "runner": {
                                "kind": "str",
                                "resources": {
                                    "storage": "str",
                                    "memory": "str"
                                },
                                "accelerator": {
                                    "kind": "str",
                                    "gpu": {
                                        "hardwareTypes": [
                                            "str"
                                        ],
                                        "count": 1,
                                        "memory": "str"
                                    }
                                },
                                "args": [
                                    "str"
                                ],
                                "image": {
                                    "digest": "str",
                                    "host": "str",
                                    "name": "str",
                                    "tag": "str"
                                }
                            }
                        },
                        "accelerator": {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "expires": "2020-02-20 00:00:00",
                        "kind": "InferenceSession",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "replicas": 1,
                        "schemaVersion": "0.1",
                        "status": "str",
                        "useSpotPods": True
                    },
                    "token": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferencesessions_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, session_id: str, **kwargs: Any) -> JSON:
        """Get an InferenceSession by its key.

        Get an InferenceSession by its key.

        Raises a 404 error if no entity exists with that key.

        :param session_id: Required.
        :type session_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "inferenceService": {
                        "account": "str",
                        "id": "str",
                        "interface": {
                            "endpoint": "str",
                            "outputSchema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "inputPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ],
                            "outputPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        },
                        "name": "str",
                        "builder": {
                            "kind": "str",
                            "args": [
                                "str"
                            ]
                        },
                        "model": {
                            "account": "str",
                            "artifact": {
                                "kind": "str",
                                "huggingFaceCache": {
                                    "repoID": "str",
                                    "revision": "str"
                                }
                            },
                            "id": "str",
                            "name": "str",
                            "storage": {
                                "medium": "str"
                            }
                        },
                        "outputViews": [
                            {
                                "id": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "viewOf": "str",
                                "adapterPipeline": [
                                    {
                                        "kind": "str",
                                        "configuration": {}
                                    }
                                ]
                            }
                        ],
                        "runner": {
                            "kind": "str",
                            "resources": {
                                "storage": "str",
                                "memory": "str"
                            },
                            "accelerator": {
                                "kind": "str",
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"
                                    ],
                                    "count": 1,
                                    "memory": "str"
                                }
                            },
                            "args": [
                                "str"
                            ],
                            "image": {
                                "digest": "str",
                                "host": "str",
                                "name": "str",
                                "tag": "str"
                            }
                        }
                    },
                    "accelerator": {
                        "kind": "str",
                        "gpu": {
                            "hardwareTypes": [
                                "str"
                            ],
                            "count": 1,
                            "memory": "str"
                        }
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "expires": "2020-02-20 00:00:00",
                    "kind": "InferenceSession",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "replicas": 1,
                    "schemaVersion": "0.1",
                    "status": "str",
                    "useSpotPods": True
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferencesessions_get_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, session_id: str, **kwargs: Any) -> JSON:
        """Mark an InferenceSession for deletion.

        Mark an InferenceSession for deletion.

        :param session_id: Required.
        :type session_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferencesessions_delete_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def terminate(self, session_id: str, **kwargs: Any) -> JSON:
        """Terminate an InferenceSession.

        Terminate an InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_inferencesessions_terminate_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def infer(self, session_id: str, inference_endpoint: str, **kwargs: Any) -> Any:
        """Create an InferenceSession.

        Create an InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param inference_endpoint: Required.
        :type inference_endpoint: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_inferencesessions_infer_request(
            session_id=session_id,
            inference_endpoint=inference_endpoint,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @overload
    def token(
        self,
        session_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> str:
        """Get an access token for an existing InferenceSession.

        Get an access token for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "expires": "2020-02-20 00:00:00",
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def token(
        self,
        session_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> str:
        """Get an access token for an existing InferenceSession.

        Get an access token for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: str
        :rtype: str :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def token(
        self, session_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> str:
        """Get an access token for an existing InferenceSession.

        Get an access token for an existing InferenceSession.

        :param session_id: Required.
        :type session_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: str
        :rtype: str
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "expires": "2020-02-20 00:00:00",
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[str] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_inferencesessions_token_request(
            session_id=session_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(str, deserialized), {})  # type: ignore

        return cast(str, deserialized)  # type: ignore

    @distributed_trace
    def ready(self, session_id: str, **kwargs: Any) -> Any:
        """Perform a readiness probe on the session.

        Check if an InferenceSession is ready. Returns status 200 if the session is
        ready. Raises a 503 (ServiceUnavailable) error if the session is not ready.

        Raises a 404 error if no session exists with the provided ID. Note that this may
        happen temporarily for session that were created recently, as it takes time for
        status information to propagate through the platform.

        :param session_id: Required.
        :type session_id: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_inferencesessions_ready_request(
            session_id=session_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore


class MeasurementsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`measurements` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        measurement_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Measurement.

        Update labels for an existing Measurement.

        :param measurement_id: Required.
        :type measurement_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        measurement_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Measurement.

        Update labels for an existing Measurement.

        :param measurement_id: Required.
        :type measurement_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(
        self, measurement_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Update labels for an existing Measurement.

        Update labels for an existing Measurement.

        :param measurement_id: Required.
        :type measurement_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_measurements_label_request(
            measurement_id=measurement_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        method: Optional[str] = None,
        method_name: Optional[str] = None,
        dataset: Optional[str] = None,
        evaluation: Optional[str] = None,
        inference_service: Optional[str] = None,
        model: Optional[str] = None,
        inputs: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Measurements matching a query.

        Get all Measurements matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword method: Default value is None.
        :paramtype method: str
        :keyword method_name: Default value is None.
        :paramtype method_name: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword evaluation: Default value is None.
        :paramtype evaluation: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword inputs: Default value is None.
        :paramtype inputs: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "id": "str",
                        "level": "str",
                        "method": {
                            "account": "str",
                            "id": "str",
                            "implementation": {
                                "kind": "str",
                                "jupyterNotebook": {
                                    "notebookModule": "str",
                                    "notebookPath": "str"
                                },
                                "pythonFunction": {
                                    "fullyQualifiedName": "str"
                                },
                                "pythonRubric": {
                                    "fullyQualifiedName": "str"
                                }
                            },
                            "name": "str",
                            "output": {
                                "kind": "str",
                                "measurement": {
                                    "level": "str",
                                    "name": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "description": "str"
                                },
                                "safetyCase": {
                                    "name": "str",
                                    "description": "str"
                                }
                            },
                            "scope": "str",
                            "description": "str",
                            "inputs": [
                                {
                                    "keyword": "str",
                                    "kind": "str",
                                    "description": "str"
                                }
                            ],
                            "modules": [
                                "str"
                            ],
                            "parameters": [
                                {
                                    "keyword": "str",
                                    "description": "str"
                                }
                            ],
                            "scores": [
                                {
                                    "name": "str",
                                    "summary": "str",
                                    "title": "str",
                                    "format": "{quantity:.1f}",
                                    "maximum": 0.0,
                                    "minimum": 0.0,
                                    "priority": "primary",
                                    "unit": "str",
                                    "valence": "neutral"
                                }
                            ]
                        },
                        "name": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "arguments": [
                            {
                                "keyword": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "data": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "description": "str",
                        "inputs": [
                            {
                                "entity": "str",
                                "keyword": "str"
                            }
                        ],
                        "kind": "Measurement",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "scope": {
                            "dataset": "str",
                            "evaluation": "str",
                            "inferenceService": "str",
                            "model": "str"
                        },
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_measurements_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            method=method,
            method_name=method_name,
            dataset=dataset,
            evaluation=evaluation,
            inference_service=inference_service,
            model=model,
            inputs=inputs,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Measurement.

        Create a Measurement.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "method": "str",
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "level": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "Measurement",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Measurement.

        Create a Measurement.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "level": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "Measurement",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a Measurement.

        Create a Measurement.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "method": "str",
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "level": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "Measurement",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_measurements_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, measurement_id: str, **kwargs: Any) -> JSON:
        """Get a Measurement by its key.

        Get a Measurement by its key.

        Raises a 404 error if no entity exists with that key.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "level": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "schema": {
                        "arrowSchema": "str",
                        "dyffSchema": {
                            "components": [
                                "str"
                            ],
                            "schemaVersion": "0.1"
                        },
                        "jsonSchema": {}
                    },
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "Measurement",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_measurements_get_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, measurement_id: str, **kwargs: Any) -> JSON:
        """Mark a Measurement for deletion.

        Mark a Measurement for deletion.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_measurements_delete_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def downlinks(self, measurement_id: str, **kwargs: Any) -> List[JSON]:
        """Get a list of signed GET URLs from which measurement artifacts can be
        downloaded.

        Get a list of signed GET URLs from which measurement artifacts can be downloaded.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        },
                        "signedURL": {
                            "method": "str",
                            "url": "str",
                            "headers": {
                                "str": "str"
                            }
                        }
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_measurements_downlinks_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def logs(self, measurement_id: str, **kwargs: Any) -> JSON:
        """Get a signed GET URL from which the logs file for the measurement run can be
        downloaded.

        Get a signed GET URL from which the logs file for the measurement run can be downloaded.

        :param measurement_id: Required.
        :type measurement_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifact": {
                        "path": "str",
                        "digest": {
                            "md5": "str"
                        },
                        "kind": "str"
                    },
                    "signedURL": {
                        "method": "str",
                        "url": "str",
                        "headers": {
                            "str": "str"
                        }
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_measurements_logs_request(
            measurement_id=measurement_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class MethodsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`methods` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        method_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Method.

        Update labels for an existing Method.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        method_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Method.

        Update labels for an existing Method.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(self, method_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> Any:
        """Update labels for an existing Method.

        Update labels for an existing Method.

        :param method_id: Required.
        :type method_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_methods_label_request(
            method_id=method_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        output_kind: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Methods matching a query.

        Get all Methods matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :keyword output_kind: Default value is None.
        :paramtype output_kind: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "kind": "Method",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ],
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_methods_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            output_kind=output_kind,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Method.

        Create a Method.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "implementation": {
                        "kind": "str",
                        "jupyterNotebook": {
                            "notebookModule": "str",
                            "notebookPath": "str"
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"
                        }
                    },
                    "name": "str",
                    "output": {
                        "kind": "str",
                        "measurement": {
                            "level": "str",
                            "name": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "description": "str"
                        },
                        "safetyCase": {
                            "name": "str",
                            "description": "str"
                        }
                    },
                    "scope": "str",
                    "description": "str",
                    "inputs": [
                        {
                            "keyword": "str",
                            "kind": "str",
                            "description": "str"
                        }
                    ],
                    "modules": [
                        "str"
                    ],
                    "parameters": [
                        {
                            "keyword": "str",
                            "description": "str"
                        }
                    ],
                    "schemaVersion": "0.1",
                    "scores": [
                        {
                            "name": "str",
                            "summary": "str",
                            "title": "str",
                            "format": "{quantity:.1f}",
                            "maximum": 0.0,
                            "minimum": 0.0,
                            "priority": "primary",
                            "unit": "str",
                            "valence": "neutral"
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "implementation": {
                        "kind": "str",
                        "jupyterNotebook": {
                            "notebookModule": "str",
                            "notebookPath": "str"
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"
                        }
                    },
                    "name": "str",
                    "output": {
                        "kind": "str",
                        "measurement": {
                            "level": "str",
                            "name": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "description": "str"
                        },
                        "safetyCase": {
                            "name": "str",
                            "description": "str"
                        }
                    },
                    "scope": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "description": "str",
                    "inputs": [
                        {
                            "keyword": "str",
                            "kind": "str",
                            "description": "str"
                        }
                    ],
                    "kind": "Method",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "modules": [
                        "str"
                    ],
                    "parameters": [
                        {
                            "keyword": "str",
                            "description": "str"
                        }
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scores": [
                        {
                            "name": "str",
                            "summary": "str",
                            "title": "str",
                            "format": "{quantity:.1f}",
                            "maximum": 0.0,
                            "minimum": 0.0,
                            "priority": "primary",
                            "unit": "str",
                            "valence": "neutral"
                        }
                    ],
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Method.

        Create a Method.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "implementation": {
                        "kind": "str",
                        "jupyterNotebook": {
                            "notebookModule": "str",
                            "notebookPath": "str"
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"
                        }
                    },
                    "name": "str",
                    "output": {
                        "kind": "str",
                        "measurement": {
                            "level": "str",
                            "name": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "description": "str"
                        },
                        "safetyCase": {
                            "name": "str",
                            "description": "str"
                        }
                    },
                    "scope": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "description": "str",
                    "inputs": [
                        {
                            "keyword": "str",
                            "kind": "str",
                            "description": "str"
                        }
                    ],
                    "kind": "Method",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "modules": [
                        "str"
                    ],
                    "parameters": [
                        {
                            "keyword": "str",
                            "description": "str"
                        }
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scores": [
                        {
                            "name": "str",
                            "summary": "str",
                            "title": "str",
                            "format": "{quantity:.1f}",
                            "maximum": 0.0,
                            "minimum": 0.0,
                            "priority": "primary",
                            "unit": "str",
                            "valence": "neutral"
                        }
                    ],
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a Method.

        Create a Method.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "implementation": {
                        "kind": "str",
                        "jupyterNotebook": {
                            "notebookModule": "str",
                            "notebookPath": "str"
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"
                        }
                    },
                    "name": "str",
                    "output": {
                        "kind": "str",
                        "measurement": {
                            "level": "str",
                            "name": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "description": "str"
                        },
                        "safetyCase": {
                            "name": "str",
                            "description": "str"
                        }
                    },
                    "scope": "str",
                    "description": "str",
                    "inputs": [
                        {
                            "keyword": "str",
                            "kind": "str",
                            "description": "str"
                        }
                    ],
                    "modules": [
                        "str"
                    ],
                    "parameters": [
                        {
                            "keyword": "str",
                            "description": "str"
                        }
                    ],
                    "schemaVersion": "0.1",
                    "scores": [
                        {
                            "name": "str",
                            "summary": "str",
                            "title": "str",
                            "format": "{quantity:.1f}",
                            "maximum": 0.0,
                            "minimum": 0.0,
                            "priority": "primary",
                            "unit": "str",
                            "valence": "neutral"
                        }
                    ]
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "implementation": {
                        "kind": "str",
                        "jupyterNotebook": {
                            "notebookModule": "str",
                            "notebookPath": "str"
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"
                        }
                    },
                    "name": "str",
                    "output": {
                        "kind": "str",
                        "measurement": {
                            "level": "str",
                            "name": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "description": "str"
                        },
                        "safetyCase": {
                            "name": "str",
                            "description": "str"
                        }
                    },
                    "scope": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "description": "str",
                    "inputs": [
                        {
                            "keyword": "str",
                            "kind": "str",
                            "description": "str"
                        }
                    ],
                    "kind": "Method",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "modules": [
                        "str"
                    ],
                    "parameters": [
                        {
                            "keyword": "str",
                            "description": "str"
                        }
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scores": [
                        {
                            "name": "str",
                            "summary": "str",
                            "title": "str",
                            "format": "{quantity:.1f}",
                            "maximum": 0.0,
                            "minimum": 0.0,
                            "priority": "primary",
                            "unit": "str",
                            "valence": "neutral"
                        }
                    ],
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_methods_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, method_id: str, **kwargs: Any) -> JSON:
        """Get a Method by its key.

        Get a Method by its key.

        Raises a 404 error if no entity exists with that key.

        :param method_id: Required.
        :type method_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "implementation": {
                        "kind": "str",
                        "jupyterNotebook": {
                            "notebookModule": "str",
                            "notebookPath": "str"
                        },
                        "pythonFunction": {
                            "fullyQualifiedName": "str"
                        },
                        "pythonRubric": {
                            "fullyQualifiedName": "str"
                        }
                    },
                    "name": "str",
                    "output": {
                        "kind": "str",
                        "measurement": {
                            "level": "str",
                            "name": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "description": "str"
                        },
                        "safetyCase": {
                            "name": "str",
                            "description": "str"
                        }
                    },
                    "scope": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "description": "str",
                    "inputs": [
                        {
                            "keyword": "str",
                            "kind": "str",
                            "description": "str"
                        }
                    ],
                    "kind": "Method",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "modules": [
                        "str"
                    ],
                    "parameters": [
                        {
                            "keyword": "str",
                            "description": "str"
                        }
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scores": [
                        {
                            "name": "str",
                            "summary": "str",
                            "title": "str",
                            "format": "{quantity:.1f}",
                            "maximum": 0.0,
                            "minimum": 0.0,
                            "priority": "primary",
                            "unit": "str",
                            "valence": "neutral"
                        }
                    ],
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_methods_get_request(
            method_id=method_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, method_id: str, **kwargs: Any) -> JSON:
        """Mark a Method for deletion.

        Mark a Method for deletion.

        :param method_id: Required.
        :type method_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_methods_delete_request(
            method_id=method_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def documentation(self, method_id: str, **kwargs: Any) -> JSON:
        """Get the documentation associated with a Method.

        Get the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key.

        :param method_id: Required.
        :type method_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_methods_documentation_request(
            method_id=method_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def edit_documentation(
        self,
        method_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Method.

        Edit the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @overload
    def edit_documentation(
        self,
        method_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Method.

        Edit the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param method_id: Required.
        :type method_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @distributed_trace
    def edit_documentation(
        self, method_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        """Edit the documentation associated with a Method.

        Edit the documentation associated with a Method.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param method_id: Required.
        :type method_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_methods_edit_documentation_request(
            method_id=method_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ModelsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`models` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        model_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Model.

        Update labels for an existing Model.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        model_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Model.

        Update labels for an existing Model.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(self, model_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> Any:
        """Update labels for an existing Model.

        Update labels for an existing Model.

        :param model_id: Required.
        :type model_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_models_label_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Models matching a query.

        Get all Models matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "artifact": {
                            "kind": "str",
                            "huggingFaceCache": {
                                "repoID": "str",
                                "revision": "str"
                            }
                        },
                        "id": "str",
                        "name": "str",
                        "resources": {
                            "storage": "str",
                            "memory": "str"
                        },
                        "source": {
                            "kind": "str",
                            "gitLFS": {
                                "url": "str"
                            },
                            "huggingFaceHub": {
                                "repoID": "str",
                                "revision": "str",
                                "allowPatterns": [
                                    "str"
                                ],
                                "ignorePatterns": [
                                    "str"
                                ]
                            },
                            "openLLM": {
                                "modelID": "str",
                                "modelKind": "str",
                                "modelVersion": "str"
                            }
                        },
                        "storage": {
                            "medium": "str"
                        },
                        "accelerators": [
                            {
                                "kind": "str",
                                "gpu": {
                                    "hardwareTypes": [
                                        "str"
                                    ],
                                    "count": 1,
                                    "memory": "str"
                                }
                            }
                        ],
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "kind": "Model",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_models_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Model.

        Create a Model.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "artifact": {
                        "kind": "str",
                        "huggingFaceCache": {
                            "repoID": "str",
                            "revision": "str"
                        }
                    },
                    "name": "str",
                    "resources": {
                        "storage": "str",
                        "memory": "str"
                    },
                    "source": {
                        "kind": "str",
                        "gitLFS": {
                            "url": "str"
                        },
                        "huggingFaceHub": {
                            "repoID": "str",
                            "revision": "str",
                            "allowPatterns": [
                                "str"
                            ],
                            "ignorePatterns": [
                                "str"
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",
                            "modelKind": "str",
                            "modelVersion": "str"
                        }
                    },
                    "storage": {
                        "medium": "str"
                    },
                    "accelerators": [
                        {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        }
                    ],
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifact": {
                        "kind": "str",
                        "huggingFaceCache": {
                            "repoID": "str",
                            "revision": "str"
                        }
                    },
                    "id": "str",
                    "name": "str",
                    "resources": {
                        "storage": "str",
                        "memory": "str"
                    },
                    "source": {
                        "kind": "str",
                        "gitLFS": {
                            "url": "str"
                        },
                        "huggingFaceHub": {
                            "repoID": "str",
                            "revision": "str",
                            "allowPatterns": [
                                "str"
                            ],
                            "ignorePatterns": [
                                "str"
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",
                            "modelKind": "str",
                            "modelVersion": "str"
                        }
                    },
                    "storage": {
                        "medium": "str"
                    },
                    "accelerators": [
                        {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Model",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Model.

        Create a Model.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifact": {
                        "kind": "str",
                        "huggingFaceCache": {
                            "repoID": "str",
                            "revision": "str"
                        }
                    },
                    "id": "str",
                    "name": "str",
                    "resources": {
                        "storage": "str",
                        "memory": "str"
                    },
                    "source": {
                        "kind": "str",
                        "gitLFS": {
                            "url": "str"
                        },
                        "huggingFaceHub": {
                            "repoID": "str",
                            "revision": "str",
                            "allowPatterns": [
                                "str"
                            ],
                            "ignorePatterns": [
                                "str"
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",
                            "modelKind": "str",
                            "modelVersion": "str"
                        }
                    },
                    "storage": {
                        "medium": "str"
                    },
                    "accelerators": [
                        {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Model",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a Model.

        Create a Model.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "artifact": {
                        "kind": "str",
                        "huggingFaceCache": {
                            "repoID": "str",
                            "revision": "str"
                        }
                    },
                    "name": "str",
                    "resources": {
                        "storage": "str",
                        "memory": "str"
                    },
                    "source": {
                        "kind": "str",
                        "gitLFS": {
                            "url": "str"
                        },
                        "huggingFaceHub": {
                            "repoID": "str",
                            "revision": "str",
                            "allowPatterns": [
                                "str"
                            ],
                            "ignorePatterns": [
                                "str"
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",
                            "modelKind": "str",
                            "modelVersion": "str"
                        }
                    },
                    "storage": {
                        "medium": "str"
                    },
                    "accelerators": [
                        {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        }
                    ],
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifact": {
                        "kind": "str",
                        "huggingFaceCache": {
                            "repoID": "str",
                            "revision": "str"
                        }
                    },
                    "id": "str",
                    "name": "str",
                    "resources": {
                        "storage": "str",
                        "memory": "str"
                    },
                    "source": {
                        "kind": "str",
                        "gitLFS": {
                            "url": "str"
                        },
                        "huggingFaceHub": {
                            "repoID": "str",
                            "revision": "str",
                            "allowPatterns": [
                                "str"
                            ],
                            "ignorePatterns": [
                                "str"
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",
                            "modelKind": "str",
                            "modelVersion": "str"
                        }
                    },
                    "storage": {
                        "medium": "str"
                    },
                    "accelerators": [
                        {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Model",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_models_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, model_id: str, **kwargs: Any) -> JSON:
        """Get a Model by its key.

        Get a Model by its key.

        Raises a 404 error if no entity exists with that key.

        :param model_id: Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifact": {
                        "kind": "str",
                        "huggingFaceCache": {
                            "repoID": "str",
                            "revision": "str"
                        }
                    },
                    "id": "str",
                    "name": "str",
                    "resources": {
                        "storage": "str",
                        "memory": "str"
                    },
                    "source": {
                        "kind": "str",
                        "gitLFS": {
                            "url": "str"
                        },
                        "huggingFaceHub": {
                            "repoID": "str",
                            "revision": "str",
                            "allowPatterns": [
                                "str"
                            ],
                            "ignorePatterns": [
                                "str"
                            ]
                        },
                        "openLLM": {
                            "modelID": "str",
                            "modelKind": "str",
                            "modelVersion": "str"
                        }
                    },
                    "storage": {
                        "medium": "str"
                    },
                    "accelerators": [
                        {
                            "kind": "str",
                            "gpu": {
                                "hardwareTypes": [
                                    "str"
                                ],
                                "count": 1,
                                "memory": "str"
                            }
                        }
                    ],
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Model",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_models_get_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, model_id: str, **kwargs: Any) -> JSON:
        """Mark a Model for deletion.

        Mark a Model for deletion.

        :param model_id: Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_models_delete_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def documentation(self, model_id: str, **kwargs: Any) -> JSON:
        """Get the documentation associated with a Model.

        Get the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key.

        :param model_id: Required.
        :type model_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_models_documentation_request(
            model_id=model_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def edit_documentation(
        self,
        model_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Model.

        Edit the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @overload
    def edit_documentation(
        self,
        model_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Model.

        Edit the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param model_id: Required.
        :type model_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @distributed_trace
    def edit_documentation(
        self, model_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        """Edit the documentation associated with a Model.

        Edit the documentation associated with a Model.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param model_id: Required.
        :type model_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_models_edit_documentation_request(
            model_id=model_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ModulesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`modules` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        module_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Module.

        Update labels for an existing Module.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        module_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Module.

        Update labels for an existing Module.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(self, module_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> Any:
        """Update labels for an existing Module.

        Update labels for an existing Module.

        :param module_id: Required.
        :type module_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_modules_label_request(
            module_id=module_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        name: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Modules matching a query.

        Get all Modules matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword name: Default value is None.
        :paramtype name: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "artifacts": [
                            {
                                "path": "str",
                                "digest": {
                                    "md5": "str"
                                },
                                "kind": "str"
                            }
                        ],
                        "id": "str",
                        "name": "str",
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "kind": "Module",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_modules_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            name=name,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Module.

        Create a Module.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "name": "str",
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Module",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Module.

        Create a Module.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Module",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a Module.

        Create a Module.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "name": "str",
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Module",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_modules_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, module_id: str, **kwargs: Any) -> JSON:
        """Get a Module by its key.

        Get a Module by its key.

        Raises a 404 error if no entity exists with that key.

        :param module_id: Required.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "artifacts": [
                        {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        }
                    ],
                    "id": "str",
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "kind": "Module",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_get_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, module_id: str, **kwargs: Any) -> JSON:
        """Mark a Module for deletion.

        Mark a Module for deletion.

        :param module_id: Required.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_delete_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def upload(self, module_id: str, artifact_path: str, **kwargs: Any) -> JSON:
        """Get a signed URL to which the given artifact can be uploaded.

        Get a signed URL to which the given artifact can be uploaded.

        :param module_id: Required.
        :type module_id: str
        :param artifact_path: Required.
        :type artifact_path: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "method": "str",
                    "url": "str",
                    "headers": {
                        "str": "str"
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_upload_request(
            module_id=module_id,
            artifact_path=artifact_path,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def finalize(self, module_id: str, **kwargs: Any) -> Any:
        """Indicate that all module artifacts have been uploaded.

        Indicate that all module artifacts have been uploaded.

        :param module_id: Required.
        :type module_id: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[Any] = kwargs.pop("cls", None)

        _request = build_modules_finalize_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def downlinks(self, module_id: str, **kwargs: Any) -> List[JSON]:
        """Get a list of signed GET URLs from which Module artifacts can be downloaded.

        Get a list of signed GET URLs from which Module artifacts can be downloaded.

        :param module_id: Required.
        :type module_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        },
                        "signedURL": {
                            "method": "str",
                            "url": "str",
                            "headers": {
                                "str": "str"
                            }
                        }
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_modules_downlinks_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def documentation(self, module_id: str, **kwargs: Any) -> JSON:
        """Get the documentation associated with a Module.

        Get the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key.

        :param module_id: Required.
        :type module_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_modules_documentation_request(
            module_id=module_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def edit_documentation(
        self,
        module_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Module.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @overload
    def edit_documentation(
        self,
        module_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> JSON:
        """Edit the documentation associated with a Module.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param module_id: Required.
        :type module_id: str
        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @distributed_trace
    def edit_documentation(
        self, module_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> JSON:
        """Edit the documentation associated with a Module.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key. Returns the
        modified Documentation.

        :param module_id: Required.
        :type module_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }

                # response body for status code(s): 200
                response == {
                    "entity": "str",
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_modules_edit_documentation_request(
            module_id=module_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class UsecasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`usecases` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @distributed_trace
    def get(self, id: str, **kwargs: Any) -> JSON:
        """Get a UseCase by its key.

        Get a UseCase by its key.

        Raises a 404 error if no entity exists with that key.

        :param id: Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "documentation": {
                        "fullPage": "str",
                        "summary": "str",
                        "title": "str"
                    },
                    "kind": "UseCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_usecases_get_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all UseCases matching a query.

        Get all UseCases matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "id": "str",
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "documentation": {
                            "fullPage": "str",
                            "summary": "str",
                            "title": "str"
                        },
                        "kind": "UseCase",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_usecases_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a UseCase.

        Create a UseCase.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "documentation": {
                        "fullPage": "str",
                        "summary": "str",
                        "title": "str"
                    },
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "documentation": {
                        "fullPage": "str",
                        "summary": "str",
                        "title": "str"
                    },
                    "kind": "UseCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a UseCase.

        Create a UseCase.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "documentation": {
                        "fullPage": "str",
                        "summary": "str",
                        "title": "str"
                    },
                    "kind": "UseCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a UseCase.

        Create a UseCase.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "documentation": {
                        "fullPage": "str",
                        "summary": "str",
                        "title": "str"
                    },
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "documentation": {
                        "fullPage": "str",
                        "summary": "str",
                        "title": "str"
                    },
                    "kind": "UseCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_usecases_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @overload
    def label(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing UseCase.

        Update labels for an existing UseCase.

        :param id: Required.
        :type id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing UseCase.

        Update labels for an existing UseCase.

        :param id: Required.
        :type id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(self, id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> Any:
        """Update labels for an existing UseCase.

        Update labels for an existing UseCase.

        :param id: Required.
        :type id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_usecases_label_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @overload
    def edit_documentation(
        self,
        id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Edit the documentation associated with a UseCase.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key.

        :param id: Required.
        :type id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """

    @overload
    def edit_documentation(
        self,
        id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Edit the documentation associated with a UseCase.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key.

        :param id: Required.
        :type id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def edit_documentation(
        self, id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Edit the documentation associated with a UseCase.

        Edit the documentation associated with a Module.

        Raises a 404 error if no entity exists with that key.

        :param id: Required.
        :type id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "fullPage": "str",
                    "schemaVersion": "0.1",
                    "summary": "str",
                    "title": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_usecases_edit_documentation_request(
            id=id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, id: str, **kwargs: Any) -> JSON:
        """Mark a UseCase for deletion.

        Mark a UseCase for deletion.

        :param id: Required.
        :type id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_usecases_delete_request(
            id=id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class ReportsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`reports` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        report_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Report.

        Update labels for an existing Report.

        :param report_id: Required.
        :type report_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        report_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing Report.

        Update labels for an existing Report.

        :param report_id: Required.
        :type report_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(self, report_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any) -> Any:
        """Update labels for an existing Report.

        Update labels for an existing Report.

        :param report_id: Required.
        :type report_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reports_label_request(
            report_id=report_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        report: Optional[str] = None,
        dataset: Optional[str] = None,
        evaluation: Optional[str] = None,
        inference_service: Optional[str] = None,
        model: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all Reports matching a query.

        Get all Reports matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword report: Default value is None.
        :paramtype report: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword evaluation: Default value is None.
        :paramtype evaluation: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword model: Default value is None.
        :paramtype model: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "dataset": "str",
                        "evaluation": "str",
                        "id": "str",
                        "inferenceService": "str",
                        "rubric": "str",
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "datasetView": {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        },
                        "evaluationView": {
                            "id": "str",
                            "schema": {
                                "arrowSchema": "str",
                                "dyffSchema": {
                                    "components": [
                                        "str"
                                    ],
                                    "schemaVersion": "0.1"
                                },
                                "jsonSchema": {}
                            },
                            "viewOf": "str",
                            "adapterPipeline": [
                                {
                                    "kind": "str",
                                    "configuration": {}
                                }
                            ]
                        },
                        "kind": "Report",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "model": "str",
                        "modules": [
                            "str"
                        ],
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_reports_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            report=report,
            dataset=dataset,
            evaluation=evaluation,
            inference_service=inference_service,
            model=model,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Report.

        Create a Report.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "evaluation": "str",
                    "rubric": "str",
                    "datasetView": {},
                    "evaluationView": {},
                    "modules": [
                        "str"
                    ],
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "evaluation": "str",
                    "id": "str",
                    "inferenceService": "str",
                    "rubric": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "datasetView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "kind": "Report",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": "str",
                    "modules": [
                        "str"
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a Report.

        Create a Report.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "evaluation": "str",
                    "id": "str",
                    "inferenceService": "str",
                    "rubric": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "datasetView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "kind": "Report",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": "str",
                    "modules": [
                        "str"
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a Report.

        Create a Report.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "evaluation": "str",
                    "rubric": "str",
                    "datasetView": {},
                    "evaluationView": {},
                    "modules": [
                        "str"
                    ],
                    "schemaVersion": "0.1"
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "evaluation": "str",
                    "id": "str",
                    "inferenceService": "str",
                    "rubric": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "datasetView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "kind": "Report",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": "str",
                    "modules": [
                        "str"
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_reports_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, report_id: str, **kwargs: Any) -> JSON:
        """Get a Report by its key.

        Get a Report by its key.

        Raises a 404 error if no entity exists with that key.

        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "dataset": "str",
                    "evaluation": "str",
                    "id": "str",
                    "inferenceService": "str",
                    "rubric": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "datasetView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "evaluationView": {
                        "id": "str",
                        "schema": {
                            "arrowSchema": "str",
                            "dyffSchema": {
                                "components": [
                                    "str"
                                ],
                                "schemaVersion": "0.1"
                            },
                            "jsonSchema": {}
                        },
                        "viewOf": "str",
                        "adapterPipeline": [
                            {
                                "kind": "str",
                                "configuration": {}
                            }
                        ]
                    },
                    "kind": "Report",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "model": "str",
                    "modules": [
                        "str"
                    ],
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_get_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, report_id: str, **kwargs: Any) -> JSON:
        """Mark a Report for deletion.

        Mark a Report for deletion.

        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_delete_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def downlinks(self, report_id: str, **kwargs: Any) -> List[JSON]:
        """Get a list of signed GET URLs from which Report artifacts can be downloaded.

        Get a list of signed GET URLs from which Report artifacts can be downloaded.

        :param report_id: Required.
        :type report_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        },
                        "signedURL": {
                            "method": "str",
                            "url": "str",
                            "headers": {
                                "str": "str"
                            }
                        }
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_reports_downlinks_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def logs(self, report_id: str, **kwargs: Any) -> JSON:
        """Get a signed GET URL from which the logs file for the report run can be
        downloaded.

        Get a signed GET URL from which the logs file for the report run can be downloaded.

        :param report_id: Required.
        :type report_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifact": {
                        "path": "str",
                        "digest": {
                            "md5": "str"
                        },
                        "kind": "str"
                    },
                    "signedURL": {
                        "method": "str",
                        "url": "str",
                        "headers": {
                            "str": "str"
                        }
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_reports_logs_request(
            report_id=report_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore


class SafetycasesOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~_generated.DyffV0API`'s
        :attr:`safetycases` attribute.
    """

    def __init__(self, *args, **kwargs):
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = (
            input_args.pop(0) if input_args else kwargs.pop("deserializer")
        )

    @overload
    def label(
        self,
        safetycase_id: str,
        body: JSON,
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing SafetyCase.

        Update labels for an existing SafetyCase.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """

    @overload
    def label(
        self,
        safetycase_id: str,
        body: IO[bytes],
        *,
        content_type: str = "application/json",
        **kwargs: Any,
    ) -> Any:
        """Update labels for an existing SafetyCase.

        Update labels for an existing SafetyCase.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :param body: Required.
        :type body: IO[bytes] :keyword content_type: Body Parameter content-type.
            Content type parameter for binary body. Default value is "application/json".
        :paramtype content_type: str
        :return: any
        :rtype: any :raises ~azure.core.exceptions.HttpResponseError:
        """

    @distributed_trace
    def label(
        self, safetycase_id: str, body: Union[JSON, IO[bytes]], **kwargs: Any
    ) -> Any:
        """Update labels for an existing SafetyCase.

        Update labels for an existing SafetyCase.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: any
        :rtype: any
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "labels": {
                        "str": "str"
                    },
                    "schemaVersion": "0.1"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[Any] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_safetycases_label_request(
            safetycase_id=safetycase_id,
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(Any, deserialized), {})  # type: ignore

        return cast(Any, deserialized)  # type: ignore

    @distributed_trace
    def query(
        self,
        *,
        query: Optional[str] = None,
        id: Optional[str] = None,
        account: Optional[str] = None,
        status: Optional[str] = None,
        reason: Optional[str] = None,
        labels: Optional[str] = None,
        method: Optional[str] = None,
        method_name: Optional[str] = None,
        dataset: Optional[str] = None,
        evaluation: Optional[str] = None,
        inference_service: Optional[str] = None,
        model: Optional[str] = None,
        inputs: Optional[str] = None,
        **kwargs: Any,
    ) -> List[JSON]:
        """Get all SafetyCase entities matching a query.

        Get all SafetyCase entities matching a query.

        The query is a set of equality constraints specified as key-value
        pairs.

        :keyword query: Default value is None.
        :paramtype query: str
        :keyword id: Default value is None.
        :paramtype id: str
        :keyword account: Default value is None.
        :paramtype account: str
        :keyword status: Default value is None.
        :paramtype status: str
        :keyword reason: Default value is None.
        :paramtype reason: str
        :keyword labels: Default value is None.
        :paramtype labels: str
        :keyword method: Default value is None.
        :paramtype method: str
        :keyword method_name: Default value is None.
        :paramtype method_name: str
        :keyword dataset: Default value is None.
        :paramtype dataset: str
        :keyword evaluation: Default value is None.
        :paramtype evaluation: str
        :keyword inference_service: Default value is None.
        :paramtype inference_service: str
        :keyword model: Default value is None.
        :paramtype model: str
        :keyword inputs: Default value is None.
        :paramtype inputs: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "account": "str",
                        "id": "str",
                        "method": {
                            "account": "str",
                            "id": "str",
                            "implementation": {
                                "kind": "str",
                                "jupyterNotebook": {
                                    "notebookModule": "str",
                                    "notebookPath": "str"
                                },
                                "pythonFunction": {
                                    "fullyQualifiedName": "str"
                                },
                                "pythonRubric": {
                                    "fullyQualifiedName": "str"
                                }
                            },
                            "name": "str",
                            "output": {
                                "kind": "str",
                                "measurement": {
                                    "level": "str",
                                    "name": "str",
                                    "schema": {
                                        "arrowSchema": "str",
                                        "dyffSchema": {
                                            "components": [
                                                "str"
                                            ],
                                            "schemaVersion": "0.1"
                                        },
                                        "jsonSchema": {}
                                    },
                                    "description": "str"
                                },
                                "safetyCase": {
                                    "name": "str",
                                    "description": "str"
                                }
                            },
                            "scope": "str",
                            "description": "str",
                            "inputs": [
                                {
                                    "keyword": "str",
                                    "kind": "str",
                                    "description": "str"
                                }
                            ],
                            "modules": [
                                "str"
                            ],
                            "parameters": [
                                {
                                    "keyword": "str",
                                    "description": "str"
                                }
                            ],
                            "scores": [
                                {
                                    "name": "str",
                                    "summary": "str",
                                    "title": "str",
                                    "format": "{quantity:.1f}",
                                    "maximum": 0.0,
                                    "minimum": 0.0,
                                    "priority": "primary",
                                    "unit": "str",
                                    "valence": "neutral"
                                }
                            ]
                        },
                        "name": "str",
                        "annotations": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "arguments": [
                            {
                                "keyword": "str",
                                "value": "str"
                            }
                        ],
                        "creationTime": "2020-02-20 00:00:00",
                        "data": [
                            {
                                "key": "str",
                                "value": "str"
                            }
                        ],
                        "description": "str",
                        "inputs": [
                            {
                                "entity": "str",
                                "keyword": "str"
                            }
                        ],
                        "kind": "SafetyCase",
                        "labels": {
                            "str": "str"
                        },
                        "lastTransitionTime": "2020-02-20 00:00:00",
                        "reason": "str",
                        "schemaVersion": "0.1",
                        "scope": {
                            "dataset": "str",
                            "evaluation": "str",
                            "inferenceService": "str",
                            "model": "str"
                        },
                        "status": "str"
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_safetycases_query_request(
            query=query,
            id=id,
            account=account,
            status=status,
            reason=reason,
            labels=labels,
            method=method,
            method_name=method_name,
            dataset=dataset,
            evaluation=evaluation,
            inference_service=inference_service,
            model=model,
            inputs=inputs,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @overload
    def create(
        self, body: JSON, *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a SafetyCase.

        Create a SafetyCase.

        :param body: Required.
        :type body: JSON
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "method": "str",
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "SafetyCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """

    @overload
    def create(
        self, body: IO[bytes], *, content_type: str = "application/json", **kwargs: Any
    ) -> JSON:
        """Create a SafetyCase.

        Create a SafetyCase.

        :param body: Required.
        :type body: IO[bytes]
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "SafetyCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """

    @distributed_trace
    def create(self, body: Union[JSON, IO[bytes]], **kwargs: Any) -> JSON:
        """Create a SafetyCase.

        Create a SafetyCase.

        :param body: Is either a JSON type or a IO[bytes] type. Required.
        :type body: JSON or IO[bytes]
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "account": "str",
                    "method": "str",
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    }
                }

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "SafetyCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type: Optional[str] = kwargs.pop(
            "content_type", _headers.pop("Content-Type", None)
        )
        cls: ClsType[JSON] = kwargs.pop("cls", None)

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IOBase, bytes)):
            _content = body
        else:
            _json = body

        _request = build_safetycases_create_request(
            content_type=content_type,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def get(self, safetycase_id: str, **kwargs: Any) -> JSON:
        """Get a SafetyCase by its key.

        Get a SafetyCase by its key.

        Raises a 404 error if no entity exists with that key.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "account": "str",
                    "id": "str",
                    "method": {
                        "account": "str",
                        "id": "str",
                        "implementation": {
                            "kind": "str",
                            "jupyterNotebook": {
                                "notebookModule": "str",
                                "notebookPath": "str"
                            },
                            "pythonFunction": {
                                "fullyQualifiedName": "str"
                            },
                            "pythonRubric": {
                                "fullyQualifiedName": "str"
                            }
                        },
                        "name": "str",
                        "output": {
                            "kind": "str",
                            "measurement": {
                                "level": "str",
                                "name": "str",
                                "schema": {
                                    "arrowSchema": "str",
                                    "dyffSchema": {
                                        "components": [
                                            "str"
                                        ],
                                        "schemaVersion": "0.1"
                                    },
                                    "jsonSchema": {}
                                },
                                "description": "str"
                            },
                            "safetyCase": {
                                "name": "str",
                                "description": "str"
                            }
                        },
                        "scope": "str",
                        "description": "str",
                        "inputs": [
                            {
                                "keyword": "str",
                                "kind": "str",
                                "description": "str"
                            }
                        ],
                        "modules": [
                            "str"
                        ],
                        "parameters": [
                            {
                                "keyword": "str",
                                "description": "str"
                            }
                        ],
                        "scores": [
                            {
                                "name": "str",
                                "summary": "str",
                                "title": "str",
                                "format": "{quantity:.1f}",
                                "maximum": 0.0,
                                "minimum": 0.0,
                                "priority": "primary",
                                "unit": "str",
                                "valence": "neutral"
                            }
                        ]
                    },
                    "name": "str",
                    "annotations": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "arguments": [
                        {
                            "keyword": "str",
                            "value": "str"
                        }
                    ],
                    "creationTime": "2020-02-20 00:00:00",
                    "data": [
                        {
                            "key": "str",
                            "value": "str"
                        }
                    ],
                    "description": "str",
                    "inputs": [
                        {
                            "entity": "str",
                            "keyword": "str"
                        }
                    ],
                    "kind": "SafetyCase",
                    "labels": {
                        "str": "str"
                    },
                    "lastTransitionTime": "2020-02-20 00:00:00",
                    "reason": "str",
                    "schemaVersion": "0.1",
                    "scope": {
                        "dataset": "str",
                        "evaluation": "str",
                        "inferenceService": "str",
                        "model": "str"
                    },
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_safetycases_get_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def delete(self, safetycase_id: str, **kwargs: Any) -> JSON:
        """Mark a SafetyCase for deletion.

        Mark a SafetyCase for deletion.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "reason": "str",
                    "status": "str"
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_safetycases_delete_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore

    @distributed_trace
    def downlinks(self, safetycase_id: str, **kwargs: Any) -> List[JSON]:
        """Get a list of signed GET URLs from which safety case artifacts can be
        downloaded.

        Get a list of signed GET URLs from which safety case artifacts can be downloaded.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: list of JSON object
        :rtype: list[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == [
                    {
                        "artifact": {
                            "path": "str",
                            "digest": {
                                "md5": "str"
                            },
                            "kind": "str"
                        },
                        "signedURL": {
                            "method": "str",
                            "url": "str",
                            "headers": {
                                "str": "str"
                            }
                        }
                    }
                ]
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[List[JSON]] = kwargs.pop("cls", None)

        _request = build_safetycases_downlinks_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(List[JSON], deserialized), {})  # type: ignore

        return cast(List[JSON], deserialized)  # type: ignore

    @distributed_trace
    def logs(self, safetycase_id: str, **kwargs: Any) -> JSON:
        """Get a signed GET URL from which the logs file for the safety case run can be
        downloaded.

        Get a signed GET URL from which the logs file for the safety case run can be downloaded.

        :param safetycase_id: Required.
        :type safetycase_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "artifact": {
                        "path": "str",
                        "digest": {
                            "md5": "str"
                        },
                        "kind": "str"
                    },
                    "signedURL": {
                        "method": "str",
                        "url": "str",
                        "headers": {
                            "str": "str"
                        }
                    }
                }
        """
        error_map: MutableMapping = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            304: ResourceNotModifiedError,
        }
        error_map.update(kwargs.pop("error_map", {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls: ClsType[JSON] = kwargs.pop("cls", None)

        _request = build_safetycases_logs_request(
            safetycase_id=safetycase_id,
            headers=_headers,
            params=_params,
        )
        _request.url = self._client.format_url(_request.url)

        _stream = False
        pipeline_response: PipelineResponse = (
            self._client._pipeline.run(  # pylint: disable=protected-access
                _request, stream=_stream, **kwargs
            )
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(
                status_code=response.status_code, response=response, error_map=error_map
            )
            raise HttpResponseError(response=response)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})  # type: ignore

        return cast(JSON, deserialized)  # type: ignore
