import os
import pandas as pd
import geojson
from importlib.resources import files
from warnings import warn

def get_geo_estimates(acs_year=None, geo=None, var_codes="all", boundary_year=None):
    
    """
    Retrieve demographic estimates by specified geography, ACS year, and boundary year (if applicable).

    Parameters:
    ----------
        acs_year : int
            Desired 5-Year ACS year (e.g., "2021" for the 2017-2021 5-Year ACS).
        geo : str)
            Geographic level of aggregation desired. Options include "borough", "communitydist", "councildist", "nta",
            "policeprct", "schooldist", or "city".
        var_codes : list or str
            List of chosen variable codes selected from the 'estimate_var_codes' column produced by the `get_ACS_variables()`
            function. Default is "all", which provides estimates for all available variable codes.
        boundary_year : int
            Year for the geographic boundary (relevant for "councildist"). Options: "2013", "2023".

    Returns:
    --------
        pandas.DataFrame: 
            Table with estimates for the specified geography, ACS year, and boundary_year (if applicable). 

    Notes:
    ------
        - All variables are taken from the 5-Year ACS Data Profiles data dictionary, which can be found here:
        https://api.census.gov/data/{INSERT YEAR}/acs/acs5/profile/variables.html. 
        - Codes ending with 'E' and 'M' represent numerical estimates and margins of error, respectively, while codes ending with
        'PE' and 'PM' represent percent estimates and margins of error, respectively. Codes ending with 'V' represent coefficients
        of variation. 
        - Data for geographies available within existing census hierarchy are taken from the ACS. All other data are estimates
        generated by the NYC Council Data Team. Contact datainfo@council.nyc.gov with questions.
    """
    
    if acs_year: acs_year = int(acs_year) # so don't get error if accidentally input wrong dtype

    data_path = files("councilcount").joinpath("data")
    
    # locate available CSV files
    file_names = os.listdir(data_path)
    geo_file_names = [f for f in file_names if "geographies" in f or "nyc-wide" in f]
    geo_names = list(set([f.split('-')[0] for f in geo_file_names]))
    geo_names.remove('nyc')
    geo_names.append('city')

    # record available years
    available_years = sorted(set(int(f.split('_')[-1][:4]) for f in file_names if f.split('_')[-1][:4].isdigit()))

    # boundary year information
    boundary_year_num = str(boundary_year)[-2:] if boundary_year else None

    def read_geos(geo, boundary_year_ext=None):
        """
        Internal function to read and wrangle geo files.
        """
        
        # preparing to access files with boundary year in name
        add_boundary_year = f"_b{boundary_year_ext}" if boundary_year_ext else ""
        
        # building paths
        if geo == "city":
            file_path = f'{data_path}/nyc-wide_estimates_{acs_year}.csv'
            geo_df = pd.read_csv(file_path)
        else:
            file_path = f'{data_path}/{geo}-geographies{add_boundary_year}_{acs_year}.geojson'
            
            with open(file_path) as f:
                gj = geojson.load(f)

            features = gj['features']
            geo_df = pd.json_normalize([feature['properties'] for feature in features])

        # if list of variable codes requested, subset
        if var_codes == "all": 
            return geo_df
        
        # if list of variable codes requested, subset
        else: 
            
            # list of columns for chosen variable(s) if "all" NOT selected
            master_col_list = [geo] 
            
            # creating list of desired variables names (for sub-setting final table)
            for var_code in var_codes:  
                
                # check if the variable code is available in the data
                if var_code not in geo_df.columns:
                    raise ValueError(f"Estimates for the variable code {var_code} are not available. Check for any typos.\n"
                                     "View available variable codes using get_ACS_variables(), or input 'all' to view all columns.")
                else:
                    var_code_base = var_code[:9]
                    var_col_list = [
                        f"{var_code_base}E",  # numeric estimate
                        f"{var_code_base}M",  # numeric MOE
                        f"{var_code_base}PE", # percentage estimate
                        f"{var_code_base}PM", # percentage MOE
                        f"{var_code_base}V"  # coefficient of Variation
                    ]
                    
                    # updating master column list
                    master_col_list.extend(var_col_list)

            # if geo == 'city':
            #     geo_df = geo_df[master_col_list] # adding all desired columns
            # else: 
            #     geo_df = geo_df[master_col_list + ['geometry']] # adding all desired columns + geometry column 
                    
            return geo_df[master_col_list]

    # check input cases
    if acs_year is None:
        raise ValueError("`acs_year` parameter is required. Available options are:\n" +
                         ", ".join(map(str, available_years)))
    elif geo is None:
        raise ValueError("`geo` parameter is required. Available options are:\n" +
                         ", ".join(geo_names))
    elif geo == "councildist" and str(boundary_year) not in ["2013", "2023"]:
        warn("`boundary_year` must be set to 2013 or 2023 when `geo` is 'councildist'. Defaulting to 2023.")
        boundary_year_num = "23"
        return read_geos(geo, boundary_year_num)
    elif acs_year not in available_years:
        raise ValueError(f"The ACS year {acs_year} could not be found. Available options are:\n" +
                         ", ".join(map(str, available_years)))
    elif geo not in geo_names:
        raise ValueError(f"The geography '{geo}' could not be found. Available options are:\n" +
                         ", ".join(geo_names))
    elif geo != "councildist" and boundary_year is not None:
        warn("`boundary_year` is only relevant for `geo = councildist`. Ignoring `boundary_year` input.")
        return read_geos(geo)
    else:
        return read_geos(geo, boundary_year_num)
