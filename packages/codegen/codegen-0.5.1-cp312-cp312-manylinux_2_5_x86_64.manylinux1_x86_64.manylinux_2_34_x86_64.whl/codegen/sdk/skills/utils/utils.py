import difflib
import textwrap

import autoflake
import black
import isort
import jsbeautifier

from codegen.sdk.core.codebase import Codebase
from codegen.sdk.enums import ProgrammingLanguage


def get_jsbeautifier_options() -> jsbeautifier.default_options:
    options = jsbeautifier.default_options()
    options.indent_size = 2
    options.space_in_empty_paren = False
    options.space_after_anon_function = True
    options.brace_style = "collapse,preserve-inline"
    options.break_chained_methods = False
    options.keep_array_indentation = False
    options.keep_function_indentation = False
    options.space_before_conditional = True
    options.unescape_strings = True
    options.wrap_line_length = 80
    options.preserve_newlines = False
    return options


def reformat_code_string(code: str, language: ProgrammingLanguage) -> str:
    """Reformat the code string based on the programming language."""
    if language == ProgrammingLanguage.PYTHON:
        output = autoflake.fix_code(
            code,
            remove_all_unused_imports=True,
        )
        output = isort.code(output, combine_as_imports=True)
        return black.format_str(output, mode=black.FileMode())
    elif language == ProgrammingLanguage.TYPESCRIPT:
        options = get_jsbeautifier_options()
        return jsbeautifier.beautify(code, options)
    else:
        raise ValueError(f"Unsupported programming language: {language}!")


def verify_skill_output(codebase: Codebase, skill, test_case, get_diff, snapshot) -> str | None:
    """Verify the output of a skill against the expected output."""
    if test_case.sanity:
        return None
    elif test_case.graph:
        # I want to save test_case graph locally and compare it with the graph generated by the skill
        # Read the generated graph JSON
        graph_json = open(f"{codebase.op.base_dir}/codegen-graphviz/graph.json").read()

        # Compare with snapshot
        snapshot.assert_match(graph_json, f"{skill.name}_{test_case.name or 'unnamed'}.json")
        return None

    diff_output = []
    for file in test_case.files:
        if file.unchanged:
            expected_output = file.input
        else:
            expected_output = file.output
        if not expected_output:
            if codebase.has_file(file.filepath):
                if get_diff:
                    diff_output.append(f"<h2>Error: File {file.filepath} exists but was expected to be deleted</h2>")
                    diff_output.append(f"<pre>{codebase.get_file(file.filepath).content}</pre>")
                else:
                    error_message = create_unexpected_file_error_message(skill.name, test_case, file.filepath, codebase.get_file(file.filepath).content)
                    raise AssertionError(error_message)
            continue

        if not codebase.has_file(file.filepath):
            if get_diff:
                diff_output.append(f"<h2>Error: File {file.filepath} does not exist but was expected</h2>")
            else:
                error_message = create_missing_file_error_message(skill.name, test_case, file.filepath)
                raise AssertionError(error_message)
            continue

        generated_output = reformat_code_string(codebase.get_file(file.filepath).content, skill.language)
        expected_output = reformat_code_string(expected_output, skill.language)
        if generated_output != expected_output:
            if get_diff:
                diff = difflib.HtmlDiff().make_file(expected_output.splitlines(), generated_output.splitlines(), fromdesc="Expected", todesc="Generated", context=True, numlines=3)
                diff_output.append(f"<h2>Diff for {file.filepath}</h2>")
                diff_output.append(diff)
            else:
                error_message = create_file_mismatch_error_message(skill.name, test_case, file.filepath, expected_output, generated_output)
                raise AssertionError(error_message)

    if diff_output:
        full_diff = "<html><body>" + "".join(diff_output) + "</body></html>"
        return full_diff

    return None


def create_unexpected_file_error_message(skill_name: str, test_case, filepath: str, file_content: str) -> str:
    error_message = textwrap.dedent(f"""
                                        Failure in skill {skill_name} for test case {test_case}, file {filepath}.
                                        Expected file to not exist, but it does.
                                        File content:
                                        ```
                                        {file_content}
                                        ```
                                    """)

    return error_message


def create_missing_file_error_message(skill_name: str, test_case, filepath: str) -> str:
    error_message = textwrap.dedent(f"""
                                        Failure in skill {skill_name} for test case {test_case}, file {filepath}.
                                        Expected file to exist, but it does not.
                                    """)

    return error_message


def create_file_mismatch_error_message(skill_name: str, test_case, filepath: str, expected_content: str, generated_content: str) -> str:
    error_message = textwrap.dedent(f"""
                                        Failure in skill {skill_name} for test case {test_case}, file {filepath}.
                                        Expected output:

                                        ```
{expected_content}
                                        ```

                                        But got:

                                        ```
{generated_content}
                                        ```
                                    """)

    return error_message
