# Generated by cloudcoil-model-codegen v0.3.0
# DO NOT EDIT

from __future__ import annotations

from typing import (
    Annotated,
    Callable,
    List,
    Literal,
    Optional,
    Type,
    overload,
)

from pydantic import Field

from cloudcoil import apimachinery
from cloudcoil.pydantic import (
    BaseModel,
    BaseModelBuilder,
    BuilderContextBase,
    GenericListBuilder,
    ListBuilderContext,
    Never,
    Self,
)
from cloudcoil.resources import Resource, ResourceList

from ..core import v1


class NamedResourcesAllocationResult(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesAllocationResult"]:
            return NamedResourcesAllocationResult

        def build(self) -> "NamedResourcesAllocationResult":
            return NamedResourcesAllocationResult(**self._attrs)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of the selected resource instance.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["NamedResourcesAllocationResult.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesAllocationResult.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesAllocationResult."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesAllocationResult", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesAllocationResult.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: str
    """
    Name is the name of the selected resource instance.
    """


class NamedResourcesFilter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesFilter"]:
            return NamedResourcesFilter

        def build(self) -> "NamedResourcesFilter":
            return NamedResourcesFilter(**self._attrs)

        def selector(self, value: str, /) -> Self:
            """
            Selector is a CEL expression which must evaluate to true if a resource instance is suitable. The language is as defined in https://kubernetes.io/docs/reference/using-api/cel/

            In addition, for each type NamedResourcesin AttributeValue there is a map that resolves to the corresponding value of the instance under evaluation. For example:

               attributes.quantity["a"].isGreaterThan(quantity("0")) &&
               attributes.stringslice["b"].isSorted()
            """
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["NamedResourcesFilter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesFilter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesFilter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesFilter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesFilter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    selector: str
    """
    Selector is a CEL expression which must evaluate to true if a resource instance is suitable. The language is as defined in https://kubernetes.io/docs/reference/using-api/cel/

    In addition, for each type NamedResourcesin AttributeValue there is a map that resolves to the corresponding value of the instance under evaluation. For example:

       attributes.quantity["a"].isGreaterThan(quantity("0")) &&
       attributes.stringslice["b"].isSorted()
    """


class NamedResourcesIntSlice(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesIntSlice"]:
            return NamedResourcesIntSlice

        def build(self) -> "NamedResourcesIntSlice":
            return NamedResourcesIntSlice(**self._attrs)

        def ints(self, value: List[int], /) -> Self:
            """
            Ints is the slice of 64-bit integers.
            """
            return self._set("ints", value)

    class BuilderContext(BuilderContextBase["NamedResourcesIntSlice.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesIntSlice.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesIntSlice."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesIntSlice", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesIntSlice.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    ints: List[int]
    """
    Ints is the slice of 64-bit integers.
    """


class NamedResourcesRequest(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesRequest"]:
            return NamedResourcesRequest

        def build(self) -> "NamedResourcesRequest":
            return NamedResourcesRequest(**self._attrs)

        def selector(self, value: str, /) -> Self:
            """
            Selector is a CEL expression which must evaluate to true if a resource instance is suitable. The language is as defined in https://kubernetes.io/docs/reference/using-api/cel/

            In addition, for each type NamedResourcesin AttributeValue there is a map that resolves to the corresponding value of the instance under evaluation. For example:

               attributes.quantity["a"].isGreaterThan(quantity("0")) &&
               attributes.stringslice["b"].isSorted()
            """
            return self._set("selector", value)

    class BuilderContext(BuilderContextBase["NamedResourcesRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    selector: str
    """
    Selector is a CEL expression which must evaluate to true if a resource instance is suitable. The language is as defined in https://kubernetes.io/docs/reference/using-api/cel/

    In addition, for each type NamedResourcesin AttributeValue there is a map that resolves to the corresponding value of the instance under evaluation. For example:

       attributes.quantity["a"].isGreaterThan(quantity("0")) &&
       attributes.stringslice["b"].isSorted()
    """


class NamedResourcesStringSlice(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesStringSlice"]:
            return NamedResourcesStringSlice

        def build(self) -> "NamedResourcesStringSlice":
            return NamedResourcesStringSlice(**self._attrs)

        def strings(self, value: List[str], /) -> Self:
            """
            Strings is the slice of strings.
            """
            return self._set("strings", value)

    class BuilderContext(BuilderContextBase["NamedResourcesStringSlice.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesStringSlice.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesStringSlice."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesStringSlice", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesStringSlice.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    strings: List[str]
    """
    Strings is the slice of strings.
    """


class PodSchedulingContextSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodSchedulingContextSpec"]:
            return PodSchedulingContextSpec

        def build(self) -> "PodSchedulingContextSpec":
            return PodSchedulingContextSpec(**self._attrs)

        def potential_nodes(self, value: Optional[List[str]], /) -> Self:
            """
            PotentialNodes lists nodes where the Pod might be able to run.

            The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
            """
            return self._set("potential_nodes", value)

        def selected_node(self, value: Optional[str], /) -> Self:
            """
            SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
            """
            return self._set("selected_node", value)

    class BuilderContext(BuilderContextBase["PodSchedulingContextSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodSchedulingContextSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodSchedulingContextSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodSchedulingContextSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodSchedulingContextSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    potential_nodes: Annotated[Optional[List[str]], Field(alias="potentialNodes")] = None
    """
    PotentialNodes lists nodes where the Pod might be able to run.

    The size of this field is limited to 128. This is large enough for many clusters. Larger clusters may need more attempts to find a node that suits all pending resources. This may get increased in the future, but not reduced.
    """
    selected_node: Annotated[Optional[str], Field(alias="selectedNode")] = None
    """
    SelectedNode is the node for which allocation of ResourceClaims that are referenced by the Pod and that use "WaitForFirstConsumer" allocation is to be attempted.
    """


class ResourceClaimConsumerReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimConsumerReference"]:
            return ResourceClaimConsumerReference

        def build(self) -> "ResourceClaimConsumerReference":
            return ResourceClaimConsumerReference(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
            """
            return self._set("api_group", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced.
            """
            return self._set("name", value)

        def resource(self, value: str, /) -> Self:
            """
            Resource is the type of resource being referenced, for example "pods".
            """
            return self._set("resource", value)

        def uid(self, value: str, /) -> Self:
            """
            UID identifies exactly one incarnation of the resource.
            """
            return self._set("uid", value)

    class BuilderContext(BuilderContextBase["ResourceClaimConsumerReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimConsumerReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimConsumerReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimConsumerReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimConsumerReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
    """
    name: str
    """
    Name is the name of resource being referenced.
    """
    resource: str
    """
    Resource is the type of resource being referenced, for example "pods".
    """
    uid: str
    """
    UID identifies exactly one incarnation of the resource.
    """


class ResourceClaimParametersReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimParametersReference"]:
            return ResourceClaimParametersReference

        def build(self) -> "ResourceClaimParametersReference":
            return ResourceClaimParametersReference(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced. This is the same value as in the parameter object's metadata, for example "ConfigMap".
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["ResourceClaimParametersReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimParametersReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimParametersReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimParametersReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimParametersReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
    """
    kind: str
    """
    Kind is the type of resource being referenced. This is the same value as in the parameter object's metadata, for example "ConfigMap".
    """
    name: str
    """
    Name is the name of resource being referenced.
    """


class ResourceClaimSchedulingStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimSchedulingStatus"]:
            return ResourceClaimSchedulingStatus

        def build(self) -> "ResourceClaimSchedulingStatus":
            return ResourceClaimSchedulingStatus(**self._attrs)

        def name(self, value: Optional[str], /) -> Self:
            """
            Name matches the pod.spec.resourceClaims[*].Name field.
            """
            return self._set("name", value)

        def unsuitable_nodes(self, value: Optional[List[str]], /) -> Self:
            """
            UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.

            The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
            """
            return self._set("unsuitable_nodes", value)

    class BuilderContext(BuilderContextBase["ResourceClaimSchedulingStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimSchedulingStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimSchedulingStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimSchedulingStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimSchedulingStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    name: Optional[str] = None
    """
    Name matches the pod.spec.resourceClaims[*].Name field.
    """
    unsuitable_nodes: Annotated[Optional[List[str]], Field(alias="unsuitableNodes")] = None
    """
    UnsuitableNodes lists nodes that the ResourceClaim cannot be allocated for.

    The size of this field is limited to 128, the same as for PodSchedulingSpec.PotentialNodes. This may get increased in the future, but not reduced.
    """


class ResourceClaimSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimSpec"]:
            return ResourceClaimSpec

        def build(self) -> "ResourceClaimSpec":
            return ResourceClaimSpec(**self._attrs)

        def allocation_mode(self, value: Optional[str], /) -> Self:
            """
            Allocation can start immediately or when a Pod wants to use the resource. "WaitForFirstConsumer" is the default.
            """
            return self._set("allocation_mode", value)

        @overload
        def parameters_ref(
            self, value_or_callback: Optional[ResourceClaimParametersReference], /
        ) -> "ResourceClaimSpec.Builder": ...

        @overload
        def parameters_ref(
            self,
            value_or_callback: Callable[
                [ResourceClaimParametersReference.Builder],
                ResourceClaimParametersReference.Builder | ResourceClaimParametersReference,
            ],
            /,
        ) -> "ResourceClaimSpec.Builder": ...

        @overload
        def parameters_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceClaimParametersReference.BuilderContext": ...

        def parameters_ref(self, value_or_callback=None, /):
            """
            ParametersRef references a separate object with arbitrary parameters that will be used by the driver when allocating a resource for the claim.

            The object must be in the same namespace as the ResourceClaim.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClaimParametersReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "parameters_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimParametersReference.builder())
                if isinstance(output, ResourceClaimParametersReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("parameters_ref", value)

        def resource_class_name(self, value: str, /) -> Self:
            """
            ResourceClassName references the driver and additional parameters via the name of a ResourceClass that was created as part of the driver deployment.
            """
            return self._set("resource_class_name", value)

    class BuilderContext(BuilderContextBase["ResourceClaimSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allocation_mode: Annotated[Optional[str], Field(alias="allocationMode")] = None
    """
    Allocation can start immediately or when a Pod wants to use the resource. "WaitForFirstConsumer" is the default.
    """
    parameters_ref: Annotated[
        Optional[ResourceClaimParametersReference], Field(alias="parametersRef")
    ] = None
    """
    ParametersRef references a separate object with arbitrary parameters that will be used by the driver when allocating a resource for the claim.

    The object must be in the same namespace as the ResourceClaim.
    """
    resource_class_name: Annotated[str, Field(alias="resourceClassName")]
    """
    ResourceClassName references the driver and additional parameters via the name of a ResourceClass that was created as part of the driver deployment.
    """


class ResourceClassParametersReference(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClassParametersReference"]:
            return ResourceClassParametersReference

        def build(self) -> "ResourceClassParametersReference":
            return ResourceClassParametersReference(**self._attrs)

        def api_group(self, value: Optional[str], /) -> Self:
            """
            APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
            """
            return self._set("api_group", value)

        def kind(self, value: str, /) -> Self:
            """
            Kind is the type of resource being referenced. This is the same value as in the parameter object's metadata.
            """
            return self._set("kind", value)

        def name(self, value: str, /) -> Self:
            """
            Name is the name of resource being referenced.
            """
            return self._set("name", value)

        def namespace(self, value: Optional[str], /) -> Self:
            """
            Namespace that contains the referenced resource. Must be empty for cluster-scoped resources and non-empty for namespaced resources.
            """
            return self._set("namespace", value)

    class BuilderContext(BuilderContextBase["ResourceClassParametersReference.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClassParametersReference.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClassParametersReference."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClassParametersReference", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClassParametersReference.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_group: Annotated[Optional[str], Field(alias="apiGroup")] = None
    """
    APIGroup is the group for the resource being referenced. It is empty for the core API. This matches the group in the APIVersion that is used when creating the resources.
    """
    kind: str
    """
    Kind is the type of resource being referenced. This is the same value as in the parameter object's metadata.
    """
    name: str
    """
    Name is the name of resource being referenced.
    """
    namespace: Optional[str] = None
    """
    Namespace that contains the referenced resource. Must be empty for cluster-scoped resources and non-empty for namespaced resources.
    """


class ResourceFilter(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceFilter"]:
            return ResourceFilter

        def build(self) -> "ResourceFilter":
            return ResourceFilter(**self._attrs)

        def driver_name(self, value: Optional[str], /) -> Self:
            """
            DriverName is the name used by the DRA driver kubelet plugin.
            """
            return self._set("driver_name", value)

        @overload
        def named_resources(
            self, value_or_callback: Optional[NamedResourcesFilter], /
        ) -> "ResourceFilter.Builder": ...

        @overload
        def named_resources(
            self,
            value_or_callback: Callable[
                [NamedResourcesFilter.Builder],
                NamedResourcesFilter.Builder | NamedResourcesFilter,
            ],
            /,
        ) -> "ResourceFilter.Builder": ...

        @overload
        def named_resources(
            self, value_or_callback: Never = ...
        ) -> "NamedResourcesFilter.BuilderContext": ...

        def named_resources(self, value_or_callback=None, /):
            """
            NamedResources describes a resource filter using the named resources model.
            """
            if self._in_context and value_or_callback is None:
                context = NamedResourcesFilter.BuilderContext()
                context._parent_builder = self
                context._field_name = "named_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesFilter.builder())
                if isinstance(output, NamedResourcesFilter.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("named_resources", value)

    class BuilderContext(BuilderContextBase["ResourceFilter.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceFilter.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceFilter."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceFilter", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceFilter.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver_name: Annotated[Optional[str], Field(alias="driverName")] = None
    """
    DriverName is the name used by the DRA driver kubelet plugin.
    """
    named_resources: Annotated[Optional[NamedResourcesFilter], Field(alias="namedResources")] = None
    """
    NamedResources describes a resource filter using the named resources model.
    """


class DriverAllocationResult(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DriverAllocationResult"]:
            return DriverAllocationResult

        def build(self) -> "DriverAllocationResult":
            return DriverAllocationResult(**self._attrs)

        @overload
        def named_resources(
            self, value_or_callback: Optional[NamedResourcesAllocationResult], /
        ) -> "DriverAllocationResult.Builder": ...

        @overload
        def named_resources(
            self,
            value_or_callback: Callable[
                [NamedResourcesAllocationResult.Builder],
                NamedResourcesAllocationResult.Builder | NamedResourcesAllocationResult,
            ],
            /,
        ) -> "DriverAllocationResult.Builder": ...

        @overload
        def named_resources(
            self, value_or_callback: Never = ...
        ) -> "NamedResourcesAllocationResult.BuilderContext": ...

        def named_resources(self, value_or_callback=None, /):
            """
            NamedResources describes the allocation result when using the named resources model.
            """
            if self._in_context and value_or_callback is None:
                context = NamedResourcesAllocationResult.BuilderContext()
                context._parent_builder = self
                context._field_name = "named_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesAllocationResult.builder())
                if isinstance(output, NamedResourcesAllocationResult.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("named_resources", value)

        @overload
        def vendor_request_parameters(
            self, value_or_callback: Optional[apimachinery.RawExtension], /
        ) -> "DriverAllocationResult.Builder": ...

        @overload
        def vendor_request_parameters(
            self,
            value_or_callback: Callable[
                [apimachinery.RawExtension.Builder],
                apimachinery.RawExtension.Builder | apimachinery.RawExtension,
            ],
            /,
        ) -> "DriverAllocationResult.Builder": ...

        @overload
        def vendor_request_parameters(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.RawExtension.BuilderContext": ...

        def vendor_request_parameters(self, value_or_callback=None, /):
            """
            VendorRequestParameters are the per-request configuration parameters from the time that the claim was allocated.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.RawExtension.BuilderContext()
                context._parent_builder = self
                context._field_name = "vendor_request_parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.RawExtension.builder())
                if isinstance(output, apimachinery.RawExtension.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vendor_request_parameters", value)

    class BuilderContext(BuilderContextBase["DriverAllocationResult.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DriverAllocationResult.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DriverAllocationResult."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DriverAllocationResult", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DriverAllocationResult.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    named_resources: Annotated[
        Optional[NamedResourcesAllocationResult], Field(alias="namedResources")
    ] = None
    """
    NamedResources describes the allocation result when using the named resources model.
    """
    vendor_request_parameters: Annotated[
        Optional[apimachinery.RawExtension], Field(alias="vendorRequestParameters")
    ] = None
    """
    VendorRequestParameters are the per-request configuration parameters from the time that the claim was allocated.
    """


class NamedResourcesAttribute(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesAttribute"]:
            return NamedResourcesAttribute

        def build(self) -> "NamedResourcesAttribute":
            return NamedResourcesAttribute(**self._attrs)

        def bool(self, value: Optional[bool], /) -> Self:
            """
            BoolValue is a true/false value.
            """
            return self._set("bool", value)

        def int(self, value: Optional[int], /) -> Self:
            """
            IntValue is a 64-bit integer.
            """
            return self._set("int", value)

        @overload
        def int_slice(
            self, value_or_callback: Optional[NamedResourcesIntSlice], /
        ) -> "NamedResourcesAttribute.Builder": ...

        @overload
        def int_slice(
            self,
            value_or_callback: Callable[
                [NamedResourcesIntSlice.Builder],
                NamedResourcesIntSlice.Builder | NamedResourcesIntSlice,
            ],
            /,
        ) -> "NamedResourcesAttribute.Builder": ...

        @overload
        def int_slice(
            self, value_or_callback: Never = ...
        ) -> "NamedResourcesIntSlice.BuilderContext": ...

        def int_slice(self, value_or_callback=None, /):
            """
            IntSliceValue is an array of 64-bit integers.
            """
            if self._in_context and value_or_callback is None:
                context = NamedResourcesIntSlice.BuilderContext()
                context._parent_builder = self
                context._field_name = "int_slice"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesIntSlice.builder())
                if isinstance(output, NamedResourcesIntSlice.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("int_slice", value)

        def name(self, value: str, /) -> Self:
            """
            Name is unique identifier among all resource instances managed by the driver on the node. It must be a DNS subdomain.
            """
            return self._set("name", value)

        @overload
        def quantity(
            self, value_or_callback: Optional[apimachinery.Quantity], /
        ) -> "NamedResourcesAttribute.Builder": ...

        @overload
        def quantity(
            self,
            value_or_callback: Callable[
                [apimachinery.Quantity.Builder],
                apimachinery.Quantity.Builder | apimachinery.Quantity,
            ],
            /,
        ) -> "NamedResourcesAttribute.Builder": ...

        @overload
        def quantity(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.Quantity.BuilderContext": ...

        def quantity(self, value_or_callback=None, /):
            """
            QuantityValue is a quantity.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.Quantity.BuilderContext()
                context._parent_builder = self
                context._field_name = "quantity"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.Quantity.builder())
                if isinstance(output, apimachinery.Quantity.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("quantity", value)

        def string(self, value: Optional[str], /) -> Self:
            """
            StringValue is a string.
            """
            return self._set("string", value)

        @overload
        def string_slice(
            self, value_or_callback: Optional[NamedResourcesStringSlice], /
        ) -> "NamedResourcesAttribute.Builder": ...

        @overload
        def string_slice(
            self,
            value_or_callback: Callable[
                [NamedResourcesStringSlice.Builder],
                NamedResourcesStringSlice.Builder | NamedResourcesStringSlice,
            ],
            /,
        ) -> "NamedResourcesAttribute.Builder": ...

        @overload
        def string_slice(
            self, value_or_callback: Never = ...
        ) -> "NamedResourcesStringSlice.BuilderContext": ...

        def string_slice(self, value_or_callback=None, /):
            """
            StringSliceValue is an array of strings.
            """
            if self._in_context and value_or_callback is None:
                context = NamedResourcesStringSlice.BuilderContext()
                context._parent_builder = self
                context._field_name = "string_slice"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesStringSlice.builder())
                if isinstance(output, NamedResourcesStringSlice.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("string_slice", value)

        def version(self, value: Optional[str], /) -> Self:
            """
            VersionValue is a semantic version according to semver.org spec 2.0.0.
            """
            return self._set("version", value)

    class BuilderContext(BuilderContextBase["NamedResourcesAttribute.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesAttribute.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesAttribute."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesAttribute", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesAttribute.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    bool: Optional[bool] = None
    """
    BoolValue is a true/false value.
    """
    int: Optional[int] = None
    """
    IntValue is a 64-bit integer.
    """
    int_slice: Annotated[Optional[NamedResourcesIntSlice], Field(alias="intSlice")] = None
    """
    IntSliceValue is an array of 64-bit integers.
    """
    name: str
    """
    Name is unique identifier among all resource instances managed by the driver on the node. It must be a DNS subdomain.
    """
    quantity: Optional[apimachinery.Quantity] = None
    """
    QuantityValue is a quantity.
    """
    string: Optional[str] = None
    """
    StringValue is a string.
    """
    string_slice: Annotated[Optional[NamedResourcesStringSlice], Field(alias="stringSlice")] = None
    """
    StringSliceValue is an array of strings.
    """
    version: Optional[str] = None
    """
    VersionValue is a semantic version according to semver.org spec 2.0.0.
    """


class NamedResourcesInstance(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesInstance"]:
            return NamedResourcesInstance

        def build(self) -> "NamedResourcesInstance":
            return NamedResourcesInstance(**self._attrs)

        @overload
        def attributes(
            self, value_or_callback: List[NamedResourcesAttribute], /
        ) -> "NamedResourcesInstance.Builder": ...

        @overload
        def attributes(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NamedResourcesAttribute, NamedResourcesAttribute.Builder]],
                GenericListBuilder[NamedResourcesAttribute, NamedResourcesAttribute.Builder]
                | List[NamedResourcesAttribute],
            ],
            /,
        ) -> "NamedResourcesInstance.Builder": ...

        @overload
        def attributes(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NamedResourcesAttribute.Builder]: ...

        def attributes(self, value_or_callback=None, /):
            """
            Attributes defines the attributes of this resource instance. The name of each attribute must be unique.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NamedResourcesAttribute.Builder]()
                context._parent_builder = self
                context._field_name = "attributes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesAttribute.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("attributes", value)

        def name(self, value: str, /) -> Self:
            """
            Name is unique identifier among all resource instances managed by the driver on the node. It must be a DNS subdomain.
            """
            return self._set("name", value)

    class BuilderContext(BuilderContextBase["NamedResourcesInstance.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesInstance.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesInstance."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesInstance", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesInstance.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    attributes: Optional[List[NamedResourcesAttribute]] = None
    """
    Attributes defines the attributes of this resource instance. The name of each attribute must be unique.
    """
    name: str
    """
    Name is unique identifier among all resource instances managed by the driver on the node. It must be a DNS subdomain.
    """


class NamedResourcesResources(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["NamedResourcesResources"]:
            return NamedResourcesResources

        def build(self) -> "NamedResourcesResources":
            return NamedResourcesResources(**self._attrs)

        @overload
        def instances(
            self, value_or_callback: List[NamedResourcesInstance], /
        ) -> "NamedResourcesResources.Builder": ...

        @overload
        def instances(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[NamedResourcesInstance, NamedResourcesInstance.Builder]],
                GenericListBuilder[NamedResourcesInstance, NamedResourcesInstance.Builder]
                | List[NamedResourcesInstance],
            ],
            /,
        ) -> "NamedResourcesResources.Builder": ...

        @overload
        def instances(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[NamedResourcesInstance.Builder]: ...

        def instances(self, value_or_callback=None, /):
            """
            The list of all individual resources instances currently available.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[NamedResourcesInstance.Builder]()
                context._parent_builder = self
                context._field_name = "instances"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesInstance.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("instances", value)

    class BuilderContext(BuilderContextBase["NamedResourcesResources.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = NamedResourcesResources.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for NamedResourcesResources."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["NamedResourcesResources", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use NamedResourcesResources.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    instances: List[NamedResourcesInstance]
    """
    The list of all individual resources instances currently available.
    """


class PodSchedulingContextStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodSchedulingContextStatus"]:
            return PodSchedulingContextStatus

        def build(self) -> "PodSchedulingContextStatus":
            return PodSchedulingContextStatus(**self._attrs)

        @overload
        def resource_claims(
            self, value_or_callback: List[ResourceClaimSchedulingStatus], /
        ) -> "PodSchedulingContextStatus.Builder": ...

        @overload
        def resource_claims(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ResourceClaimSchedulingStatus,
                        ResourceClaimSchedulingStatus.Builder,
                    ]
                ],
                GenericListBuilder[
                    ResourceClaimSchedulingStatus, ResourceClaimSchedulingStatus.Builder
                ]
                | List[ResourceClaimSchedulingStatus],
            ],
            /,
        ) -> "PodSchedulingContextStatus.Builder": ...

        @overload
        def resource_claims(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceClaimSchedulingStatus.Builder]: ...

        def resource_claims(self, value_or_callback=None, /):
            """
            ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceClaimSchedulingStatus.Builder]()
                context._parent_builder = self
                context._field_name = "resource_claims"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimSchedulingStatus.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_claims", value)

    class BuilderContext(BuilderContextBase["PodSchedulingContextStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodSchedulingContextStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodSchedulingContextStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodSchedulingContextStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodSchedulingContextStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    resource_claims: Annotated[
        Optional[List[ResourceClaimSchedulingStatus]], Field(alias="resourceClaims")
    ] = None
    """
    ResourceClaims describes resource availability for each pod.spec.resourceClaim entry where the corresponding ResourceClaim uses "WaitForFirstConsumer" allocation mode.
    """


class ResourceRequest(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceRequest"]:
            return ResourceRequest

        def build(self) -> "ResourceRequest":
            return ResourceRequest(**self._attrs)

        @overload
        def named_resources(
            self, value_or_callback: Optional[NamedResourcesRequest], /
        ) -> "ResourceRequest.Builder": ...

        @overload
        def named_resources(
            self,
            value_or_callback: Callable[
                [NamedResourcesRequest.Builder],
                NamedResourcesRequest.Builder | NamedResourcesRequest,
            ],
            /,
        ) -> "ResourceRequest.Builder": ...

        @overload
        def named_resources(
            self, value_or_callback: Never = ...
        ) -> "NamedResourcesRequest.BuilderContext": ...

        def named_resources(self, value_or_callback=None, /):
            """
            NamedResources describes a request for resources with the named resources model.
            """
            if self._in_context and value_or_callback is None:
                context = NamedResourcesRequest.BuilderContext()
                context._parent_builder = self
                context._field_name = "named_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesRequest.builder())
                if isinstance(output, NamedResourcesRequest.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("named_resources", value)

        @overload
        def vendor_parameters(
            self, value_or_callback: Optional[apimachinery.RawExtension], /
        ) -> "ResourceRequest.Builder": ...

        @overload
        def vendor_parameters(
            self,
            value_or_callback: Callable[
                [apimachinery.RawExtension.Builder],
                apimachinery.RawExtension.Builder | apimachinery.RawExtension,
            ],
            /,
        ) -> "ResourceRequest.Builder": ...

        @overload
        def vendor_parameters(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.RawExtension.BuilderContext": ...

        def vendor_parameters(self, value_or_callback=None, /):
            """
            VendorParameters are arbitrary setup parameters for the requested resource. They are ignored while allocating a claim.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.RawExtension.BuilderContext()
                context._parent_builder = self
                context._field_name = "vendor_parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.RawExtension.builder())
                if isinstance(output, apimachinery.RawExtension.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vendor_parameters", value)

    class BuilderContext(BuilderContextBase["ResourceRequest.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceRequest.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceRequest."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceRequest", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceRequest.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    named_resources: Annotated[Optional[NamedResourcesRequest], Field(alias="namedResources")] = (
        None
    )
    """
    NamedResources describes a request for resources with the named resources model.
    """
    vendor_parameters: Annotated[
        Optional[apimachinery.RawExtension], Field(alias="vendorParameters")
    ] = None
    """
    VendorParameters are arbitrary setup parameters for the requested resource. They are ignored while allocating a claim.
    """


class StructuredResourceHandle(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["StructuredResourceHandle"]:
            return StructuredResourceHandle

        def build(self) -> "StructuredResourceHandle":
            return StructuredResourceHandle(**self._attrs)

        def node_name(self, value: Optional[str], /) -> Self:
            """
            NodeName is the name of the node providing the necessary resources if the resources are local to a node.
            """
            return self._set("node_name", value)

        @overload
        def results(
            self, value_or_callback: List[DriverAllocationResult], /
        ) -> "StructuredResourceHandle.Builder": ...

        @overload
        def results(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DriverAllocationResult, DriverAllocationResult.Builder]],
                GenericListBuilder[DriverAllocationResult, DriverAllocationResult.Builder]
                | List[DriverAllocationResult],
            ],
            /,
        ) -> "StructuredResourceHandle.Builder": ...

        @overload
        def results(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DriverAllocationResult.Builder]: ...

        def results(self, value_or_callback=None, /):
            """
            Results lists all allocated driver resources.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DriverAllocationResult.Builder]()
                context._parent_builder = self
                context._field_name = "results"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DriverAllocationResult.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("results", value)

        @overload
        def vendor_claim_parameters(
            self, value_or_callback: Optional[apimachinery.RawExtension], /
        ) -> "StructuredResourceHandle.Builder": ...

        @overload
        def vendor_claim_parameters(
            self,
            value_or_callback: Callable[
                [apimachinery.RawExtension.Builder],
                apimachinery.RawExtension.Builder | apimachinery.RawExtension,
            ],
            /,
        ) -> "StructuredResourceHandle.Builder": ...

        @overload
        def vendor_claim_parameters(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.RawExtension.BuilderContext": ...

        def vendor_claim_parameters(self, value_or_callback=None, /):
            """
            VendorClaimParameters are the per-claim configuration parameters from the resource claim parameters at the time that the claim was allocated.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.RawExtension.BuilderContext()
                context._parent_builder = self
                context._field_name = "vendor_claim_parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.RawExtension.builder())
                if isinstance(output, apimachinery.RawExtension.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vendor_claim_parameters", value)

        @overload
        def vendor_class_parameters(
            self, value_or_callback: Optional[apimachinery.RawExtension], /
        ) -> "StructuredResourceHandle.Builder": ...

        @overload
        def vendor_class_parameters(
            self,
            value_or_callback: Callable[
                [apimachinery.RawExtension.Builder],
                apimachinery.RawExtension.Builder | apimachinery.RawExtension,
            ],
            /,
        ) -> "StructuredResourceHandle.Builder": ...

        @overload
        def vendor_class_parameters(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.RawExtension.BuilderContext": ...

        def vendor_class_parameters(self, value_or_callback=None, /):
            """
            VendorClassParameters are the per-claim configuration parameters from the resource class at the time that the claim was allocated.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.RawExtension.BuilderContext()
                context._parent_builder = self
                context._field_name = "vendor_class_parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.RawExtension.builder())
                if isinstance(output, apimachinery.RawExtension.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vendor_class_parameters", value)

    class BuilderContext(BuilderContextBase["StructuredResourceHandle.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = StructuredResourceHandle.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for StructuredResourceHandle."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["StructuredResourceHandle", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use StructuredResourceHandle.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    node_name: Annotated[Optional[str], Field(alias="nodeName")] = None
    """
    NodeName is the name of the node providing the necessary resources if the resources are local to a node.
    """
    results: List[DriverAllocationResult]
    """
    Results lists all allocated driver resources.
    """
    vendor_claim_parameters: Annotated[
        Optional[apimachinery.RawExtension], Field(alias="vendorClaimParameters")
    ] = None
    """
    VendorClaimParameters are the per-claim configuration parameters from the resource claim parameters at the time that the claim was allocated.
    """
    vendor_class_parameters: Annotated[
        Optional[apimachinery.RawExtension], Field(alias="vendorClassParameters")
    ] = None
    """
    VendorClassParameters are the per-claim configuration parameters from the resource class at the time that the claim was allocated.
    """


class VendorParameters(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["VendorParameters"]:
            return VendorParameters

        def build(self) -> "VendorParameters":
            return VendorParameters(**self._attrs)

        def driver_name(self, value: Optional[str], /) -> Self:
            """
            DriverName is the name used by the DRA driver kubelet plugin.
            """
            return self._set("driver_name", value)

        @overload
        def parameters(
            self, value_or_callback: Optional[apimachinery.RawExtension], /
        ) -> "VendorParameters.Builder": ...

        @overload
        def parameters(
            self,
            value_or_callback: Callable[
                [apimachinery.RawExtension.Builder],
                apimachinery.RawExtension.Builder | apimachinery.RawExtension,
            ],
            /,
        ) -> "VendorParameters.Builder": ...

        @overload
        def parameters(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.RawExtension.BuilderContext": ...

        def parameters(self, value_or_callback=None, /):
            """
            Parameters can be arbitrary setup parameters. They are ignored while allocating a claim.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.RawExtension.BuilderContext()
                context._parent_builder = self
                context._field_name = "parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.RawExtension.builder())
                if isinstance(output, apimachinery.RawExtension.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("parameters", value)

    class BuilderContext(BuilderContextBase["VendorParameters.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = VendorParameters.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for VendorParameters."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["VendorParameters", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use VendorParameters.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver_name: Annotated[Optional[str], Field(alias="driverName")] = None
    """
    DriverName is the name used by the DRA driver kubelet plugin.
    """
    parameters: Optional[apimachinery.RawExtension] = None
    """
    Parameters can be arbitrary setup parameters. They are ignored while allocating a claim.
    """


class DriverRequests(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["DriverRequests"]:
            return DriverRequests

        def build(self) -> "DriverRequests":
            return DriverRequests(**self._attrs)

        def driver_name(self, value: Optional[str], /) -> Self:
            """
            DriverName is the name used by the DRA driver kubelet plugin.
            """
            return self._set("driver_name", value)

        @overload
        def requests(
            self, value_or_callback: List[ResourceRequest], /
        ) -> "DriverRequests.Builder": ...

        @overload
        def requests(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceRequest, ResourceRequest.Builder]],
                GenericListBuilder[ResourceRequest, ResourceRequest.Builder]
                | List[ResourceRequest],
            ],
            /,
        ) -> "DriverRequests.Builder": ...

        @overload
        def requests(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceRequest.Builder]: ...

        def requests(self, value_or_callback=None, /):
            """
            Requests describes all resources that are needed from the driver.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceRequest.Builder]()
                context._parent_builder = self
                context._field_name = "requests"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceRequest.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("requests", value)

        @overload
        def vendor_parameters(
            self, value_or_callback: Optional[apimachinery.RawExtension], /
        ) -> "DriverRequests.Builder": ...

        @overload
        def vendor_parameters(
            self,
            value_or_callback: Callable[
                [apimachinery.RawExtension.Builder],
                apimachinery.RawExtension.Builder | apimachinery.RawExtension,
            ],
            /,
        ) -> "DriverRequests.Builder": ...

        @overload
        def vendor_parameters(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.RawExtension.BuilderContext": ...

        def vendor_parameters(self, value_or_callback=None, /):
            """
            VendorParameters are arbitrary setup parameters for all requests of the claim. They are ignored while allocating the claim.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.RawExtension.BuilderContext()
                context._parent_builder = self
                context._field_name = "vendor_parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.RawExtension.builder())
                if isinstance(output, apimachinery.RawExtension.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("vendor_parameters", value)

    class BuilderContext(BuilderContextBase["DriverRequests.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = DriverRequests.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for DriverRequests."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["DriverRequests", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use DriverRequests.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    driver_name: Annotated[Optional[str], Field(alias="driverName")] = None
    """
    DriverName is the name used by the DRA driver kubelet plugin.
    """
    requests: Optional[List[ResourceRequest]] = None
    """
    Requests describes all resources that are needed from the driver.
    """
    vendor_parameters: Annotated[
        Optional[apimachinery.RawExtension], Field(alias="vendorParameters")
    ] = None
    """
    VendorParameters are arbitrary setup parameters for all requests of the claim. They are ignored while allocating the claim.
    """


class PodSchedulingContext(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["PodSchedulingContext"]:
            return PodSchedulingContext

        def build(self) -> "PodSchedulingContext":
            return PodSchedulingContext(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["PodSchedulingContext"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "PodSchedulingContext.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "PodSchedulingContext.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: PodSchedulingContextSpec, /
        ) -> "PodSchedulingContext.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [PodSchedulingContextSpec.Builder],
                PodSchedulingContextSpec.Builder | PodSchedulingContextSpec,
            ],
            /,
        ) -> "PodSchedulingContext.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "PodSchedulingContextSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Spec describes where resources for the Pod are needed.
            """
            if self._in_context and value_or_callback is None:
                context = PodSchedulingContextSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodSchedulingContextSpec.builder())
                if isinstance(output, PodSchedulingContextSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[PodSchedulingContextStatus], /
        ) -> "PodSchedulingContext.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [PodSchedulingContextStatus.Builder],
                PodSchedulingContextStatus.Builder | PodSchedulingContextStatus,
            ],
            /,
        ) -> "PodSchedulingContext.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "PodSchedulingContextStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            """
            Status describes where resources for the Pod can be allocated.
            """
            if self._in_context and value_or_callback is None:
                context = PodSchedulingContextStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(PodSchedulingContextStatus.builder())
                if isinstance(output, PodSchedulingContextStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["PodSchedulingContext.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = PodSchedulingContext.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for PodSchedulingContext."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["PodSchedulingContext", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use PodSchedulingContext.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["PodSchedulingContext"]] = "PodSchedulingContext"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    spec: PodSchedulingContextSpec
    """
    Spec describes where resources for the Pod are needed.
    """
    status: Optional[PodSchedulingContextStatus] = None
    """
    Status describes where resources for the Pod can be allocated.
    """


PodSchedulingContextList = ResourceList["PodSchedulingContext"]


class ResourceClaimParameters(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimParameters"]:
            return ResourceClaimParameters

        def build(self) -> "ResourceClaimParameters":
            return ResourceClaimParameters(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        @overload
        def driver_requests(
            self, value_or_callback: List[DriverRequests], /
        ) -> "ResourceClaimParameters.Builder": ...

        @overload
        def driver_requests(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[DriverRequests, DriverRequests.Builder]],
                GenericListBuilder[DriverRequests, DriverRequests.Builder] | List[DriverRequests],
            ],
            /,
        ) -> "ResourceClaimParameters.Builder": ...

        @overload
        def driver_requests(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[DriverRequests.Builder]: ...

        def driver_requests(self, value_or_callback=None, /):
            """
            DriverRequests describes all resources that are needed for the allocated claim. A single claim may use resources coming from different drivers. For each driver, this array has at most one entry which then may have one or more per-driver requests.

            May be empty, in which case the claim can always be allocated.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[DriverRequests.Builder]()
                context._parent_builder = self
                context._field_name = "driver_requests"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(DriverRequests.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("driver_requests", value)

        @overload
        def generated_from(
            self, value_or_callback: Optional[ResourceClaimParametersReference], /
        ) -> "ResourceClaimParameters.Builder": ...

        @overload
        def generated_from(
            self,
            value_or_callback: Callable[
                [ResourceClaimParametersReference.Builder],
                ResourceClaimParametersReference.Builder | ResourceClaimParametersReference,
            ],
            /,
        ) -> "ResourceClaimParameters.Builder": ...

        @overload
        def generated_from(
            self, value_or_callback: Never = ...
        ) -> "ResourceClaimParametersReference.BuilderContext": ...

        def generated_from(self, value_or_callback=None, /):
            """
            If this object was created from some other resource, then this links back to that resource. This field is used to find the in-tree representation of the claim parameters when the parameter reference of the claim refers to some unknown type.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClaimParametersReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "generated_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimParametersReference.builder())
                if isinstance(output, ResourceClaimParametersReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generated_from", value)

        def kind(self, value: Optional[Literal["ResourceClaimParameters"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceClaimParameters.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceClaimParameters.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        def shareable(self, value: Optional[bool], /) -> Self:
            """
            Shareable indicates whether the allocated claim is meant to be shareable by multiple consumers at the same time.
            """
            return self._set("shareable", value)

    class BuilderContext(BuilderContextBase["ResourceClaimParameters.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimParameters.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimParameters."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimParameters", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimParameters.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    driver_requests: Annotated[Optional[List[DriverRequests]], Field(alias="driverRequests")] = None
    """
    DriverRequests describes all resources that are needed for the allocated claim. A single claim may use resources coming from different drivers. For each driver, this array has at most one entry which then may have one or more per-driver requests.

    May be empty, in which case the claim can always be allocated.
    """
    generated_from: Annotated[
        Optional[ResourceClaimParametersReference], Field(alias="generatedFrom")
    ] = None
    """
    If this object was created from some other resource, then this links back to that resource. This field is used to find the in-tree representation of the claim parameters when the parameter reference of the claim refers to some unknown type.
    """
    kind: Optional[Literal["ResourceClaimParameters"]] = "ResourceClaimParameters"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    shareable: Optional[bool] = None
    """
    Shareable indicates whether the allocated claim is meant to be shareable by multiple consumers at the same time.
    """


ResourceClaimParametersList = ResourceList["ResourceClaimParameters"]


class ResourceClaimTemplateSpec(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimTemplateSpec"]:
            return ResourceClaimTemplateSpec

        def build(self) -> "ResourceClaimTemplateSpec":
            return ResourceClaimTemplateSpec(**self._attrs)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceClaimTemplateSpec.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceClaimTemplateSpec.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ResourceClaimSpec, /
        ) -> "ResourceClaimTemplateSpec.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ResourceClaimSpec.Builder],
                ResourceClaimSpec.Builder | ResourceClaimSpec,
            ],
            /,
        ) -> "ResourceClaimTemplateSpec.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ResourceClaimSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClaimSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimSpec.builder())
                if isinstance(output, ResourceClaimSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ResourceClaimTemplateSpec.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimTemplateSpec.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimTemplateSpec."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimTemplateSpec", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimTemplateSpec.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    ObjectMeta may contain labels and annotations that will be copied into the PVC when creating it. No other fields are allowed and will be rejected during validation.
    """
    spec: ResourceClaimSpec
    """
    Spec for the ResourceClaim. The entire content is copied unchanged into the ResourceClaim that gets created from this template. The same fields as in a ResourceClaim are also valid here.
    """


class ResourceClass(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClass"]:
            return ResourceClass

        def build(self) -> "ResourceClass":
            return ResourceClass(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def driver_name(self, value: str, /) -> Self:
            """
            DriverName defines the name of the dynamic resource driver that is used for allocation of a ResourceClaim that uses this class.

            Resource drivers have a unique name in forward domain order (acme.example.com).
            """
            return self._set("driver_name", value)

        def kind(self, value: Optional[Literal["ResourceClass"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceClass.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceClass.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def parameters_ref(
            self, value_or_callback: Optional[ResourceClassParametersReference], /
        ) -> "ResourceClass.Builder": ...

        @overload
        def parameters_ref(
            self,
            value_or_callback: Callable[
                [ResourceClassParametersReference.Builder],
                ResourceClassParametersReference.Builder | ResourceClassParametersReference,
            ],
            /,
        ) -> "ResourceClass.Builder": ...

        @overload
        def parameters_ref(
            self, value_or_callback: Never = ...
        ) -> "ResourceClassParametersReference.BuilderContext": ...

        def parameters_ref(self, value_or_callback=None, /):
            """
            ParametersRef references an arbitrary separate object that may hold parameters that will be used by the driver when allocating a resource that uses this class. A dynamic resource driver can distinguish between parameters stored here and and those stored in ResourceClaimSpec.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClassParametersReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "parameters_ref"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClassParametersReference.builder())
                if isinstance(output, ResourceClassParametersReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("parameters_ref", value)

        def structured_parameters(self, value: Optional[bool], /) -> Self:
            """
            If and only if allocation of claims using this class is handled via structured parameters, then StructuredParameters must be set to true.
            """
            return self._set("structured_parameters", value)

        @overload
        def suitable_nodes(
            self, value_or_callback: Optional[v1.NodeSelector], /
        ) -> "ResourceClass.Builder": ...

        @overload
        def suitable_nodes(
            self,
            value_or_callback: Callable[
                [v1.NodeSelector.Builder], v1.NodeSelector.Builder | v1.NodeSelector
            ],
            /,
        ) -> "ResourceClass.Builder": ...

        @overload
        def suitable_nodes(
            self, value_or_callback: Never = ...
        ) -> "v1.NodeSelector.BuilderContext": ...

        def suitable_nodes(self, value_or_callback=None, /):
            """
            Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a ResourceClaim that has not been allocated yet.

            Setting this field is optional. If null, all nodes are candidates.
            """
            if self._in_context and value_or_callback is None:
                context = v1.NodeSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "suitable_nodes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.NodeSelector.builder())
                if isinstance(output, v1.NodeSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("suitable_nodes", value)

    class BuilderContext(BuilderContextBase["ResourceClass.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClass.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClass."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClass", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClass.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    driver_name: Annotated[str, Field(alias="driverName")]
    """
    DriverName defines the name of the dynamic resource driver that is used for allocation of a ResourceClaim that uses this class.

    Resource drivers have a unique name in forward domain order (acme.example.com).
    """
    kind: Optional[Literal["ResourceClass"]] = "ResourceClass"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    parameters_ref: Annotated[
        Optional[ResourceClassParametersReference], Field(alias="parametersRef")
    ] = None
    """
    ParametersRef references an arbitrary separate object that may hold parameters that will be used by the driver when allocating a resource that uses this class. A dynamic resource driver can distinguish between parameters stored here and and those stored in ResourceClaimSpec.
    """
    structured_parameters: Annotated[Optional[bool], Field(alias="structuredParameters")] = None
    """
    If and only if allocation of claims using this class is handled via structured parameters, then StructuredParameters must be set to true.
    """
    suitable_nodes: Annotated[Optional[v1.NodeSelector], Field(alias="suitableNodes")] = None
    """
    Only nodes matching the selector will be considered by the scheduler when trying to find a Node that fits a Pod when that Pod uses a ResourceClaim that has not been allocated yet.

    Setting this field is optional. If null, all nodes are candidates.
    """


ResourceClassList = ResourceList["ResourceClass"]


class ResourceClassParameters(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClassParameters"]:
            return ResourceClassParameters

        def build(self) -> "ResourceClassParameters":
            return ResourceClassParameters(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        @overload
        def filters(
            self, value_or_callback: List[ResourceFilter], /
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def filters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceFilter, ResourceFilter.Builder]],
                GenericListBuilder[ResourceFilter, ResourceFilter.Builder] | List[ResourceFilter],
            ],
            /,
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def filters(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceFilter.Builder]: ...

        def filters(self, value_or_callback=None, /):
            """
            Filters describes additional contraints that must be met when using the class.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceFilter.Builder]()
                context._parent_builder = self
                context._field_name = "filters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceFilter.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("filters", value)

        @overload
        def generated_from(
            self, value_or_callback: Optional[ResourceClassParametersReference], /
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def generated_from(
            self,
            value_or_callback: Callable[
                [ResourceClassParametersReference.Builder],
                ResourceClassParametersReference.Builder | ResourceClassParametersReference,
            ],
            /,
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def generated_from(
            self, value_or_callback: Never = ...
        ) -> "ResourceClassParametersReference.BuilderContext": ...

        def generated_from(self, value_or_callback=None, /):
            """
            If this object was created from some other resource, then this links back to that resource. This field is used to find the in-tree representation of the class parameters when the parameter reference of the class refers to some unknown type.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClassParametersReference.BuilderContext()
                context._parent_builder = self
                context._field_name = "generated_from"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClassParametersReference.builder())
                if isinstance(output, ResourceClassParametersReference.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("generated_from", value)

        def kind(self, value: Optional[Literal["ResourceClassParameters"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def vendor_parameters(
            self, value_or_callback: List[VendorParameters], /
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def vendor_parameters(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[VendorParameters, VendorParameters.Builder]],
                GenericListBuilder[VendorParameters, VendorParameters.Builder]
                | List[VendorParameters],
            ],
            /,
        ) -> "ResourceClassParameters.Builder": ...

        @overload
        def vendor_parameters(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[VendorParameters.Builder]: ...

        def vendor_parameters(self, value_or_callback=None, /):
            """
            VendorParameters are arbitrary setup parameters for all claims using this class. They are ignored while allocating the claim. There must not be more than one entry per driver.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[VendorParameters.Builder]()
                context._parent_builder = self
                context._field_name = "vendor_parameters"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(VendorParameters.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("vendor_parameters", value)

    class BuilderContext(BuilderContextBase["ResourceClassParameters.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClassParameters.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClassParameters."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClassParameters", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClassParameters.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    filters: Optional[List[ResourceFilter]] = None
    """
    Filters describes additional contraints that must be met when using the class.
    """
    generated_from: Annotated[
        Optional[ResourceClassParametersReference], Field(alias="generatedFrom")
    ] = None
    """
    If this object was created from some other resource, then this links back to that resource. This field is used to find the in-tree representation of the class parameters when the parameter reference of the class refers to some unknown type.
    """
    kind: Optional[Literal["ResourceClassParameters"]] = "ResourceClassParameters"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    vendor_parameters: Annotated[
        Optional[List[VendorParameters]], Field(alias="vendorParameters")
    ] = None
    """
    VendorParameters are arbitrary setup parameters for all claims using this class. They are ignored while allocating the claim. There must not be more than one entry per driver.
    """


ResourceClassParametersList = ResourceList["ResourceClassParameters"]


class ResourceHandle(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceHandle"]:
            return ResourceHandle

        def build(self) -> "ResourceHandle":
            return ResourceHandle(**self._attrs)

        def data(self, value: Optional[str], /) -> Self:
            """
            Data contains the opaque data associated with this ResourceHandle. It is set by the controller component of the resource driver whose name matches the DriverName set in the ResourceClaimStatus this ResourceHandle is embedded in. It is set at allocation time and is intended for processing by the kubelet plugin whose name matches the DriverName set in this ResourceHandle.

            The maximum size of this field is 16KiB. This may get increased in the future, but not reduced.
            """
            return self._set("data", value)

        def driver_name(self, value: Optional[str], /) -> Self:
            """
            DriverName specifies the name of the resource driver whose kubelet plugin should be invoked to process this ResourceHandle's data once it lands on a node. This may differ from the DriverName set in ResourceClaimStatus this ResourceHandle is embedded in.
            """
            return self._set("driver_name", value)

        @overload
        def structured_data(
            self, value_or_callback: Optional[StructuredResourceHandle], /
        ) -> "ResourceHandle.Builder": ...

        @overload
        def structured_data(
            self,
            value_or_callback: Callable[
                [StructuredResourceHandle.Builder],
                StructuredResourceHandle.Builder | StructuredResourceHandle,
            ],
            /,
        ) -> "ResourceHandle.Builder": ...

        @overload
        def structured_data(
            self, value_or_callback: Never = ...
        ) -> "StructuredResourceHandle.BuilderContext": ...

        def structured_data(self, value_or_callback=None, /):
            """
            If StructuredData is set, then it needs to be used instead of Data.
            """
            if self._in_context and value_or_callback is None:
                context = StructuredResourceHandle.BuilderContext()
                context._parent_builder = self
                context._field_name = "structured_data"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(StructuredResourceHandle.builder())
                if isinstance(output, StructuredResourceHandle.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("structured_data", value)

    class BuilderContext(BuilderContextBase["ResourceHandle.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceHandle.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceHandle."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceHandle", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceHandle.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    data: Optional[str] = None
    """
    Data contains the opaque data associated with this ResourceHandle. It is set by the controller component of the resource driver whose name matches the DriverName set in the ResourceClaimStatus this ResourceHandle is embedded in. It is set at allocation time and is intended for processing by the kubelet plugin whose name matches the DriverName set in this ResourceHandle.

    The maximum size of this field is 16KiB. This may get increased in the future, but not reduced.
    """
    driver_name: Annotated[Optional[str], Field(alias="driverName")] = None
    """
    DriverName specifies the name of the resource driver whose kubelet plugin should be invoked to process this ResourceHandle's data once it lands on a node. This may differ from the DriverName set in ResourceClaimStatus this ResourceHandle is embedded in.
    """
    structured_data: Annotated[
        Optional[StructuredResourceHandle], Field(alias="structuredData")
    ] = None
    """
    If StructuredData is set, then it needs to be used instead of Data.
    """


class ResourceSlice(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceSlice"]:
            return ResourceSlice

        def build(self) -> "ResourceSlice":
            return ResourceSlice(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def driver_name(self, value: str, /) -> Self:
            """
            DriverName identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
            """
            return self._set("driver_name", value)

        def kind(self, value: Optional[Literal["ResourceSlice"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceSlice.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceSlice.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def named_resources(
            self, value_or_callback: Optional[NamedResourcesResources], /
        ) -> "ResourceSlice.Builder": ...

        @overload
        def named_resources(
            self,
            value_or_callback: Callable[
                [NamedResourcesResources.Builder],
                NamedResourcesResources.Builder | NamedResourcesResources,
            ],
            /,
        ) -> "ResourceSlice.Builder": ...

        @overload
        def named_resources(
            self, value_or_callback: Never = ...
        ) -> "NamedResourcesResources.BuilderContext": ...

        def named_resources(self, value_or_callback=None, /):
            """
            NamedResources describes available resources using the named resources model.
            """
            if self._in_context and value_or_callback is None:
                context = NamedResourcesResources.BuilderContext()
                context._parent_builder = self
                context._field_name = "named_resources"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(NamedResourcesResources.builder())
                if isinstance(output, NamedResourcesResources.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("named_resources", value)

        def node_name(self, value: Optional[str], /) -> Self:
            """
            NodeName identifies the node which provides the resources if they are local to a node.

            A field selector can be used to list only ResourceSlice objects with a certain node name.
            """
            return self._set("node_name", value)

    class BuilderContext(BuilderContextBase["ResourceSlice.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceSlice.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceSlice."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceSlice", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceSlice.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    driver_name: Annotated[str, Field(alias="driverName")]
    """
    DriverName identifies the DRA driver providing the capacity information. A field selector can be used to list only ResourceSlice objects with a certain driver name.
    """
    kind: Optional[Literal["ResourceSlice"]] = "ResourceSlice"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    named_resources: Annotated[Optional[NamedResourcesResources], Field(alias="namedResources")] = (
        None
    )
    """
    NamedResources describes available resources using the named resources model.
    """
    node_name: Annotated[Optional[str], Field(alias="nodeName")] = None
    """
    NodeName identifies the node which provides the resources if they are local to a node.

    A field selector can be used to list only ResourceSlice objects with a certain node name.
    """


ResourceSliceList = ResourceList["ResourceSlice"]


class AllocationResult(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["AllocationResult"]:
            return AllocationResult

        def build(self) -> "AllocationResult":
            return AllocationResult(**self._attrs)

        @overload
        def available_on_nodes(
            self, value_or_callback: Optional[v1.NodeSelector], /
        ) -> "AllocationResult.Builder": ...

        @overload
        def available_on_nodes(
            self,
            value_or_callback: Callable[
                [v1.NodeSelector.Builder], v1.NodeSelector.Builder | v1.NodeSelector
            ],
            /,
        ) -> "AllocationResult.Builder": ...

        @overload
        def available_on_nodes(
            self, value_or_callback: Never = ...
        ) -> "v1.NodeSelector.BuilderContext": ...

        def available_on_nodes(self, value_or_callback=None, /):
            """
            This field will get set by the resource driver after it has allocated the resource to inform the scheduler where it can schedule Pods using the ResourceClaim.

            Setting this field is optional. If null, the resource is available everywhere.
            """
            if self._in_context and value_or_callback is None:
                context = v1.NodeSelector.BuilderContext()
                context._parent_builder = self
                context._field_name = "available_on_nodes"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(v1.NodeSelector.builder())
                if isinstance(output, v1.NodeSelector.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("available_on_nodes", value)

        @overload
        def resource_handles(
            self, value_or_callback: List[ResourceHandle], /
        ) -> "AllocationResult.Builder": ...

        @overload
        def resource_handles(
            self,
            value_or_callback: Callable[
                [GenericListBuilder[ResourceHandle, ResourceHandle.Builder]],
                GenericListBuilder[ResourceHandle, ResourceHandle.Builder] | List[ResourceHandle],
            ],
            /,
        ) -> "AllocationResult.Builder": ...

        @overload
        def resource_handles(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceHandle.Builder]: ...

        def resource_handles(self, value_or_callback=None, /):
            """
            ResourceHandles contain the state associated with an allocation that should be maintained throughout the lifetime of a claim. Each ResourceHandle contains data that should be passed to a specific kubelet plugin once it lands on a node. This data is returned by the driver after a successful allocation and is opaque to Kubernetes. Driver documentation may explain to users how to interpret this data if needed.

            Setting this field is optional. It has a maximum size of 32 entries. If null (or empty), it is assumed this allocation will be processed by a single kubelet plugin with no ResourceHandle data attached. The name of the kubelet plugin invoked will match the DriverName set in the ResourceClaimStatus this AllocationResult is embedded in.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceHandle.Builder]()
                context._parent_builder = self
                context._field_name = "resource_handles"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceHandle.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("resource_handles", value)

        def shareable(self, value: Optional[bool], /) -> Self:
            """
            Shareable determines whether the resource supports more than one consumer at a time.
            """
            return self._set("shareable", value)

    class BuilderContext(BuilderContextBase["AllocationResult.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = AllocationResult.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for AllocationResult."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["AllocationResult", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use AllocationResult.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    available_on_nodes: Annotated[Optional[v1.NodeSelector], Field(alias="availableOnNodes")] = None
    """
    This field will get set by the resource driver after it has allocated the resource to inform the scheduler where it can schedule Pods using the ResourceClaim.

    Setting this field is optional. If null, the resource is available everywhere.
    """
    resource_handles: Annotated[Optional[List[ResourceHandle]], Field(alias="resourceHandles")] = (
        None
    )
    """
    ResourceHandles contain the state associated with an allocation that should be maintained throughout the lifetime of a claim. Each ResourceHandle contains data that should be passed to a specific kubelet plugin once it lands on a node. This data is returned by the driver after a successful allocation and is opaque to Kubernetes. Driver documentation may explain to users how to interpret this data if needed.

    Setting this field is optional. It has a maximum size of 32 entries. If null (or empty), it is assumed this allocation will be processed by a single kubelet plugin with no ResourceHandle data attached. The name of the kubelet plugin invoked will match the DriverName set in the ResourceClaimStatus this AllocationResult is embedded in.
    """
    shareable: Optional[bool] = None
    """
    Shareable determines whether the resource supports more than one consumer at a time.
    """


class ResourceClaimStatus(BaseModel):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimStatus"]:
            return ResourceClaimStatus

        def build(self) -> "ResourceClaimStatus":
            return ResourceClaimStatus(**self._attrs)

        @overload
        def allocation(
            self, value_or_callback: Optional[AllocationResult], /
        ) -> "ResourceClaimStatus.Builder": ...

        @overload
        def allocation(
            self,
            value_or_callback: Callable[
                [AllocationResult.Builder], AllocationResult.Builder | AllocationResult
            ],
            /,
        ) -> "ResourceClaimStatus.Builder": ...

        @overload
        def allocation(
            self, value_or_callback: Never = ...
        ) -> "AllocationResult.BuilderContext": ...

        def allocation(self, value_or_callback=None, /):
            """
            Allocation is set by the resource driver once a resource or set of resources has been allocated successfully. If this is not specified, the resources have not been allocated yet.
            """
            if self._in_context and value_or_callback is None:
                context = AllocationResult.BuilderContext()
                context._parent_builder = self
                context._field_name = "allocation"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(AllocationResult.builder())
                if isinstance(output, AllocationResult.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("allocation", value)

        def deallocation_requested(self, value: Optional[bool], /) -> Self:
            """
            DeallocationRequested indicates that a ResourceClaim is to be deallocated.

            The driver then must deallocate this claim and reset the field together with clearing the Allocation field.

            While DeallocationRequested is set, no new consumers may be added to ReservedFor.
            """
            return self._set("deallocation_requested", value)

        def driver_name(self, value: Optional[str], /) -> Self:
            """
            DriverName is a copy of the driver name from the ResourceClass at the time when allocation started.
            """
            return self._set("driver_name", value)

        @overload
        def reserved_for(
            self, value_or_callback: List[ResourceClaimConsumerReference], /
        ) -> "ResourceClaimStatus.Builder": ...

        @overload
        def reserved_for(
            self,
            value_or_callback: Callable[
                [
                    GenericListBuilder[
                        ResourceClaimConsumerReference,
                        ResourceClaimConsumerReference.Builder,
                    ]
                ],
                GenericListBuilder[
                    ResourceClaimConsumerReference,
                    ResourceClaimConsumerReference.Builder,
                ]
                | List[ResourceClaimConsumerReference],
            ],
            /,
        ) -> "ResourceClaimStatus.Builder": ...

        @overload
        def reserved_for(
            self, value_or_callback: Never = ...
        ) -> ListBuilderContext[ResourceClaimConsumerReference.Builder]: ...

        def reserved_for(self, value_or_callback=None, /):
            """
            ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started.

            There can be at most 32 such reservations. This may get increased in the future, but not reduced.
            """
            if self._in_context and value_or_callback is None:
                context = ListBuilderContext[ResourceClaimConsumerReference.Builder]()
                context._parent_builder = self
                context._field_name = "reserved_for"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimConsumerReference.list_builder())
                if isinstance(output, GenericListBuilder):
                    value = output.build()
                else:
                    value = output
            return self._set("reserved_for", value)

    class BuilderContext(BuilderContextBase["ResourceClaimStatus.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimStatus.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimStatus."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimStatus", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimStatus.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    allocation: Optional[AllocationResult] = None
    """
    Allocation is set by the resource driver once a resource or set of resources has been allocated successfully. If this is not specified, the resources have not been allocated yet.
    """
    deallocation_requested: Annotated[Optional[bool], Field(alias="deallocationRequested")] = None
    """
    DeallocationRequested indicates that a ResourceClaim is to be deallocated.

    The driver then must deallocate this claim and reset the field together with clearing the Allocation field.

    While DeallocationRequested is set, no new consumers may be added to ReservedFor.
    """
    driver_name: Annotated[Optional[str], Field(alias="driverName")] = None
    """
    DriverName is a copy of the driver name from the ResourceClass at the time when allocation started.
    """
    reserved_for: Annotated[
        Optional[List[ResourceClaimConsumerReference]], Field(alias="reservedFor")
    ] = None
    """
    ReservedFor indicates which entities are currently allowed to use the claim. A Pod which references a ResourceClaim which is not reserved for that Pod will not be started.

    There can be at most 32 such reservations. This may get increased in the future, but not reduced.
    """


class ResourceClaimTemplate(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaimTemplate"]:
            return ResourceClaimTemplate

        def build(self) -> "ResourceClaimTemplate":
            return ResourceClaimTemplate(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ResourceClaimTemplate"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceClaimTemplate.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceClaimTemplate.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(
            self, value_or_callback: ResourceClaimTemplateSpec, /
        ) -> "ResourceClaimTemplate.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ResourceClaimTemplateSpec.Builder],
                ResourceClaimTemplateSpec.Builder | ResourceClaimTemplateSpec,
            ],
            /,
        ) -> "ResourceClaimTemplate.Builder": ...

        @overload
        def spec(
            self, value_or_callback: Never = ...
        ) -> "ResourceClaimTemplateSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Describes the ResourceClaim that is to be generated.

            This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClaimTemplateSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimTemplateSpec.builder())
                if isinstance(output, ResourceClaimTemplateSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

    class BuilderContext(BuilderContextBase["ResourceClaimTemplate.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaimTemplate.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaimTemplate."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaimTemplate", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaimTemplate.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ResourceClaimTemplate"]] = "ResourceClaimTemplate"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    spec: ResourceClaimTemplateSpec
    """
    Describes the ResourceClaim that is to be generated.

    This field is immutable. A ResourceClaim will get created by the control plane for a Pod when needed and then not get updated anymore.
    """


ResourceClaimTemplateList = ResourceList["ResourceClaimTemplate"]


class ResourceClaim(Resource):
    class Builder(BaseModelBuilder):
        @property
        def cls(self) -> Type["ResourceClaim"]:
            return ResourceClaim

        def build(self) -> "ResourceClaim":
            return ResourceClaim(**self._attrs)

        def api_version(self, value: Optional[Literal["resource.k8s.io/v1alpha2"]], /) -> Self:
            """
            APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
            """
            return self._set("api_version", value)

        def kind(self, value: Optional[Literal["ResourceClaim"]], /) -> Self:
            """
            Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
            """
            return self._set("kind", value)

        @overload
        def metadata(
            self, value_or_callback: Optional[apimachinery.ObjectMeta], /
        ) -> "ResourceClaim.Builder": ...

        @overload
        def metadata(
            self,
            value_or_callback: Callable[
                [apimachinery.ObjectMeta.Builder],
                apimachinery.ObjectMeta.Builder | apimachinery.ObjectMeta,
            ],
            /,
        ) -> "ResourceClaim.Builder": ...

        @overload
        def metadata(
            self, value_or_callback: Never = ...
        ) -> "apimachinery.ObjectMeta.BuilderContext": ...

        def metadata(self, value_or_callback=None, /):
            """
            Standard object metadata
            """
            if self._in_context and value_or_callback is None:
                context = apimachinery.ObjectMeta.BuilderContext()
                context._parent_builder = self
                context._field_name = "metadata"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(apimachinery.ObjectMeta.builder())
                if isinstance(output, apimachinery.ObjectMeta.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("metadata", value)

        @overload
        def spec(self, value_or_callback: ResourceClaimSpec, /) -> "ResourceClaim.Builder": ...

        @overload
        def spec(
            self,
            value_or_callback: Callable[
                [ResourceClaimSpec.Builder],
                ResourceClaimSpec.Builder | ResourceClaimSpec,
            ],
            /,
        ) -> "ResourceClaim.Builder": ...

        @overload
        def spec(self, value_or_callback: Never = ...) -> "ResourceClaimSpec.BuilderContext": ...

        def spec(self, value_or_callback=None, /):
            """
            Spec describes the desired attributes of a resource that then needs to be allocated. It can only be set once when creating the ResourceClaim.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClaimSpec.BuilderContext()
                context._parent_builder = self
                context._field_name = "spec"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimSpec.builder())
                if isinstance(output, ResourceClaimSpec.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("spec", value)

        @overload
        def status(
            self, value_or_callback: Optional[ResourceClaimStatus], /
        ) -> "ResourceClaim.Builder": ...

        @overload
        def status(
            self,
            value_or_callback: Callable[
                [ResourceClaimStatus.Builder],
                ResourceClaimStatus.Builder | ResourceClaimStatus,
            ],
            /,
        ) -> "ResourceClaim.Builder": ...

        @overload
        def status(
            self, value_or_callback: Never = ...
        ) -> "ResourceClaimStatus.BuilderContext": ...

        def status(self, value_or_callback=None, /):
            """
            Status describes whether the resource is available and with which attributes.
            """
            if self._in_context and value_or_callback is None:
                context = ResourceClaimStatus.BuilderContext()
                context._parent_builder = self
                context._field_name = "status"
                return context

            value = value_or_callback
            if callable(value_or_callback):
                output = value_or_callback(ResourceClaimStatus.builder())
                if isinstance(output, ResourceClaimStatus.Builder):
                    value = output.build()
                else:
                    value = output
            return self._set("status", value)

    class BuilderContext(BuilderContextBase["ResourceClaim.Builder"]):
        def model_post_init(self, __context) -> None:
            self._builder = ResourceClaim.Builder()
            self._builder._in_context = True
            self._parent_builder = None
            self._field_name = None

    @classmethod
    def builder(cls) -> Builder:
        return cls.Builder()

    @classmethod
    def new(cls) -> BuilderContext:
        """Creates a new context manager builder for ResourceClaim."""
        return cls.BuilderContext()

    class ListBuilder(GenericListBuilder["ResourceClaim", Builder]):
        def __init__(self):
            raise NotImplementedError(
                "This class is not meant to be instantiated. Use ResourceClaim.list_builder() instead."
            )

    @classmethod
    def list_builder(cls) -> ListBuilder:
        return GenericListBuilder[cls, cls.Builder]()  # type: ignore

    api_version: Annotated[
        Optional[Literal["resource.k8s.io/v1alpha2"]], Field(alias="apiVersion")
    ] = "resource.k8s.io/v1alpha2"
    """
    APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
    """
    kind: Optional[Literal["ResourceClaim"]] = "ResourceClaim"
    """
    Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
    """
    metadata: Optional[apimachinery.ObjectMeta] = None
    """
    Standard object metadata
    """
    spec: ResourceClaimSpec
    """
    Spec describes the desired attributes of a resource that then needs to be allocated. It can only be set once when creating the ResourceClaim.
    """
    status: Optional[ResourceClaimStatus] = None
    """
    Status describes whether the resource is available and with which attributes.
    """


ResourceClaimList = ResourceList["ResourceClaim"]
