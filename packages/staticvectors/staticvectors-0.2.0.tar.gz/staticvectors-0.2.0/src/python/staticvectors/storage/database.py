"""
Database module
"""

import os
import sqlite3

import numpy as np

from .base import Storage


# pylint: disable=W0223
class Database(Storage):
    """
    SQLite storage format. Also supports legacy magnitude-lite databases (https://github.com/neuml/magnitude).

    Configuration, vectors and vocabulary are all stored in SQLite. Configuration can optionally be mirrored in a JSON file to facilitate
    loading from the Hugging Face Hub.

    This format only supports unquantized vectors, it does not support classification models.
    """

    @staticmethod
    def isdatabase(path):
        """
        Checks if this is a SQLite database.

        Args:
            path: path to check

        Returns:
            True if this is a SQLite database
        """

        # Read file header and check for SQLite
        if os.path.isfile(path) and os.path.getsize(path) >= 100:
            # Read 100 byte SQLite header
            with open(path, "rb") as f:
                header = f.read(100)

            # Check for SQLite header
            return header.startswith(b"SQLite format 3\000")

        # Check for sqlite extension
        return path.lower().endswith(".sqlite")

    def __init__(self, path, create=False, storefile=False):
        # Call parent constructor
        super().__init__(path, create, storefile)

        # Database parameters
        self.connection = None

    def loadconfig(self):
        # Open database connection
        self.connect()

        # Extract configuration from database when model is a single file
        if self.storefile:
            return {"source": os.path.basename(self.path), "total": self.connection.total, "dim": self.connection.dimensions}

        # Default method
        return super().loadconfig()

    def loadtensors(self):
        # Returns a tensors view
        return DatabaseTensors(self.connection), None, None

    def loadvocab(self):
        # Return a tokens view. This behaves like a dictionary but except that data is lazily loaded from the database
        return DatabaseTokens(self.connection), None, None

    def save(self, config, vectors, pq=None, weights=None, tokens=None, labels=None, counts=None):
        # Only save configuration when persisting to a directory
        if not self.storefile:
            self.saveconfig(config)

        # Open a database for writing
        self.connect(write=True)

        # Save vectors and vocab to database
        self.connection.save(vectors, tokens)

    def storage(self):
        return "sqlite"

    def connect(self, write=False):
        """
        Opens a database connection for this instance.

        Args:
            write: if True, this connection is opened for writing, which deletes an existing database
        """

        # Check if this is a file model or directory model
        path = self.path if self.storefile else f"{self.path}/model.sqlite"

        # Retrieve model when this is a read connection
        path = path if write else self.retrieve(path)

        # Remove existing database for write operations
        if write and os.path.exists(path):
            os.remove(path)

        self.connection = Connection(path, write)


class Connection:
    """
    Methods to interface with the underlying SQLite database.
    """

    def __init__(self, path, write):
        """
        Creates a new database connection.

        Args:
            path: path to database file
            write: if this connection is open for writing
        """

        # Database connection
        self.path = path
        self.connection = sqlite3.connect(path, check_same_thread=False)
        self.cursor = self.connection.cursor()

        # Model parameters
        self.vectortable, self.configtable = None, None
        self.total, self.dimensions = None, None
        self.columns = None
        self.divisor = None

        # Data parameters used when saving data
        self.vectors, self.tokens = None, None

        # Read existing database parameters when not open for writing
        if not write:
            self.parameters()

    def parameters(self):
        """
        Sets parameters stored in the SQLite database on this instance.
        """

        # Check if this database was generated by magnitude or this library
        if self.cursor.execute("SELECT 1 FROM sqlite_master WHERE type='table' AND name='magnitude'").fetchone():
            self.vectortable, self.configtable = "magnitude", "magnitude_format"
        else:
            self.vectortable, self.configtable = "vectors", "config"

        # Configuration parameters
        self.total = self.cursor.execute(f"SELECT value FROM {self.configtable} WHERE key='size'").fetchone()[0]
        self.dimensions = self.cursor.execute(f"SELECT value FROM {self.configtable} WHERE key='dim'").fetchone()[0]
        precision = self.cursor.execute(f"SELECT value FROM {self.configtable} WHERE key='precision'").fetchone()[0]

        # Vector columns
        self.columns = ",".join(f"dim_{x}" for x in range(self.dimensions))

        # Precision divisor
        self.divisor = 10**precision

    def save(self, vectors, tokens):
        """
        Saves content to the SQLite database.

        Args:
            vectors: model vectors
            tokens: tokens used in model
        """

        # Default precision
        precision = 7

        # Create dimension columns
        columns = ", ".join(f"dim_{x} INTEGER" for x in range(vectors.shape[1]))

        # Create tables and indexes
        self.cursor.execute("CREATE TABLE config (key TEXT, value INTEGER)")
        self.cursor.execute(f"CREATE TABLE vectors (key TEXT, {columns})")
        self.cursor.execute("CREATE INDEX vectors_key ON vectors(key)")

        # Insert config
        for name, value in {"size": vectors.shape[0], "dim": vectors.shape[1], "precision": precision}.items():
            self.cursor.execute("INSERT INTO config VALUES(?, ?)", [name, value])

        # Convert to integers
        vectors = (vectors * 10**precision).astype(np.int32)

        # Insert vectors
        values = ",".join("?" for _ in range(vectors.shape[1] + 1))
        for token, tokenid in tokens.items():
            # SQL bind parameters
            row = [token] + [int(y) for y in vectors[tokenid]]

            # Insert row, adjust token index to be 1-based
            self.cursor.execute(f"INSERT INTO vectors VALUES ({values})", row)

        # Save results
        self.connection.commit()
        self.connection.close()


class DatabaseTensors:
    """
    Array-like interface to vectors. Lookups are run against the backing database.
    """

    def __init__(self, connection):
        """
        Creates a DatabaseTensors instance.

        Args:
            connection: database connection
        """

        # Database connection
        self.connection = connection.connection
        self.cursor = connection.cursor

        # Model parameters
        self.vectortable = connection.vectortable
        self.total = connection.total
        self.columns = connection.columns
        self.divisor = connection.divisor

    def __getitem__(self, index):
        """
        Enables in-place access to an existing SQLite vector database. This method adjusts the input 0-based
        indices to 1-based. This supports a single index or a list of indexes. The return value will match the input
        type.

        Args:
            index: index or list of indices

        Returns:
            vector(s) for indices
        """

        embeddings = []
        indices = index if isinstance(index, (tuple, list, np.ndarray)) else (index,)

        for x in indices:
            # Index out of range error
            if x >= self.total:
                raise IndexError

            # SQLite ids are 1-based, adjust to 1-based
            x += 1

            # Lookup vector. Convert integer to float.
            self.cursor.execute(f"SELECT {self.columns} FROM {self.vectortable} WHERE rowid = ?", [int(x)])
            vector = np.array(self.cursor.fetchone(), dtype=np.float32) / self.divisor

            # Replace 0's with a small number. This is due to storing integers in the database
            vector = np.where(vector == 0, 1e-15, vector)

            # Save vector
            embeddings.append(vector)

        # Return type should match indices type (list vs single index)
        return np.array(embeddings) if isinstance(index, (tuple, list, np.ndarray)) else embeddings[0]

    def __len__(self):
        """
        Gets the total size of the database.

        Returns:
            total database size
        """

        return self.total


class DatabaseTokens:
    """
    Dictionary-like interface to model keys. Lookups are run against the backing database.
    """

    def __init__(self, connection):
        """
        Creates a new Tokens instance.

        Args:
            connection: database connection
        """

        self.cursor = connection.cursor
        self.vectortable = connection.vectortable

    def __getitem__(self, key):
        """
        Gets an item by key.

        Args:
            key: token

        Returns:
            token id
        """

        row = self.cursor.execute(f"SELECT rowid - 1 FROM {self.vectortable} WHERE key = ? COLLATE BINARY", [key]).fetchone()
        if not row:
            raise IndexError

        return row[0]

    def __contains__(self, key):
        """
        Checks if key is present.

        Args:
            key: token

        Returns:
            True if key is present, False otherwise
        """

        return self.cursor.execute(f"SELECT 1 FROM {self.vectortable} WHERE key = ? COLLATE BINARY", [key]).fetchone()

    def items(self):
        """
        Item iterator.

        Returns:
            iterator of (key, value) pairs
        """

        # Iterate over all tokens. SQLite rowids are 1-based, adjust to 0-based.
        self.cursor.execute(f"SELECT key, rowid - 1 FROM {self.vectortable} ORDER BY rowid")
        return self.cursor
