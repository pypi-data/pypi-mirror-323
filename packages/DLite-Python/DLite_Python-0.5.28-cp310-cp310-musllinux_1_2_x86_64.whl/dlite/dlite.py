# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.3.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

"""
Python bindings to DLite


"""

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _dlite
else:
    import _dlite

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def _get_storage_base():
    return _dlite._get_storage_base()

def _get_mapping_base():
    return _dlite._get_mapping_base()

def errgetexc(code):
    r"""Returns DLite exception corresponding to error code."""
    return _dlite.errgetexc(code)

def _get_number_of_errors():
    return _dlite._get_number_of_errors()

def run_file(path, globals=None, locals=None):
    r"""Exposing PyRun_File from the Python C API."""
    return _dlite.run_file(path, globals, locals)

for n in range(_dlite._get_number_of_errors()):
    exc = errgetexc(-n)
    setattr(_dlite, exc.__name__, exc)
DLiteStorageBase = _dlite._get_storage_base()
DLiteMappingBase = _dlite._get_mapping_base()
del n, exc


class DLiteProtocolBase:
    """Base class for Python protocol plugins."""


def instance_cast(inst, newtype=None):
    """Return instance converted to a new instance subclass.

    By default the convertion is done to the type of the underlying
    instance object.

    Any subclass of `dlite.Instance` can be provided as `newtype`.
    Only downcasting to subclasses of `inst` are permitted.  For
    casting to other types, `dlite.DLiteTypeError` is raised.
    """
    if newtype:
        subclasses = getattr(newtype, "__subclasses__")
        if type(inst) in subclasses():
            inst.__class__ = newtype
        else:
            raise _dlite.DLiteTypeError(
                f"cannot upcast {type(inst)} to {newtype}"
            )
    elif inst.meta.uri == COLLECTION_ENTITY:
        inst.__class__ = Collection
    elif inst.is_meta:
        inst.__class__ = Metadata
    return inst


# Deprecated exceptions
class DLiteSearchError(_dlite.DLiteLookupError):
    """Deprecated.  Has been renamed to DLiteLookupError."""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        deprecation_warning(
            "0.7.0",
            "DLiteSearchError has been renamed to DLiteLookupError."
        )



def get_version():
    r"""
    get_version() -> char const *
    Returns the current version of DLite.

    """
    return _dlite.get_version()

def get_license():
    r"""
    get_license() -> char const *
    Returns DLite licenses information.

    """
    return _dlite.get_license()

def get_uuid(id=None):
    r"""
    get_uuid(id=None)
    Returns an UUID, depending on:

    - If `id` is NULL or empty, generates a new random version 4 UUID.
    - If `id` is not a valid UUID string, generates a new version 5 sha1-based
      UUID from `id` using the DNS namespace.

    Otherwise return `id` (which already must be a valid UUID).

    """
    return _dlite.get_uuid(id)

def get_uuid_version(id=None):
    r"""
    get_uuid_version(id=None) -> posstatus_t
    Returns the generated UUID version number if `id` had been passed to
    get_uuid() or zero if `id` is already a valid UUID.

    """
    return _dlite.get_uuid_version(id)

def join_meta_uri(name, version, namespace):
    r"""
    join_meta_uri(name, version, namespace) -> char *
    Returns a (metadata) uri by combining `name`, `version` and `namespace` as:

        namespace/version/name

    """
    return _dlite.join_meta_uri(name, version, namespace)

def split_meta_uri(uri):
    r"""split_meta_uri(uri)"""
    return _dlite.split_meta_uri(uri)

def join_url(driver, location, options=None, fragment=None):
    r"""
    join_url(driver, location, options=None, fragment=None) -> char *
    Returns an url constructed from the arguments of the form:

        driver://location?options#fragment

    The `driver`, `options` and `fragment` arguments may be None.

    """
    return _dlite.join_url(driver, location, options, fragment)

def split_url(url):
    r"""
    split_url(url)
    Returns a (driver, location, options, fragment)-tuplet by splitting
    `url` of the form

        driver://location?options#fragment

    into four parts.

    """
    return _dlite.split_url(url)

def globmatch(pattern, s):
    r"""
    globmatch(pattern, s) -> int
    Match string 's' against glob pattern 'pattern' and return zero on
    match.

    Understands the following patterns:

    - `*`: Any number of characters.
    - `?`: Any single character.
    - `[a-z]`: Any single character in the range a-z.
    - `[^a-z]`: Any single character not in the range a-z.
    - `\x`: Match x.

    """
    return _dlite.globmatch(pattern, s)

def _mark_python_atexit():
    r"""_mark_python_atexit()"""
    return _dlite._mark_python_atexit()

def errclr():
    r"""
    errclr()
    Clear the last error (setting its error code to zero).

    """
    return _dlite.errclr()

def errval():
    r"""
    errval() -> int
    Returns the error code (error value) or the last error or zero if no errors
    have occured since the last call to dlite.errclr().

    """
    return _dlite.errval()

def errmsg():
    r"""
    errmsg() -> char const *
    Returns the error message of the last error.  An empty string is returned if
    no errors have occured since the last call to dlite.errclr().

    """
    return _dlite.errmsg()

def err_get_stream():
    r"""err_get_stream() -> FILE *"""
    return _dlite.err_get_stream()

def err_set_stream(arg1):
    r"""err_set_stream(arg1)"""
    return _dlite.err_set_stream(arg1)

def err_set_file(filename):
    r"""
    err_set_file(filename)
    Set error log file. Special values includes:

    - `None` or empty: Turn off error output.
    - `<stderr>`: Standard error.
    - `<stdout>`: Standard output.

    All other values are treated as a filename that will be opened in append mode.

    """
    return _dlite.err_set_file(filename)

def _err_getcode(name):
    r"""
    _err_getcode(name) -> int
    Return DLite error code corresponding to `name`.  Unknown names will return
    `dliteUnknownError`.

    """
    return _dlite._err_getcode(name)

def _err_ignore_set(code, value):
    r"""
    _err_ignore_set(code, value)
    Set whether to ignore printing given error code.

    """
    return _dlite._err_ignore_set(code, value)

def _err_ignore_get(code):
    r"""
    _err_ignore_get(code) -> int
    Return whether printing is ignored for given error code.

    """
    return _dlite._err_ignore_get(code)

def _err_mask_get():
    r"""_err_mask_get() -> int64_t"""
    return _dlite._err_mask_get()

def _err_mask_set(mask):
    r"""_err_mask_set(mask)"""
    return _dlite._err_mask_set(mask)

def errcheck():
    r"""
    errcheck()
    Just check for errors, do nothing else.
    """
    return _dlite.errcheck()

def get_warnings_hide():
    r"""
    get_warnings_hide() -> int
    Return a list with the `[hide, pattern]` parameters for controlling whether
    warnings are shown.

    """
    return _dlite.get_warnings_hide()

def set_warnings_hide(hide, pattern=None):
    r"""
    set_warnings_hide(hide, pattern=None)
    Sets parameters controlling whether to hide warnings.
    """
    return _dlite.set_warnings_hide(hide, pattern)

def asbool(str):
    r"""
    asbool(str) -> bool
    Set error stream.

    """
    return _dlite.asbool(str)

def chk_semver(version, n=-1):
    r"""
    chk_semver(version, n=-1) -> int
    Check if `version` is a valid semantic version 2.0.0 number.

    By default, the whole string is checked.  If `n` is non-negative, only
    the initial part of `version` is checked, at most `n` characters.

    Returns the length of the valid part of `version` or -1 if `version` is
    not a valid semantic number.

    """
    return _dlite.chk_semver(version, n)

def cmp_semver(v1, v2, n=-1):
    r"""
    cmp_semver(v1, v2, n=-1) -> int
    Compare semantic version strings `v1` and `v2`.

    Returns -1 if `v1 < v2`, 0 if `v1 == v2` and 1 if `v1 > v2`.

    By default, the whole of `v1` and `v2` are compared.  If `n` is non-negative,
    only the initial part of `v1` and `v2` are compared, at most `n` characters.

    """
    return _dlite.cmp_semver(v1, v2, n)

def uriencode(INPUT):
    r"""
    uriencode(INPUT) -> char *
    Return percent-encoded copy of input.
    """
    return _dlite.uriencode(INPUT)

def uridecode(INPUT):
    r"""
    uridecode(INPUT) -> status_t
    Return percent-decoded copy of input.
    """
    return _dlite.uridecode(INPUT)


import atexit
import warnings


atexit.register(_mark_python_atexit)


class errctl():
    """Context manager for temporary disabling specific DLite error
    messages or redirecting them.

    Arguments:
        hide: Sequence of DLiteException subclasses or exception names
            corresponding to error messages to hide.  A single class or
            name is also allowed.
            May also be a boolean, in which case error messages will be
            hidden/shown.
        show: Sequence of DLiteException subclasses or exception names
            corresponding to error messages to show.  A single class or
            name is also allowed.
            May also be a boolean, in which case error messages will be
            shown/hidden.
        filename: Filename to redirect errors to.  The following values
            are handled specially:
            - "None" or empty: No output is written.
            - "<stderr>": Write errors to stderr (default).
            - "<stdout>": Write errors to stdout.

    Attributes:
        filename: Filename to redirect errors to.

    """
    def __init__(self, hide=(), show=(), filename="<stderr>"):
        allcodes = [-i for i in range(1, _dlite._get_number_of_errors())]

        if hide is True or show is False:
            self.hide = allcodes
        elif hide is not False:
            self.hide = self._as_codes(hide)

        if show is True or hide is False:
            self.show = allcodes
        elif show is not False:
            self.show = self._as_codes(show)

        self.filename = filename

    def __enter__(self):
        self.mask = _dlite._err_mask_get()
        for code in self.hide:
            _dlite._err_ignore_set(code, 1)
        for code in self.show:
            _dlite._err_ignore_set(code, 0)
        self.f = _dlite.err_get_stream()
        _dlite.err_set_file(self.filename)

    def __exit__(self, *exc):
        ignored = _dlite._err_ignore_get(_dlite.errval())
        _dlite._err_mask_set(self.mask)
        _dlite.err_set_stream(self.f)
        if ignored or self.filename is None:
            _dlite.errclr()

    @staticmethod
    def _as_codes(seq):
        """Return sequence of exceptions/exception names as a sequence of
        DLite error coces.  `seq` may also be a single exception or name."""
        sequence = [seq] if isinstance(seq, (str, type)) else seq
        errnames = [
            exc.__name__ if isinstance(exc, type) else str(exc)
            for exc in sequence
        ]
        if "DLiteError" in errnames:
            return [-i for i in range(1, _dlite._get_number_of_errors())]
        return [_dlite._err_getcode(errname) for errname in errnames]


silent = errctl(hide=True)
"""Context manager for a silent code block.  Same as `errctl(hide=True)`."""

class HideDLiteWarnings():
    """Context manager for hiding warnings.

    Arguments:
        hide: If true, hide warnings if `pattern` is None or `pattern`
            matches the warning message.
            If false, hide warnings if `pattern` is given and don't
            match the warning message.
        pattern: Optional glob pattern matching the warning message.

    """
    def __init__(self, hide=True, pattern=None):
        self.hide = int(hide)
        self.pattern = pattern

    def __enter__(self):
        self._oldstate = get_warnings_hide()
        set_warnings_hide(self.hide, self.pattern)

    def __exit__(self, *exc):
        set_warnings_hide(*self._oldstate)


# A set for keeping track of already issued deprecation warnings
_deprecation_warning_record = set()

def deprecation_warning(version_removed, descr):
    """Issues a deprecation warning.

    Arguments:
        version_removed: The version the deprecated feature is
            expected to be finally removed.
        descr: Description of the deprecated feature.

    Returns non-zero on error.
    """
    if descr in _deprecation_warning_record:
        return
    _deprecation_warning_record.add(descr)

    warnings.warn(
        f"{descr}\nIt will be removed in v{version_removed}",
        DeprecationWarning,
        stacklevel=2,
    )

    dlite_version = get_version()
    if chk_semver(version_removed) < 0:
        raise SystemError(
            f"argument `version_removed='{version_removed}'` must be a "
            "valid semantic version number",
        )
    if chk_semver(dlite_version) < 0:
        raise SystemError(
            f"DLite version number is not semantic: {dlite_version}"
        )
    if cmp_semver(version_removed, dlite_version) <= 0:
        raise SystemError(
            "deprecated feature was supposed to be removed in version "
            f"{version_removed}: {descr}"
        )


BlobType = _dlite.BlobType

BoolType = _dlite.BoolType

IntType = _dlite.IntType

UIntType = _dlite.UIntType

FloatType = _dlite.FloatType

FixStringType = _dlite.FixStringType

StringPtrType = _dlite.StringPtrType

DimensionType = _dlite.DimensionType

PropertyType = _dlite.PropertyType

RelationType = _dlite.RelationType


def from_typename(typename):
    r"""
    from_typename(typename) -> status_t
    Returns type number and size from given type name.
    """
    return _dlite.from_typename(typename)

def to_typename(type, size=-1):
    r"""
    to_typename(type, size=-1) -> char *
    Returns type name for given type number and size. If `size` is negative, only the name of `type` is returned.
    """
    return _dlite.to_typename(type, size)

def to_typenumber(dtypename):
    r"""
    to_typenumber(dtypename) -> int
    Returns DLite type number corresponding to `dtypename`.
    """
    return _dlite.to_typenumber(dtypename)

def get_alignment(type, size):
    r"""get_alignment(type, size) -> size_t"""
    return _dlite.get_alignment(type, size)
class StorageIterator(object):
    r"""
    Iterates over instances in storage `s`.  If `pattern` is given, only
    instances whos metadata URI matches `pattern` are returned.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    s = property(_dlite.StorageIterator_s_get, _dlite.StorageIterator_s_set, doc=r"""s""")
    state = property(_dlite.StorageIterator_state_get, _dlite.StorageIterator_state_set, doc=r"""state""")

    def __init__(self, s, pattern=None):
        r"""
        __init__(self, s, pattern=None) -> StorageIterator
        Iterates over instances in storage `s`.  If `pattern` is given, only
        instances whos metadata URI matches `pattern` are returned.

        """
        _dlite.StorageIterator_swiginit(self, _dlite.new_StorageIterator(s, pattern))
    __swig_destroy__ = _dlite.delete_StorageIterator

    def next(self):
        r"""
        next(self) -> Instance
        Returns next instance or None if exhausted.
        """
        return _dlite.StorageIterator_next(self)

    def __iter__(self):
        r"""__iter__(self) -> StorageIterator"""
        return _dlite.StorageIterator___iter__(self)


          # Override default __init__()
    def __init__(self, s, pattern=None):
        """Iterates over instances in storage `s`.

        If `pattern` is given, only instances whos metadata URI
        matches glob pattern `pattern` are returned.
        """
        _dlite.StorageIterator_swiginit(
            self, _dlite.new_StorageIterator(s, pattern))

    # Keep a reference to self, such that it is not garbage-collected
    # before end of iterations
        if not hasattr(_dlite, "_storage_iters"):
            _dlite._storage_iters = {}
        _dlite._storage_iters[id(self.state)] = self

    def __next__(self):
        inst = self.next()
        if not inst:
    # Delete reference to iterator object stored away in __init__()
            _dlite._storage_iters.pop(id(self.this), None)
            raise StopIteration()
        return instance_cast(inst)


# Register StorageIterator in _dlite:
_dlite.StorageIterator_swigregister(StorageIterator)
IDTranslateToUUID = _dlite.IDTranslateToUUID

IDRequireUUID = _dlite.IDRequireUUID

IDKeepID = _dlite.IDKeepID

class Storage(object):
    r"""
    Represents a data storage.

    Arguments
    ---------
    driver_or_url : string
        Name of driver used to connect to the storage or, if `location` is not
        given, the URL to the storage:

            driver://location?options

    location : string
        The location to the storage. For file storages, this is the file name.
    options : string
        Additional options passed to the driver as a list of semicolon-separated
        ``key=value`` pairs. See the documentation of the individual drivers to
        see which options they support.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    location = property(_dlite.Storage_location_get, doc=r"""location""")
    options = property(_dlite.Storage_options_get, doc=r"""options""")
    flags = property(_dlite.Storage_flags_get, doc=r"""flags""")
    idflag = property(_dlite.Storage_idflag_get, doc=r"""idflag""")

    def __init__(self, driver_or_url, location=None, options=None):
        r"""
        __init__(self, driver_or_url, location=None, options=None) -> Storage
        Represents a data storage.

        Arguments
        ---------
        driver_or_url : string
            Name of driver used to connect to the storage or, if `location` is not
            given, the URL to the storage:

                driver://location?options

        location : string
            The location to the storage. For file storages, this is the file name.
        options : string
            Additional options passed to the driver as a list of semicolon-separated
            ``key=value`` pairs. See the documentation of the individual drivers to
            see which options they support.

        """
        _dlite.Storage_swiginit(self, _dlite.new_Storage(driver_or_url, location, options))
    __swig_destroy__ = _dlite.delete_Storage

    def flush(self):
        r"""
        flush(self)
        Flush storage.
        """
        return _dlite.Storage_flush(self)

    def delete(self, id):
        r"""
        delete(self, id)
        Delete instance with given `id`.
        """
        return _dlite.Storage_delete(self, id)

    def get_driver(self):
        r"""
        get_driver(self) -> char const *
        Returns name of driver for this storage.
        """
        return _dlite.Storage_get_driver(self)

    def help(self):
        r"""
        help(self) -> char *
        Returns documentation for storage plugin.
        """
        return _dlite.Storage_help(self)

    def get_uuids(self, pattern=None):
        r"""
        get_uuids(self, pattern=None) -> char **
        Returns a list of UUIDs of all instances in the storage whos metadata matches `pattern`. If `pattern` is None, all UUIDs will be returned.
        """
        return _dlite.Storage_get_uuids(self, pattern)

    def _get_readable(self):
        r"""
        _get_readable(self) -> bool
        Returns whether the storage is readable.
        """
        return _dlite.Storage__get_readable(self)

    def _set_readable(self, readable):
        r"""
        _set_readable(self, readable)
        Set storage readability.
        """
        return _dlite.Storage__set_readable(self, readable)

    def _get_writable(self):
        r"""
        _get_writable(self) -> bool
        Returns whether the storage is writable.
        """
        return _dlite.Storage__get_writable(self)

    def _set_writable(self, writable):
        r"""
        _set_writable(self, writable)
        Set storage writability.
        """
        return _dlite.Storage__set_writable(self, writable)

    def _get_generic(self):
        r"""
        _get_generic(self) -> bool
        Returns whether the storage is generic.
        """
        return _dlite.Storage__get_generic(self)

    def _set_generic(self, generic):
        r"""
        _set_generic(self, generic)
        Set whether storage is generic
        """
        return _dlite.Storage__set_generic(self, generic)

          # Override default __init__()
    def __init__(self, driver_or_url, location=None, options=None):
        from dlite.options import make_query
        if options and not isinstance(options, str):
            options = make_query(options)
        loc = str(location) if location else None
        _dlite.Storage_swiginit(self, _dlite.new_Storage(
            driver_or_url=driver_or_url, location=loc, options=options))

    def __enter__(self):
        return self

    def __exit__(self, *exc):
        del self.this

    def __repr__(self):
        return (
            f"Storage('{self.driver}', location='{self.location}', "
            f"options='{self.options}')"
        )

    def __iter__(self):
        return StorageIterator(self)

    readable = property(
        fget=lambda self: self._get_readable(),
        doc="Whether the storage is readable.")

    writable = property(
        fget=lambda self: self._get_writable(),
        doc="Whether the storage is writable.")

    generic = property(
        fget=lambda self: self._get_generic(),
        doc="Whether the storage is generic, i.e. whether the storage can "
        "hold multiple instances, including both data and metadata."
    )

    @classmethod
    def load_plugins(cls):
        """Load all storage plugins."""
        _dlite._load_all_storage_plugins()

    @classmethod
    def unload_plugin(cls, name):
        """Unload storage plugin with this name."""
        _dlite._unload_storage_plugin(str(name))

    @classmethod
    def plugin_help(cls, name):
        """Return documentation of storage plogin with this name."""
        return _dlite._storage_plugin_help(name)

    def instances(self, pattern=None):
        """Returns an iterator over all instances in storage whos
        metadata URI matches `pattern`."""
        return StorageIterator(self, pattern=pattern)

    def load(self, id, metaid=None):
        """Loads instance `id` from this storage and return it.

        If `metaid` is provided, the returned instance will be
        mapped to an instance of this type (if appropriate mappings
        are available)."""
        return Instance.from_storage(self, id, metaid)

    def save(self, inst):
        """Stores instance `inst` in this storage."""
        inst.save_to_storage(self)

    driver = property(get_driver,
                      doc='Name of driver associated with this storage')



# Register Storage in _dlite:
_dlite.Storage_swigregister(Storage)
class StoragePluginIter(object):
    r"""
    Iterates over loaded storage plugins.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iter = property(_dlite.StoragePluginIter_iter_get, _dlite.StoragePluginIter_iter_set, doc=r"""iter""")

    def __init__(self):
        r"""
        __init__(self) -> StoragePluginIter
        Iterates over loaded storage plugins.

        """
        _dlite.StoragePluginIter_swiginit(self, _dlite.new_StoragePluginIter())
    __swig_destroy__ = _dlite.delete_StoragePluginIter

    def next(self):
        r"""
        next(self) -> char const *
        Returns name of next plugin or None if exhausted.

        """
        return _dlite.StoragePluginIter_next(self)

    def __iter__(self):
        r"""__iter__(self) -> StoragePluginIter"""
        return _dlite.StoragePluginIter___iter__(self)

          # Override default __init__()
    def __init__(self):
        """Iterator over loaded storage plugins."""
        _dlite.StoragePluginIter_swiginit(
            self, _dlite.new_StoragePluginIter())
    # Keep a reference to self, such that it is not garbage-collected
    # before end of iterations
        if not hasattr(_dlite, "_storage_iters"):
            _dlite._storage_iters = {}
        _dlite._storage_iters[id(self.iter)] = self

    def __next__(self):
        name = self.next()
        if not name:
    # Delete reference to iterator object stored away in __init__()
            _dlite._storage_iters.pop(id(self.this), None)
            raise StopIteration()
        return name


# Register StoragePluginIter in _dlite:
_dlite.StoragePluginIter_swigregister(StoragePluginIter)

def _load_all_storage_plugins():
    r"""_load_all_storage_plugins() -> int"""
    return _dlite._load_all_storage_plugins()

def _unload_storage_plugin(name):
    r"""_unload_storage_plugin(name) -> int"""
    return _dlite._unload_storage_plugin(name)

def _storage_plugin_help(name):
    r"""_storage_plugin_help(name) -> char *"""
    return _dlite._storage_plugin_help(name)
class Dimension(object):
    r"""
    A dimension represented by its name and description.
    Metadata can define a set of common dimensions for its properties that
    are referred to by the shape of each property.

    Arguments:
        name: Dimension name.
        description: Dimension description.

    Attributes:
        name: Dimension name.
        description: Dimension description.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_dlite.Dimension_name_get, _dlite.Dimension_name_set, doc=r"""name""")
    description = property(_dlite.Dimension_description_get, _dlite.Dimension_description_set, doc=r"""description""")

    def __init__(self, name, description=None):
        r"""
        __init__(self, name, description=None) -> Dimension
        A dimension represented by its name and description.
        Metadata can define a set of common dimensions for its properties that
        are referred to by the shape of each property.

        Arguments:
            name: Dimension name.
            description: Dimension description.

        Attributes:
            name: Dimension name.
            description: Dimension description.


        """
        _dlite.Dimension_swiginit(self, _dlite.new_Dimension(name, description))
    __swig_destroy__ = _dlite.delete_Dimension

    def __repr__(self):
        return 'Dimension(name=%r, description=%r)' % (
            self.name, self.description)

    def __eq__(self, other):
        """Returns true if `other` equals self."""
        return self.asdict() == other.asdict()

    def asdict(self):
        """Returns a dict representation of self."""
        d = {}
        d['name'] = self.name
        if self.description:
            d['description'] = self.description
        return d

    def asstrings(self):
        """Returns a representation of self as a tuple of strings."""
        return (self.name,
                '' if self.description is None else self.description)


# Register Dimension in _dlite:
_dlite.Dimension_swigregister(Dimension)
class Property(object):
    r"""
    Represents a property.
    All metadata must have one or more properties that define the instances
    of the metadata.

    Arguments:
        name: Property name.
        type: Property type. Ex: 'int', 'blob14', 'float64', 'ref'...
        ref: Optional. URL to metadata. Only needed for `type='ref'`.
        shape: Optional. Specifies the dimensionality of property.  If `shape`
            is not given, the property is a scalar (dimensionality zero).
            It should be a sequence of dimension names.
        unit: Optional. The unit for properties with a unit. The unit should
             be a valid unit label defined by EMMO or a custom ontology.
        description: Optional: A human description of the property.

    Attributes:
        name: Property name.
        size: Number of bytes needed to represent a single instance of `type`
            in memory.
        ref: Value of the `ref` argument.
        ndims: Number of dimensions of the property. A scalar has `ndims=0`.
        unit: The unit of the property.
        description: Property description.
        dims: Deprecated alias for shape.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_dlite.Property_name_get, _dlite.Property_name_set, doc=r"""name""")
    size = property(_dlite.Property_size_get, _dlite.Property_size_set, doc=r"""size""")
    ref = property(_dlite.Property_ref_get, _dlite.Property_ref_set, doc=r"""ref""")
    ndims = property(_dlite.Property_ndims_get, doc=r"""ndims""")
    unit = property(_dlite.Property_unit_get, _dlite.Property_unit_set, doc=r"""unit""")
    description = property(_dlite.Property_description_get, _dlite.Property_description_set, doc=r"""description""")

    def __init__(self, name, type, ref=None, shape=None, unit=None, description=None):
        r"""
        __init__(self, name, type, ref=None, shape=None, unit=None, description=None) -> Property
        Represents a property.
        All metadata must have one or more properties that define the instances
        of the metadata.

        Arguments:
            name: Property name.
            type: Property type. Ex: 'int', 'blob14', 'float64', 'ref'...
            ref: Optional. URL to metadata. Only needed for `type='ref'`.
            shape: Optional. Specifies the dimensionality of property.  If `shape`
                is not given, the property is a scalar (dimensionality zero).
                It should be a sequence of dimension names.
            unit: Optional. The unit for properties with a unit. The unit should
                 be a valid unit label defined by EMMO or a custom ontology.
            description: Optional: A human description of the property.

        Attributes:
            name: Property name.
            size: Number of bytes needed to represent a single instance of `type`
                in memory.
            ref: Value of the `ref` argument.
            ndims: Number of dimensions of the property. A scalar has `ndims=0`.
            unit: The unit of the property.
            description: Property description.
            dims: Deprecated alias for shape.


        """
        _dlite.Property_swiginit(self, _dlite.new_Property(name, type, ref, shape, unit, description))
    __swig_destroy__ = _dlite.delete_Property

    def get_type(self):
        r"""get_type(self) -> char *"""
        return _dlite.Property_get_type(self)

    def get_dtype(self):
        r"""get_dtype(self) -> int"""
        return _dlite.Property_get_dtype(self)

    def get_shape(self):
        r"""get_shape(self) -> obj_t *"""
        return _dlite.Property_get_shape(self)

    def set_shape(self, arr):
        r"""set_shape(self, arr)"""
        return _dlite.Property_set_shape(self, arr)

    def __repr__(self):
        ref = ', ref=%r' % self.ref if self.ref else ''
        shape = ', shape=%r' % self.shape.tolist() if self.ndims else ''
        unit = ', unit=%r' % self.unit if self.unit else ''
        descr = ', description=%r' %self.description if self.description else ''
        return 'Property(%r, type=%r%s%s%s%s)' % (
            self.name, self.type, ref, shape, unit, descr)

    def __eq__(self, other):
        """Returns true if `other` equals self."""
        return self.asdict() == other.asdict()

    def asdict(self, soft7=True, exclude_name=False):
        """Returns a dict representation of self.

        Args:
            soft7: Whether to use new SOFT7 format.
            exclude_name: Whether to exclude "name" from the returned dict.
        """
        d = {}
        if not exclude_name:
            d['name'] = self.name
        d['type'] = self.get_type()
        if self.ref:
            d['ref'] = self.ref
        if self.ndims:
            d['shape' if soft7 else 'dims'] = self.shape.tolist()
        if self.unit:
            d['unit'] = self.unit
        if self.description:
            d['description'] = self.description
        return d

    def asstrings(self):
        """Returns a representation of self as a tuple of strings."""
        return (self.name, self.type, ','.join(str(d) for d in self.shape),
                '' if self.unit is None else self.unit,
                '' if self.description is None else self.description)

    @property
    def type(self):
        """Type name."""
        return self.get_type()

    @property
    def dtype(self):
        """Type number."""
        return self.get_dtype()

    @property
    def shape(self):
        """Array of dimension indices."""
        return self.get_shape()

    @shape.setter
    def shape(self, value):
        return self.set_shape(value)

    # Too be removed...
    def _get_dims_depr(self):
        warnings.warn('Property `dims` is deprecated, use `shape` instead.',
                      DeprecationWarning, stacklevel=2)
        return self.get_shape()
    dims = property(_get_dims_depr, doc='Array of dimension indices. '
                    'Property `dims` is deprecated, use `shape` instead.')



# Register Property in _dlite:
_dlite.Property_swigregister(Property)
class Relation(object):
    r"""
    A DLite relation representing an RDF triple.

    Arguments:
        s: Subject IRI.
        p: Predicate IRI.
        o: Either an IRI for non-literal objects or the literal value for
            literal objects.
        d: The datatype IRI for literal objects.  It may have three forms:

            - None: object is an IRI (rdfs:Resource).
            - Starts with '@': object is a language-tagged plain literal
              (rdf:langString). The language identifier follows the '@'-sign.
              Ex: '@en' for english.
            - Otherwise: object is a literal with datatype `d`. Ex: 'xsd:int'.

    As an internal implementation detail, relations also have an `id` field.
    It may change in the future, so please don't rely on it.

    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    s = property(_dlite.Relation_s_get, _dlite.Relation_s_set, doc=r"""s""")
    p = property(_dlite.Relation_p_get, _dlite.Relation_p_set, doc=r"""p""")
    o = property(_dlite.Relation_o_get, _dlite.Relation_o_set, doc=r"""o""")
    d = property(_dlite.Relation_d_get, _dlite.Relation_d_set, doc=r"""d""")
    id = property(_dlite.Relation_id_get, _dlite.Relation_id_set, doc=r"""id""")

    def __init__(self, s, p, o, d=None, id=None):
        r"""
        __init__(self, s, p, o, d=None, id=None) -> Relation
        A DLite relation representing an RDF triple.

        Arguments:
            s: Subject IRI.
            p: Predicate IRI.
            o: Either an IRI for non-literal objects or the literal value for
                literal objects.
            d: The datatype IRI for literal objects.  It may have three forms:

                - None: object is an IRI (rdfs:Resource).
                - Starts with '@': object is a language-tagged plain literal
                  (rdf:langString). The language identifier follows the '@'-sign.
                  Ex: '@en' for english.
                - Otherwise: object is a literal with datatype `d`. Ex: 'xsd:int'.

        As an internal implementation detail, relations also have an `id` field.
        It may change in the future, so please don't rely on it.

        """
        _dlite.Relation_swiginit(self, _dlite.new_Relation(s, p, o, d, id))
    __swig_destroy__ = _dlite.delete_Relation

    def __repr__(self):
        args = [f"s='{self.s}', p='{self.p}', o='{self.o}'"]
        if self.d:
            args.append(f"d='{self.d}'")
        if self.id:
            args.append(f"id='{self.id}'")
        return f"Relation({', '.join(args)})"

    def __eq__(self, other):
        if isinstance(other, Relation):
            return (self.s == other.s and self.p == other.p and
                    self.o == other.o and self.d == other.d)
        return NotImplemented

    def copy(self):
        """Returns a copy of self."""
        return Relation(s=self.s, p=self.p, o=self.o, d=self.d, id=self.id)

    def aspreferred(self):
        """Returns preferred Python representation."""
        return self.asstrings()

    def asdict(self):
        """Returns a dict representation of self."""
        d = dict(s=self.s, p=self.p, o=self.o)
        if self.id:
            d[id] = self.id
        return d

    def asstrings(self):
        """Returns a representation of self as a tuple of strings."""
        return (self.s, self.p, self.o)


# Register Relation in _dlite:
_dlite.Relation_swigregister(Relation)
class Instance(object):
    r"""
    Represents a DLite instance.

    This is the most central class in DLite.  It has a complex `__init__()`
    method and is intended to be instantiated with one of the following class
    methods:

    - from_metaid(cls, metaid, dimensions, id=None)
    - from_url(cls, url, metaid=None)
    - from_storage(cls, storage, id=None, metaid=None)
    - from_location(cls, driver, location, options=None, id=None)
    - from_json(cls, jsoninput, id=None, metaid=None)
    - from_bson(cls, bsoninput)
    - from_dict(cls, d, id=None, single=None, check_storages=True)
    - create_metadata(cls, uri, dimensions, properties, description)

    For details, see the documentation of the individual class methods.

    Attributes:
        uuid: The UUID of the instance.
        uri: The URI of the instance.


    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    uuid = property(_dlite.Instance_uuid_get, doc=r"""uuid""")
    _flags = property(_dlite.Instance__flags_get, doc=r"""_flags""")
    uri = property(_dlite.Instance_uri_get, doc=r"""uri""")
    _refcount = property(_dlite.Instance__refcount_get, doc=r"""_refcount""")

    def __init__(self, metaid=None, dims=None, id=None, url=None, storage=None, driver=None, location=None, options=None, uri=None, jsoninput=None, bsoninput=None, dimensions=None, properties=None, description=None):
        r"""
        __init__(self, metaid=None, dims=None, id=None, url=None, storage=None, driver=None, location=None, options=None, uri=None, jsoninput=None, bsoninput=None, dimensions=None, properties=None, description=None) -> Instance
        Represents a DLite instance.

        This is the most central class in DLite.  It has a complex `__init__()`
        method and is intended to be instantiated with one of the following class
        methods:

        - from_metaid(cls, metaid, dimensions, id=None)
        - from_url(cls, url, metaid=None)
        - from_storage(cls, storage, id=None, metaid=None)
        - from_location(cls, driver, location, options=None, id=None)
        - from_json(cls, jsoninput, id=None, metaid=None)
        - from_bson(cls, bsoninput)
        - from_dict(cls, d, id=None, single=None, check_storages=True)
        - create_metadata(cls, uri, dimensions, properties, description)

        For details, see the documentation of the individual class methods.

        Attributes:
            uuid: The UUID of the instance.
            uri: The URI of the instance.


        """
        _dlite.Instance_swiginit(self, _dlite.new_Instance(metaid, dims, id, url, storage, driver, location, options, uri, jsoninput, bsoninput, dimensions, properties, description))
    __swig_destroy__ = _dlite.delete_Instance

    def _get_meta(self):
        r"""
        _get_meta(self) -> Instance
        Returns reference to metadata.
        """
        return _dlite.Instance__get_meta(self)

    def _get_parent_uuid(self):
        r"""
        _get_parent_uuid(self) -> char const *
        Returns reference to parent uuid.
        """
        return _dlite.Instance__get_parent_uuid(self)

    def _get_parent_hash(self):
        r"""
        _get_parent_hash(self) -> char *
        Returns reference to parent hash.
        """
        return _dlite.Instance__get_parent_hash(self)

    def save(self, driver_or_url=None, location=None, options=None, storage=None):
        r"""
        save(self, driver_or_url=None, location=None, options=None, storage=None)
        Saves this instance to url or storage.

        Call signatures:
            save(url)
            save(driver, location, options=None)
            save(storage=storage)

        """
        return _dlite.Instance_save(self, driver_or_url, location, options, storage)

    def save_to_url(self, url):
        r"""save_to_url(self, url)"""
        return _dlite.Instance_save_to_url(self, url)

    def save_to_storage(self, storage):
        r"""save_to_storage(self, storage)"""
        return _dlite.Instance_save_to_storage(self, storage)

    def to_bytes(self, driver, options=None):
        r"""
        to_bytes(self, driver, options=None)
        Save instance to bytes using given storage driver.
        """
        return _dlite.Instance_to_bytes(self, driver, options)

    def get_hash(self):
        r"""
        get_hash(self) -> char *
        Returns a hash of the instance.
        """
        return _dlite.Instance_get_hash(self)

    def verify_hash(self, *args, **kwargs):
        r"""
        verify_hash(self, hash=None, recursive=false)
        Verify the hash of the instance.

        If `hash` is not None, this function verifies that the hash of
        `inst` corresponds to the memory pointed to by `hash`.  The size
        of the memory should be `DLITE_HASH_SIZE` bytes.

        If `hash` is None and `inst` has a parent, this function will
        instead verify that the parent hash stored in `inst` corresponds
        to the value of the parent.

        If `recursive` is true, all ancestors of `inst` are also
        included in the verification.

        Raises a DLiteVerifyError exception if the hash is not valid.
        """
        return _dlite.Instance_verify_hash(self, *args, **kwargs)

    def _copy(self, newid=None):
        r"""
        _copy(self, newid=None) -> Instance
        Returns a copy of the instance.  If `newid` is given, it will be
        the id of the new instance, otherwise it will be given a
        random UUID.
        """
        return _dlite.Instance__copy(self, newid)

    def snapshot(self):
        r"""
        snapshot(self)
        Make a snapshot of the current state of the instance.  It can
        be retrieved with `get_snapshot()`.

        The instance will be a transaction whose parent is the snapshot.
        If `inst` already has a parent, that will now be the parent of
        the snapshot.

        The reason that `inst` must be mutable, is that its hash will
        change due to a change in its parent.

        The snapshot will be assigned an URI of the form
        "snapshot-XXXXXXXXXXXX" (or inst->uri#snapshot-XXXXXXXXXXXX
        if inst->uri is not NULL) where each X is replaces with a
        random character.
        """
        return _dlite.Instance_snapshot(self)

    def get_snapshot(self, n=1):
        r"""
        get_snapshot(self, n=1) -> Instance
        Returns shapshot number `n` of the current instance, where `n`
        counts backward.  Hence, `n=0` returns the current instance,
        `n=1` returns its parent, etc...

        This function may pull snapshots back into memory. Use
        `dlite_instance_pull()` if you know the storage where the snapshots are stored.
        """
        return _dlite.Instance_get_snapshot(self, n)

    def pull_snapshot(self, storage, n):
        r"""
        pull_snapshot(self, storage, n) -> Instance
        Like `dlite_instance_get_snapshot()`, except that possible stored
        snapshots are pulled from a specified storage to memory.

        Returns shapshot number `n` of the current instance, where `n`
        counts backward.  Hence, `n=0` returns the current instance,
        `n=1` returns its parent, etc... 
        """
        return _dlite.Instance_pull_snapshot(self, storage, n)

    def push_snapshot(self, storage, n):
        r"""
        push_snapshot(self, storage, n)
        Push all ancestors of snapshot `n` from memory to storage,
        where `n=0` corresponds to `inst`, `n=1` to the parent of
        `inst`, etc...

        No snapshot is pulled back from storage, so if the snapshots are
        already in storage, this function has no effect.

        This function starts pushing closest to the root to ensure
        that the transaction is in a consistent state at all times.
        """
        return _dlite.Instance_push_snapshot(self, storage, n)

    def set_parent(self, parent):
        r"""
        set_parent(self, parent)
        Turn instance `inst` into a transaction node with parent
        `parent`.  This requires that `inst` is mutable, and `parent`
        is immutable.  If `inst` already has a parent, it will be
        replaced.

        Use `dlite_instance_freeze()` and `dlite_instance_is_frozen()` to
        make and check that an instance is immutable, respectively.
        """
        return _dlite.Instance_set_parent(self, parent)

    def freeze(self):
        r"""
        freeze(self)
        Mark the instance as immutable.  This can never be reverted.
        """
        return _dlite.Instance_freeze(self)

    def is_frozen(self):
        r"""
        is_frozen(self) -> bool
        Returns whether the instance is frozen and immutable.
        """
        return _dlite.Instance_is_frozen(self)

    def verify_transaction(self):
        r"""
        verify_transaction(self) -> bool
        Verifies a transaction.
        """
        return _dlite.Instance_verify_transaction(self)

    def get_dimensions(self):
        r"""
        get_dimensions(self) -> obj_t *
        Returns array with dimension sizes.
        """
        return _dlite.Instance_get_dimensions(self)

    def get_dimension_size(self, name):
        r"""
        get_dimension_size(self, name) -> int
        Returns the size of dimension with given name or index.
        """
        return _dlite.Instance_get_dimension_size(self, name)

    def get_dimension_size_by_index(self, i):
        r"""get_dimension_size_by_index(self, i) -> int"""
        return _dlite.Instance_get_dimension_size_by_index(self, i)

    def get_property(self, name):
        r"""
        get_property(self, name) -> obj_t *
        Returns property with given name.
        """
        return _dlite.Instance_get_property(self, name)

    def get_property_by_index(self, i):
        r"""
        get_property_by_index(self, i) -> obj_t *
        Returns property with given index.
        """
        return _dlite.Instance_get_property_by_index(self, i)

    def set_property(self, name, obj):
        r"""
        set_property(self, name, obj)
        Sets property with given name to `obj`.
        """
        return _dlite.Instance_set_property(self, name, obj)

    def set_property_by_index(self, i, obj):
        r"""
        set_property_by_index(self, i, obj)
        Sets property with given index to `obj`.
        """
        return _dlite.Instance_set_property_by_index(self, i, obj)

    def get_property_as_string(self, name, width=0, prec=-2, flags=0):
        r"""
        get_property_as_string(self, name, width=0, prec=-2, flags=0) -> char *
        Return property `name` as a string.

        Arguments:
            width: Minimum field width. Unused if 0, auto if -1.
            prec: Precision. Auto if -1, unused if -2.
            flags: Or'ed sum of formatting flags:

                - `0`: Default (json).
                - `1`: Raw unquoted output.
                - `2`: Quoted output.

        Returns:
            Property as a string.


        """
        return _dlite.Instance_get_property_as_string(self, name, width, prec, flags)

    def set_property_from_string(self, name, s, flags=0):
        r"""
        set_property_from_string(self, name, s, flags=0)
        Set property `name` to the value of string `s`. 

        `flags` is the or'ed sum of:
          0  default (json)
          1  raw unquoted input
          2  quoted input
          4  strip initial and final spaces
        """
        return _dlite.Instance_set_property_from_string(self, name, s, flags)

    def has_property(self, name):
        r"""
        has_property(self, name) -> bool
        Returns true if this instance has a property with given name.
        """
        return _dlite.Instance_has_property(self, name)

    def has_property_by_index(self, i):
        r"""
        has_property_by_index(self, i) -> bool
        Returns true if this instance has a property with given index.
        """
        return _dlite.Instance_has_property_by_index(self, i)

    def has_dimension(self, name):
        r"""
        has_dimension(self, name) -> bool
        Returns true if this instance has a dimension with given name.
        """
        return _dlite.Instance_has_dimension(self, name)

    def has_dimension_by_index(self, i):
        r"""
        has_dimension_by_index(self, i) -> bool
        Returns true if this instance has a dimension with given index.
        """
        return _dlite.Instance_has_dimension_by_index(self, i)

    def _is_data(self):
        r"""
        _is_data(self) -> bool
        Returns true if this is a data instance.
        """
        return _dlite.Instance__is_data(self)

    def _is_meta(self):
        r"""
        _is_meta(self) -> bool
        Returns true if this is metadata.
        """
        return _dlite.Instance__is_meta(self)

    def _is_metameta(self):
        r"""
        _is_metameta(self) -> bool
        Returns true if this is meta-metadata.
        """
        return _dlite.Instance__is_metameta(self)

    def _incref(self):
        r"""
        _incref(self) -> int
        Increase reference count and return the new refcount.
        """
        return _dlite.Instance__incref(self)

    def _decref(self):
        r"""
        _decref(self) -> int
        Decrease reference count and return the new refcount.
        """
        return _dlite.Instance__decref(self)

    def _asjson(self, *args, **kwargs):
        r"""
        _asjson(self, indent=0, single=false, urikey=false, with_uuid=false, with_meta=false, with_arrays=false, no_parent=false, compact_rel=false) -> char *
        Returns a JSON representation of self.

        Arguments:
            single: Write instances with single-entity format.
            urikey: Use uri (if it exists) as json key in multi-entity format.
            with_uuid: Include uuid in output.
            with_meta: Always include 'meta' (even for metadata).
            with_arrays: Write metadata dimension and properties as json arrays (old format).
            no_parent: Do not write transaction parent info.
            compact_rel: Write relations with no newlines.

        """
        return _dlite.Instance__asjson(self, *args, **kwargs)

    def asbson(self):
        r"""
        asbson(self)
        Returns a BSON representation of self.
        """
        return _dlite.Instance_asbson(self)

    def get_uri(self):
        r"""
        get_uri(self) -> char *
        Returns instance uri.
        """
        return _dlite.Instance_get_uri(self)

    def __len__(self):
        r"""__len__(self) -> int"""
        return _dlite.Instance___len__(self)

    def __repr__(self):
        r"""__repr__(self) -> char *"""
        return _dlite.Instance___repr__(self)

    def _c_ptr(self):
        r"""_c_ptr(self) -> PyObject *"""
        return _dlite.Instance__c_ptr(self)


        # Override default generated __init__() method
    def __init__(self, *args, **kwargs):

    # Some versions of SWIG may generate a __new__() method that
    # is not a standard wrapper function and will therefore bypass
    # the standard error checking.  Check manually that we are not
    # in an error state.
        if hasattr(self, "__new__"):
            _dlite.errcheck()

        if self is None:
            raise _dlite.DLitePythonError(f"cannot create dlite.Instance")

        obj = _dlite.new_Instance(*args, **kwargs)

    # The swig-internal Instance_swiginit() function is not a standard
    # wrapper function and therefore bypass the standard error checking.
    # Therefore, check manually that it doesn't produce an error.
        _dlite.Instance_swiginit(self, obj)
        _dlite.errcheck()

        if not hasattr(self, 'this') or not getattr(self, 'this'):
            raise _dlite.DLitePythonError(f"cannot initiate dlite.Instance")
        instance_cast(self)

    def get_meta(self):
        """Returns reference to metadata."""
        meta = self._get_meta()
        assert meta.is_meta
        meta.__class__ = Metadata
        return meta

    def get_property_descr(self, name):
        """Return a Property object for property `name`."""
        for p in self.meta['properties']:
            if p.name == name:
                return p
        raise ValueError(
            f'No property "{name}" in '
            f'"{self.uri if self.uri else self.meta.uri}"'
        )

    @property
    def meta(self):
        """Reference to the metadata of this instance."""
        return self.get_meta()

    @property
    def dimensions(self):
        """Dictionary with dimensions name-value pairs."""
        return dict(
            (d.name, int(v))
            for d, v in zip(self.meta['dimensions'], self.get_dimensions())
        )

    @property
    def properties(self):
        """Dictionary with property name-value pairs."""
        return {p.name: self[p.name] for p in self.meta['properties']}

    @property
    def is_data(self):
        """Whether this is a data instance."""
        return self._is_data()

    @property
    def is_meta(self):
        """Whether this is a metadata instance."""
        return self._is_meta()

    @property
    def is_metameta(self):
        """Whether this is a meta-metadata instance."""
        return self._is_metameta()

    @classmethod
    def from_metaid(cls, metaid, dimensions, id=None):
        """Create a new instance of metadata `metaid`.  `dimensions` must be a
        sequence with the size of each dimension.  All values initialized
        to zero.  If `id` is None, a random UUID is generated.  Otherwise
        the UUID is derived from `id`.
        """
        if isinstance(dimensions, dict):
            meta = get_instance(metaid)
            dimensions = [dimensions[dim.name]
                          for dim in meta.properties['dimensions']]
    # Allow metaid to be an Instance
        if isinstance(metaid, Instance):
            metaid = metaid.uri
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            metaid=metaid, dims=dimensions, id=id,
            dimensions=(), properties=()  # arrays must not be None
        )
        return instance_cast(inst)

    @classmethod
    def load(
        cls, protocol, driver, location, options=None, id=None, metaid=None
    ):
        """Load the instance from storage:

        Arguments:
            protocol: Name of protocol plugin used for data transfer.
            driver: Name of storage plugin for data parsing.
            location: Location of resource.  Typically a URL or file path.
            options: Options passed to the protocol and driver plugins.
            id: ID of instance to load.
            metaid: If given, the instance is tried mapped to this metadata
                before it is returned.

        Return:
            Instance loaded from storage.
        """
        from dlite.protocol import Protocol

        with Protocol(protocol, location=location, options=options) as pr:
            buffer = pr.load(uuid=id)
        try:
            return cls.from_bytes(
                driver, buffer, id=id, options=options, metaid=metaid
            )
        except _dlite.DLiteUnsupportedError:
            pass
        tmpfile = None
        try:
            with tempfile.NamedTemporaryFile(delete=False) as f:
                tmpfile = f.name
                f.write(buffer)
            inst = cls.from_location(
                driver, tmpfile, options=options, id=id, metaid=metaid
            )
        finally:
            Path(tmpfile).unlink()
        return instance_cast(inst)

    @classmethod
    def from_url(cls, url, metaid=None):
        """Load the instance from `url`.  The URL should be of one of the
        the following forms:

            driver://location?options#id
            protocol+driver://location?options#id
            protocol://location?driver=<driver>;options#id

        where `protocol`, `driver`, `location`, `options` and `id` are
        documented in the load() method.

        If `metaid` is provided, the instance is tried mapped to this
        metadata before it is returned.
        """
        from dlite.protocol import Protocol
        from dlite.options import parse_query

        p = urlparse(url)
        if "driver=" in p.query or "+" in p.scheme:
            if "driver=" in p.query:
                protocol = p.scheme
                driver = parse_query(p.query)["driver"]
            elif "+" in p.scheme:
                protocol, driver = p.scheme.split("+", 1)
            elif Path(p.path).suffix:
                protocol = p.scheme
                driver = Path(p.path).suffix[1:]
            else:
                raise _dlite.DLiteParseError(
                    f"cannot infer driver from URL: {url}"
                )
            location = f"{protocol}://{p.netloc}{p.path}"
            inst = cls.load(
                protocol, driver, location, options=p.query, id=p.fragment,
                metaid=metaid
            )
        else:
            errclr()  # Clear internal error before calling Instance()
            inst = Instance(
                url=url, metaid=metaid,
                dims=(), dimensions=(), properties=()  # arrays
            )
        return instance_cast(inst)

    @classmethod
    def from_storage(cls, storage, id=None, metaid=None):
        """Load the instance from `storage`.  `id` is the id of the instance
        in the storage (not required if the storage only contains more one
        instance).
        If `metaid` is provided, the instance is tried mapped to this
        metadata before it is returned.
        """
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            storage=storage, id=id, metaid=metaid,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def from_location(
        cls, driver, location, options=None, id=None, metaid=None
    ):
        """Load the instance from storage specified by `driver`, `location`
        and `options`.  `id` is the id of the instance in the storage (not
        required if the storage only contains more one instance).
        """
        from dlite.options import make_query
        if options and not isinstance(options, str):
            options = make_query(options)
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            driver=driver, location=str(location), options=options, id=id,
            metaid=metaid,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def from_json(cls, jsoninput, id=None, metaid=None):
        """Load the instance from json input."""
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            jsoninput=jsoninput, id=id, metaid=metaid,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def from_bson(cls, bsoninput):
        """Load the instance from bson input."""
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            bsoninput=bsoninput,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def from_dict(cls, d, id=None, single=None, check_storages=True):
        """Load the instance from dictionary.

        Arguments:
            d: Dict to parse.  It should be of the same form as returned
                by the Instance.asdict() method.
            id: Identity of the returned instance.

                If `d` is in single-entity form with no explicit 'uuid' or
                'uri', its identity will be assigned by `id`.  Otherwise
                `id` must be consistent with the 'uuid' and/or 'uri'
                fields of `d`.

                If `d` is in multi-entity form, `id` is used to select the
                instance to return.
            single: A boolean, None or "auto".  Determines whether to
                assume that the dict is in single-entity form.
                If `single` is None or "auto", the form is inferred.
            check_storages: Whether to check if the instance already exists
                in storages specified in `dlite.storage_path`.

        Returns:
            New instance.
        """
        from dlite.utils import instance_from_dict
        inst = instance_from_dict(
            d, id=id, single=single, check_storages=check_storages,
        )
        return instance_cast(inst)

    @classmethod
    def from_bytes(cls, driver, buffer, options=None, id=None, metaid=None):
        """Load the instance with ID `id` from bytes `buffer` using the
        given storage driver.
        """
        from dlite.options import make_query
        if options and not isinstance(options, str):
            options = make_query(options)
        inst = _from_bytes(
            driver, buffer, id=id, options=options, metaid=metaid
        )
        return instance_cast(inst)

    @classmethod
    def create_metadata(cls, uri, dimensions, properties, description):
        """Create a new metadata entity (instance of entity schema) casted
        to an instance.
        """
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            uri=uri, dimensions=dimensions, properties=properties,
            description=description,
            dims=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def create_from_metaid(cls, metaid, dimensions, id=None):
        """Create a new instance of metadata `metaid`.  `dimensions` must be a
        sequence with the size of each dimension.  All values initialized
        to zero.  If `id` is None, a random UUID is generated.  Otherwise
        the UUID is derived from `id`.
        """
        warnings.warn(
            "create_from_metaid() is deprecated, use from_metaid() instead.",
            DeprecationWarning, stacklevel=2)
        if isinstance(dimensions, dict):
            meta = get_instance(metaid)
            dimensions = [dimensions[dim.name]
                          for dim in meta.properties['dimensions']]
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            metaid=metaid, dims=dimensions, id=id,
            dimensions=(), properties=()  # arrays must not be None
        )
        return instance_cast(inst)

    @classmethod
    def create_from_url(cls, url, metaid=None):
        """Load the instance from `url`.  The URL should be of the form
        ``driver://location?options#id``.
        If `metaid` is provided, the instance is tried mapped to this
        metadata before it is returned.
        """
        warnings.warn(
            "create_from_url() is deprecated, use from_url() instead.",
            DeprecationWarning, stacklevel=2)
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            url=url, metaid=metaid,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def create_from_storage(cls, storage, id=None, metaid=None):
        """Load the instance from `storage`.  `id` is the id of the instance
        in the storage (not required if the storage only contains more one
        instance).
        If `metaid` is provided, the instance is tried mapped to this
        metadata before it is returned.
        """
        warnings.warn(
            "create_from_storage() is deprecated, use from_storage() instead.",
            DeprecationWarning, stacklevel=2)
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            storage=storage, id=id, metaid=metaid,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def create_from_location(cls, driver, location, options=None, id=None):
        """Load the instance from storage specified by `driver`, `location`
        and `options`.  `id` is the id of the instance in the storage (not
        required if the storage only contains more one instance).
        """
        warnings.warn(
            "create_from_location() is deprecated, use from_location() "
            "instead.", DeprecationWarning, stacklevel=2)
        from dlite.options import make_query
        if options and not isinstance(options, str):
            options = make_query(options)
        errclr()  # Clear internal error before calling Instance()
        inst = Instance(
            driver=driver, location=str(location), options=options, id=id,
            dims=(), dimensions=(), properties=()  # arrays
        )
        return instance_cast(inst)

    @classmethod
    def get_uuids(cls, driver, location, options=None, pattern=None):
        """Returns a iterator over matching UUIDs in storage.

          Arguments:
              driver: Name of storage plugin for data parsing.
              location: Location of resource.  Typically a URL or file path.
              options: Options passed to the protocol and driver plugins.
              pattern: A glob pattern matching metadata UUIDs.  If given,
                  only matching UUIDs will be returned.

          Return:
              Iterator over all matching UUIDs in storage.
        """
        with Storage(driver, location, options=options) as s:
             return s.get_uuids(pattern=pattern)

    def save(self, *dest, location=None, options=None):
        """Saves this instance to url or storage.

        Call signatures:
          - save(storage)
          - save(url)
          - save(driver, location, options=None)
          - save(protocol, driver, location, options=None)

        Arguments:
            storage: A dlite.Storage instance to store the instance to.
            url: A URL for the storate to store to.
            protocol: Name of protocol plugin to use for transferring the
                serialised data to `location`.
            driver: Name of storage plugin for serialisation.
            location: A string describing where to save the instance.
            options: Options to the protocol and driver plugins. Should be
                a semicolon- or ampersand-separated string of key=value pairs.

        Notes:
            The URL may be given in any of the following forms:

                driver://location?options#id
                protocol+driver://location?options#id
                protocol://location?driver=<driver>;options#id

        """
        from dlite.protocol import Protocol
        from dlite.options import make_query, parse_query

        if options and not isinstance(options, str):
            options = make_query(options)

    # Assign arguments from call signature.
    # Far too complicated, but ensures backward compatibility.
        storage = url = protocol = driver = None
        if isinstance(dest, Storage):
            storage = dest
        elif isinstance(dest, str):
            if location:
                driver = dest
            else:
                url = dest
        elif isinstance(dest, Sequence):
            if len(dest) == 1:
                if isinstance(dest[0], Storage):
                    storage, = dest
                elif location:
                    driver, = dest
                else:
                    url, = dest
            if len(dest) == 2:
                if location:
                    protocol, driver = dest
                else:
                    driver, location = dest
            elif len(dest) == 3:
                if not location and options is None:
                     arg1, arg2, arg3 = dest
                     if arg2 is None and arg3 is None:
                         url = arg1
                     else:
                         driver, location, options = dest
                elif not location:
                     protocol, driver, location = dest
                else:
                    raise _dlite.DLiteValueError(
                        "dlite.Instance.save() got `location` both as "
                        f"positional ({dest[2]}) and keyword ({location}) "
                        "argument"
                    )
            elif len(dest) == 4:
                if location or options:
                    raise _dlite.DLiteValueError(
                        "dlite.Instance.save() got `location` and/or "
                        "`options` both as positional and keyword arguments"
                    )
                protocol, driver, location, options = dest

    # Call lower-level save methods
        if protocol:
            try:
                buf = self.to_bytes(driver, options=options)
            except (_dlite.DLiteAttributeError, _dlite.DLiteUnsupportedError):
                buf = None
            if not buf:
                try:
                    with tempfile.NamedTemporaryFile(delete=False) as f:
                        tmpfile = f.name
                    self.save(driver, location=tmpfile, options=options)
                    with open(tmpfile, "rb") as f:
                        buf = f.read()
                finally:
                    Path(tmpfile).unlink()
            with Protocol(protocol, location=location, options=options) as pr:
                pr.save(buf)
        elif driver:
            with Storage(driver, str(location), options) as storage:
                storage.save(self)
        elif url:
            protocol = driver = None
            scheme, loc, options, _ = split_url(url)
            if "+" in scheme:
                protocol, driver = scheme.split("+", 1)
            elif scheme in Protocol.loaded_plugins():
                protocol = scheme
            else:
                driver = scheme
            if "driver=" in options:
                driver = parse_query(options)["driver"]
            elif not driver:
                suffix = Path(loc).suffix
                if suffix:
                    driver = suffix[1:]
                else:
                    raise _dlite.DLiteParseError(
                        f"cannot infer driver from URL: {url}"
                    )
            if protocol:
                self.save(protocol, driver, location=loc, options=options)
            else:
                opts = f"?{options}" if options else ""
                self.save_to_url(f"{driver}://{loc}{opts}")
        elif storage:
            self.save_to_storage(storage=storage)
        else:
            raise _dlite.DLiteTypeError(
                'Arguments to save() do not match any of the call signatures'
            )

    def __getitem__(self, ind):
        if isinstance(ind, int):
            value = self.get_property_by_index(ind)
        elif self.has_property(ind):
            value = _get_property(self, ind)
        elif isinstance(ind, int):
            raise _dlite.DLiteIndexError(
                'instance property index out of range: %d' % ind
            )
        else:
            raise _dlite.DLiteKeyError('no such property: %s' % ind)
        if isinstance(value, np.ndarray) and self.is_frozen():
            value.flags.writeable = False  # ensure immutability
        return value

    def __setitem__(self, ind, value):
        if self.is_frozen():
            raise _dlite.DLiteUnsupportedError(
                f'frozen instance does not support assignment of property '
                f'{ind}')
        if isinstance(ind, int):
            self.set_property_by_index(ind, value)
        elif self.has_property(ind):
            _set_property(self, ind, value)
        elif isinstance(ind, int):
            raise _dlite.DLiteIndexError(
                'instance property index out of range: %d' % ind
            )
        else:
            raise _dlite.DLiteKeyError('no such property: %s' % ind)

    def __contains__(self, item):
        return item in self.properties.keys()

    def __getattr__(self, name):
        if name == 'this':
            return object.__getattribute__(self, name)
        d = object.__getattribute__(self, '__dict__')
        if name in d:
            value = d[name]
        elif self.has_property(name):
            value = _get_property(self, name)
        elif self.has_dimension(name):
            value = self.get_dimension_size(name)
        else:
            raise _dlite.DLiteAttributeError(
                'Instance object has no attribute %r' % name
            )
        if isinstance(value, np.ndarray) and self.is_frozen():
            value.flags.writeable = False  # ensure immutability
        return value

    def __setattr__(self, name, value):
        if name == 'this':
            object.__setattr__(self, name, value)
        elif self.is_frozen():
            raise _dlite.DLiteUnsupportedError(
                f"frozen instance does not support assignment of property "
                f"'{name}'"
            )
        elif _has_property(self, name):
            _set_property(self, name, value)
        else:
            object.__setattr__(self, name, value)

    def __dir__(self):
        return (object.__dir__(self) +
                [name for name in self.properties] +
                [d.name for d in self.meta.properties['dimensions']])

    def __hash__(self):
        return UUID(self.uuid).int

    def __eq__(self, other):
        return self.uuid == other.uuid

    def __str__(self):
        return self.asjson()

    def copy(self, newid=None):
        """Returns a copy of this instance.  If `newid` is given, it
        will be the id of the new instance, otherwise it will be given
        a random UUID."""
        newinst = self._copy(newid=newid)
        return instance_cast(newinst)

    def __reduce__(self):
    # ensures that instances can be pickled
        def iterfun(inst):
           for i, prop in enumerate(inst.properties.values()):
               if isinstance(prop, np.ndarray):
                   p = np.zeros_like(prop)
                   p.flat = [p.asdict() if hasattr(p, 'asdict') else p
                             for p in prop]
               else:
                   p = prop.asdict() if hasattr(prop, 'asdict') else prop
               yield i, p
        return (
            Instance.from_metaid,
            (self.meta.uri, list(self.dimensions.values()), self.uuid),
            None,
            None,
            iterfun(self),
        )

    def asdict(self, soft7=True, uuid=None, single=None):
        """Returns a dict representation of self.

        Arguments:
            soft7: Whether to structure metadata as SOFT7.
            uuid: Whether to include UUID in the dict.  The default is true
                if `single=True` and URI is None, otherwise it is false.
            single: Whether to return in single-entity format.
                If None, single-entity format is used for metadata and
                multi-entity format for data instances.
        """
        dct = d = {}
        if single is None:
            single = self.is_meta

        if uuid is None:
            uuid = single and self.uri

        if not single:
            d = {}
            dct[self.uuid] = d

        if uuid:
            d['uuid'] = self.uuid
        if self.uri:
            d['uri'] = self.uri
        d['meta'] = self.meta.uri
        if self.is_meta:
            d['description'] = self['description']
            if soft7:
                d['dimensions'] = {dim.name: dim.description
                                   for dim in self['dimensions']}
                d['properties'] = {p.name: p.asdict(exclude_name=True)
                                   for p in self['properties']}
            else:
                d['dimensions'] = [dim.asdict() for dim in self['dimensions']]
                d['properties'] = [p.asdict(soft7=False)
                                   for p in self['properties']]
        else:
            d['dimensions'] = self.dimensions
            d['properties'] = {k: standardise(v, self.get_property_descr(k))
                               for k, v in self.properties.items()}
        if self.has_property('relations') and (
                self.is_meta or self.meta.has_property('relations')):
            d['relations'] = self['relations'].tolist()
        return dct

    def asjson(self, indent=0, single=None,
               urikey=False, with_uuid=False, with_meta=False,
               with_arrays=False, no_parent=False,
               soft7=None, uuid=None):
        """Returns a JSON representation of self.

        Arguments:
            indent: Number of spaces to indent each line with.
            single: Whether to return single-entity format.  Default is
                single-entity format for metadata and multi-entity format
                for data instances.
            urikey: Use uri (if it exists) as JSON key in multi-entity format.
            with_uuid: Whether to include UUID in output.
            with_meta: Always include "meta" field, even for entities.
            with_arrays: Write metadata dimensions and properties as jSON
                arrays (old format).
            no_parent: Do not include transaction parent info.
            soft7: Whether to structure metadata as SOFT7. Deprecated.
                Use `with_arrays=False` instead.
            uuid: Alias for `with_uuid`. Deprecated.
        """
        if single is None:
            single = self.is_meta

        if soft7 is not None:
            warnings.warn(
                "`soft7` argument of asjson() is deprecated, use "
                "`with_arrays` (negated) instead.",
                 DeprecationWarning, stacklevel=2)
            with_arrays = not bool(soft7)

        if uuid is not None:
            warnings.warn(
                "`uuid` argument of asjson() is deprecated, use "
                "`with_uuid` instead.",
                 DeprecationWarning, stacklevel=2)
            with_uuid = bool(uuid)

        return self._asjson(indent=indent, single=single, urikey=urikey,
                            with_uuid=with_uuid, with_meta=with_meta,
                            with_arrays=with_arrays, no_parent=no_parent)


    # Deprecated methods
    def tojson(self, indent=0, single=False,
               urikey=False, with_uuid=False, with_meta=False,
               with_arrays=False, no_parent=False,
               soft7=None, uuid=None):
        """Deprecated alias for asjson()."""
        warnings.warn(
            'tojson() is deprecated, use asjson() instead.',
             DeprecationWarning, stacklevel=2)
        return self._asjson(indent=indent, single=single, urikey=urikey,
                            with_uuid=with_uuid, with_meta=with_meta,
                            with_arrays=with_arrays, no_parent=no_parent)

    def get_copy(self):
        """Returns a copy of self.

        This method is deprecated.  Use copy() instead.
        """
        warnings.warn(
            "Instance.get_copy() is deprecated.  Use Instance.copy() instead.",
            DeprecationWarning, stacklevel=2)
        return self.copy()

    @property
    def q(self):
        """ to work with quantities """
        from dlite.quantity import get_quantity_helper
        return get_quantity_helper(self)

    def get_quantity(self, name):
        return self.q[name]

    def set_quantity(self, name, value, unit):
        self.q[name] = (value, unit)



# Register Instance in _dlite:
_dlite.Instance_swigregister(Instance)

def get_instance(*args, **kwargs):
    r"""
    get_instance(id, metaid=None, check_storages=true) -> Instance
    Returns a new reference to instance with given id.

    If `metaid` is provided, the instance will be mapped to an instance of
    this metadata.

    If the instance exists in the in-memory store it is returned.
    Otherwise, if `check_storages` is true, the instance is searched for
    in the storage plugin path (initiated from the DLITE_STORAGES
    environment variable).

    It is an error message if the instance cannot be found.

    Note: setting `check_storages` to false is normally a good idea if calling
    this function from a storage plugin.  Otherwise you may easily end up in an
    infinite recursive loop that will exhaust the call stack.

    """
    return _dlite.get_instance(*args, **kwargs)

def has_instance(*args, **kwargs):
    r"""
    has_instance(id, check_storages=true) -> bool
    Returns whether an instance with `id` exists.

    If `check_storages` is true, the instance is also searched for
    in the storage plugin path.

    """
    return _dlite.has_instance(*args, **kwargs)

def istore_get_uuids():
    r"""
    istore_get_uuids() -> char **
    Returns a list of in-memory stored ids.


    """
    return _dlite.istore_get_uuids()

def _get_property(inst, name):
    r"""_get_property(inst, name) -> obj_t *"""
    return _dlite._get_property(inst, name)

def _set_property(inst, name, obj):
    r"""_set_property(inst, name, obj)"""
    return _dlite._set_property(inst, name, obj)

def _has_property(inst, name):
    r"""_has_property(inst, name) -> bool"""
    return _dlite._has_property(inst, name)

def _from_bytes(driver, INPUT_BYTES, id=None, options=None, metaid=None):
    r"""
    _from_bytes(driver, INPUT_BYTES, id=None, options=None, metaid=None) -> Instance
    Loads instance from string.
    """
    return _dlite._from_bytes(driver, INPUT_BYTES, id, options, metaid)
BASIC_METADATA_SCHEMA = _dlite.BASIC_METADATA_SCHEMA

ENTITY_SCHEMA = _dlite.ENTITY_SCHEMA

COLLECTION_ENTITY = _dlite.COLLECTION_ENTITY


import tempfile
import warnings
from typing import Sequence
from pathlib import Path
from urllib.parse import urlparse
from uuid import UUID

import numpy as np


#class InvalidMetadataError:
#    """Malformed or invalid metadata."""


class Metadata(Instance):
    """A subclass of Instance for metadata.

    Arguments:
        uri: URI of the new metadata.
        dimensions: Sequence of Dimension instances describing each dimension.
        properties: Sequence of Property instances describing each property.
        description: Description of metadata.
    """
    def __new__(
        cls,
        uri: str,
        dimensions: "Sequence[Dimension]",
        properties: "Sequence[Property]",
        description: str = ''
    ):
        return Instance.create_metadata(
            uri, dimensions, properties, description)

    def __init__(self, *args, **kwargs):
# Do nothing, just avoid calling Instance.__init__()
#
# The reason for this is that Instance.__init__() requires that the
# first argument is a dlite.Instance object ().  All needed
# instantiation is already done in __new__().
        pass

    def __repr__(self):
        return f"<Metadata: uri='{self.uri}'>"

    def __call__(self, dimensions=(), properties=None, id=None, dims=None):
        """Returns a new instance of this metadata.

        By default the instance is uninitialised, but with the `properties`
        argument it can be either partly or fully initialised.

        Arguments:
            dimensions: Either a dict mapping dimension names to values or
                a sequence of dimension values.
            properties: Dict of property name-property value pairs.  Used
                to initialise the instance (fully or partly).  A KeyError
                is raised if a key is not a valid property name.
            id: Id of the new instance.  The default is to create a
                random UUID.
            dims: Deprecated alias for `dimensions`.

        Returns:
            New instance.
        """
        if not self.is_meta:
            raise TypeError('data instances are not callable')
        if dims is not None:
            warnings.warn(
                "`dims` argument of metadata constructor is deprecated.\n"
                "Use `dimensions` instead.",
                DeprecationWarning,
                stacklevel=2,
            )
            dimensions = dims
        if isinstance(dimensions, dict):
            dimnames = [d.name for d in self.properties['dimensions']]
            dimensions = [dimensions[name] for name in dimnames]

        inst = Instance.from_metaid(self.uri, dimensions, id)
        if isinstance(properties, dict):
            for k, v in properties.items():
                inst[k] = v
        return inst

# For convenience. Easier to use than self.properties["properties"]
    @property
    def props(self):
        """A dict mapping property name to the `Property` object for the
        described metadata."""
        return {p.name: p for p in self.properties["properties"]}

    def getprop(self, name):
        """Returns the metadata property object with the given name."""
        if "properties" not in self.properties:
            raise _dlite.DLiteInvalidMetadataError(
                'self.properties on metadata must contain a "properties" item'
            )
        lst = [p for p in self.properties["properties"] if p.name == name]
        if lst:
            return lst[0]
        raise _dlite.DLiteKeyError(
            f"Metadata {self.uri} has no such property: {name}")

    def dimnames(self):
        """Returns a list of all dimension names in this metadata."""
        if "dimensions" not in self.properties:
            return []
        return [d.name for d in self.properties['dimensions']]

    def propnames(self):
        """Returns a list of all property names in this metadata."""
        if "properties" not in self.properties:
            raise _dlite.DLiteInvalidMetadataError(
                'self.properties on metadata must contain a "properties" item'
            )
        return [p.name for p in self.properties['properties']]


def standardise(v, prop, asdict=False):
    """Represent property value `v` as a standard python type.
    If `asdict` is true, dimensions, properties and relations will be
    represented with a dict, otherwise as a list of strings."""
    if asdict:
        conv = lambda x: x.asdict() if hasattr(x, 'asdict') else x
    else:
        conv = lambda x: list(x.asstrings()) if hasattr(x, 'asstrings') else x

    if prop.dtype == BlobType:
        if prop.ndims:
            V = np.fromiter(
                (''.join(f'{c:02x}' for c in s.item()) for s in v.flat),
                dtype=f'U{2*prop.size}')
            V.shape = v.shape
            return V.tolist()
        else:
            return ''.join(f'{c:02x}' for c in v)
    elif hasattr(v, 'tolist'):
        return [conv(x) for x in v.tolist()]
    else:
        return conv(v)


def get_instance(
    id: str,
    metaid: str = None,
    check_storages: bool = True
) -> "Instance":
    """Return instance with given id.

    Arguments:
        id: ID of instance to return.
        metaid: If given, dlite will try to convert the instance to a new
            instance of ``metaid``.
        check_storages: Whether to check for the instance in storages listed
            in dlite.storage_path if the instance is not already in memory.

    Returns:
        DLite Instance.
    """
    if isinstance(id, Instance):
        inst = id
    else:
        id = str(id).rstrip("#/")
        if metaid and not isinstance(metaid, Instance):
            metaid = str(metaid).rstrip("#/")
        inst = _dlite.get_instance(id, metaid, check_storages)

    if inst is None and id.startswith("http://onto-ns.com/"):
        try:
            import requests
        except ModuleNotFoundError as e:
            import warnings
            warnings.warn(f"{e}: skip trying to fetch from entity service")
        else:
            import json
            r = requests.get(id)
            if r.ok:
                d = json.loads(r.content.decode())
# Workaround for bugs in the entity service
                if "meta" not in d or d["meta"] == dlite.ENTITY_SCHEMA:
                    if "dimensions" not in d:
                        d["dimensions"] = {}
                inst = Instance.from_dict(d)

    if inst is None:
        raise _dlite.DLiteMissingInstanceError(f"no such instance: {id}")

    return instance_cast(inst)



def _collection_save(coll, s):
    r"""_collection_save(coll, s) -> int"""
    return _dlite._collection_save(coll, s)

def _collection_save_url(coll, url):
    r"""_collection_save_url(coll, url) -> int"""
    return _dlite._collection_save_url(coll, url)

def _collection_add_relation(coll, s, p, o, d=None):
    r"""_collection_add_relation(coll, s, p, o, d=None) -> int"""
    return _dlite._collection_add_relation(coll, s, p, o, d)

def _collection_remove_relations(coll, s, p, o, d=None):
    r"""_collection_remove_relations(coll, s, p, o, d=None) -> int"""
    return _dlite._collection_remove_relations(coll, s, p, o, d)

def _collection_find_first(coll, s, p, o, d=None):
    r"""_collection_find_first(coll, s, p, o, d=None) -> Relation"""
    return _dlite._collection_find_first(coll, s, p, o, d)

def _collection_add(coll, label, inst):
    r"""_collection_add(coll, label, inst) -> int"""
    return _dlite._collection_add(coll, label, inst)

def _collection_remove(coll, label):
    r"""_collection_remove(coll, label) -> int"""
    return _dlite._collection_remove(coll, label)

def _collection_get_new(coll, label, metaid):
    r"""_collection_get_new(coll, label, metaid) -> Instance"""
    return _dlite._collection_get_new(coll, label, metaid)

def _collection_get_id(coll, id):
    r"""_collection_get_id(coll, id) -> Instance"""
    return _dlite._collection_get_id(coll, id)

def _collection_has(coll, label):
    r"""_collection_has(coll, label) -> int"""
    return _dlite._collection_has(coll, label)

def _collection_has_id(coll, id):
    r"""_collection_has_id(coll, id) -> int"""
    return _dlite._collection_has_id(coll, id)

def _collection_count(coll):
    r"""_collection_count(coll) -> int"""
    return _dlite._collection_count(coll)
class _Collection(object):
    r"""Proxy of C _DLiteCollection struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    uuid = property(_dlite._Collection_uuid_get, doc=r"""uuid""")
    uri = property(_dlite._Collection_uri_get, doc=r"""uri""")
    _refcount = property(_dlite._Collection__refcount_get, doc=r"""_refcount""")

    def __init__(self, url=None, storage=None, id=None, lazy=False):
        r"""__init__(self, url=None, storage=None, id=None, lazy=False) -> _Collection"""
        _dlite._Collection_swiginit(self, _dlite.new__Collection(url, storage, id, lazy))
    __swig_destroy__ = _dlite.delete__Collection

    def asinstance(self):
        r"""
        asinstance(self) -> Instance
        Returns a new view of collection as an instance.
        """
        return _dlite._Collection_asinstance(self)

# Register _Collection in _dlite:
_dlite._Collection_swigregister(_Collection)
class _CollectionIter(object):
    r"""Proxy of C _CollectionIter struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    coll = property(_dlite._CollectionIter_coll_get, _dlite._CollectionIter_coll_set, doc=r"""coll""")
    state = property(_dlite._CollectionIter_state_get, _dlite._CollectionIter_state_set, doc=r"""state""")
    s = property(_dlite._CollectionIter_s_get, _dlite._CollectionIter_s_set, doc=r"""s""")
    p = property(_dlite._CollectionIter_p_get, _dlite._CollectionIter_p_set, doc=r"""p""")
    o = property(_dlite._CollectionIter_o_get, _dlite._CollectionIter_o_set, doc=r"""o""")
    d = property(_dlite._CollectionIter_d_get, _dlite._CollectionIter_d_set, doc=r"""d""")
    rettype = property(_dlite._CollectionIter_rettype_get, _dlite._CollectionIter_rettype_set, doc=r"""rettype""")

    def __init__(self, *args, **kwargs):
        r"""
        __init__(self, inst, s=None, p=None, o=None, d=None, rettype='t') -> _CollectionIter
        Iterator over instances in a collection.
        """
        _dlite._CollectionIter_swiginit(self, _dlite.new__CollectionIter(*args, **kwargs))
    __swig_destroy__ = _dlite.delete__CollectionIter

    def next(self):
        r"""
        next(self) -> Instance
        Returns a new reference next instance in the collection.
        """
        return _dlite._CollectionIter_next(self)

    def next_relation(self):
        r"""next_relation(self) -> Relation"""
        return _dlite._CollectionIter_next_relation(self)

    def poll(self):
        r"""
        poll(self) -> Relation
        Returns reference to the current instance or None if all instances have been visited.
        """
        return _dlite._CollectionIter_poll(self)

    def reset(self):
        r"""
        reset(self)
        Resets the iterator.  The next call to next() will return the first relation.
        """
        return _dlite._CollectionIter_reset(self)

    def __iter__(self):
        return self

    def __next__(self):
        if self.rettype == 'I':  # instance
            v = self.next()
            if v and v.is_meta:
                v.__class__ = Metadata
        elif self.rettype in 'RTtspod':  # relation
            v = self.next_relation()
        else:
            raise ValueError('`rettype` must one of "IRTtspod"')

        if v is None:
            raise StopIteration()

        if self.rettype == 'I':  # return instance
            return v
        if self.rettype == 'R':  # return relation object
            return v.copy()
        if self.rettype == 'T':  # return (s,p,o,d) tuple
            return (v.s, v.p, v.o, v.d)
        if self.rettype == 't':  # return (s,p,o) tuple
            return (v.s, v.p, v.o)
        elif self.rettype == 's':  # return subject
            return v.s
        elif self.rettype == 'p':  # return predicate
            return v.p
        elif self.rettype == 'o':  # return object
            return v.o
        elif self.rettype == 'd':  # return datatype
            return v.d

        raise _dlite.DLiteRuntimeError()  # should never be reached


# Register _CollectionIter in _dlite:
_dlite._CollectionIter_swigregister(_CollectionIter)

def _get_collection(id):
    r"""
    _get_collection(id) -> _Collection
    Returns a new reference to a collection with given id.
    """
    return _dlite._get_collection(id)

def _collection_value(inst, s=None, p=None, o=None, d=None, fallback=None, any=0):
    r"""_collection_value(inst, s=None, p=None, o=None, d=None, fallback=None, any=0) -> char *"""
    return _dlite._collection_value(inst, s, p, o, d, fallback, any)

from warnings import warn


class Collection(Instance):
    """A collection of instances and relations between them.

    Instances added to a collection are referred to with a label,
    which is local to the collection.

    Iteration over a collection will iterate over the instances added
    to it.  Likewise, the len() of a collection will return the number
    of instances.

    Use the `get_relations()` method (or the convenience methods
    `get_subjects()`, `get_predicates()` and `get_objects()`) to iterate
    over relations.  The number of relations is available via the
    `nrelations` property.

    Relations are `(s, p, o, d=None)`-triples with an optional fourth field
    `d`, specifying the datatype of the object.  The datatype may have the
    following values:

    - None: object is an IRI.
    - Starts with '@': object is a language-tagged plain literal.
      The language identifier follows the '@'-sign. e.g. `@en`
    - Otherwise: object is a literal with datatype `d`.

    Arguments:
        id: URI or UUID of the new instance.  The default is to create a
            collection with no URI and random (version 4) UUID.

    """
    def __new__(cls, id=None):
        """Creates an empty collection."""
        _coll = _Collection(id=id)
        inst = _coll.asinstance()
        inst.__class__ = Collection
        return inst

    def __init__(self, id=None):
        pass  # avoid calling Instance.__init__()

    @classmethod
    def load(cls, src, location=None, options=None, id=None, lazy=True):
        """Loads a collection from storage.

        Arguments:
            src: Storage instance | url | driver
            location:
                File path to load from when `src` is a driver.
            options: str
                Options passed to the storage plugin when `src` is a driver.
            id: str
                Id of collection to load.  Needed if there are more than
                one instance in the storage.
            lazy: bool
                Whether to also save all instances referred to by the
                collection.
        """
        if isinstance(src, Storage):
            _coll = _Collection(storage=src, id=id, lazy=bool(lazy))
        elif location:
            with Storage(src, location, options) as s:
                _coll = _Collection(storage=s, id=id, lazy=bool(lazy))
        else:
            _coll = _Collection(url=src, lazy=bool(lazy))
        inst = _coll.asinstance()
        inst.__class__ = Collection
        return inst

    def save(self, dst, location=None, options=None, include_instances=True):
        """Save collection.

        Arguments:
            dst: Storage instance | url | driver
            location: str
                File path to write to when `dst` is a driver.
            options: str
                Options passed to the storage plugin when `dst` is a driver.
            include_instances: bool
                Whether to also save all instances referred to by the
                collection.
        """
        loc = str(location) if location else None
        if include_instances:
            c = self._coll
            if isinstance(dst, Storage):
                _collection_save(c, dst)
            elif location:
                with Storage(dst, loc, options) as s:
                    _collection_save(c, s)
            else:
                _collection_save_url(c, dst)
        elif isinstance(dst, Storage):
            Instance.save(self, storage=dst)
        else:
            Instance.save(self, dst, loc, options)

    _coll = property(
        lambda self: _get_collection(id=self.uuid),
        doc='SWIG-internal representation of this collection.')

    properties = property(
        lambda self: {'relations': list(self.get_relations())},
        doc='Dictionary with property name-value pairs.')

    def __repr__(self):
        return '<Collection: %s>' % (
            f"uri='{self.uri}'" if self.uri else f"uuid='{self.uuid}'")

    def __iter__(self):
        return _CollectionIter(self, rettype='I')

    def __len__(self):
        return _collection_count(self._coll)

    def __getitem__(self, label):
        return self.get(label)

    def __setitem__(self, label, inst):
        self.add(label, inst)

    def __delitem__(self, label):
        self.remove(label)

    def __contains__(self, label):
        return self.has(label)

    def add(self, label, inst, force=False):
        """Add `inst` to collection with given label.
        If `force` is true, a possible existing instance will be replaced.
        """
        if force and self.has(label):
            self.remove(label)
        _collection_add(self._coll, label, inst)

    def remove(self, label):
        """Remove instance with given label from collection."""
        if _collection_remove(self._coll, label):
            raise _dlite.DLiteError(f'No such label in collection: "{label}"')

    def get(self, label, metaid=None):
        """Return instance with given label.

        If `metaid` is given, the instance is converted to an instance
        of `metaid` using instance mappings.  If no such instance mapping
        is registered, a DLiteError is raised.
        """
        inst = _collection_get_new(self._coll, label, metaid)
        return instance_cast(inst)

    def get_id(self, id):
        """Return instance with given id."""
        inst = _collection_get_id(self._coll, id)
        return inst

    def has(self, label):
        """Returns true if an instance has been added with the given label."""
        b = _collection_has(self._coll, label)
        return bool(b)

    def has_id(self, id):
        """Returns true if an instance has been added with the given id."""
        b = _collection_has_id(self._coll, id)
        return bool(b)

    def add_relation(self, s, p, o, d=None):
        """Add (subject, predicate, object) RDF triple to collection."""
        if _collection_add_relation(self._coll, s, p, o, d) != 0:
            raise _dlite.DLiteError(
                f'Error adding relation ({s}, {p}, {o}, {d})')

    def remove_relations(self, s=None, p=None, o=None, d=None):
        """Remove all relations matching `s`, `p` and `o`."""
        if _collection_remove_relations(self._coll, s, p, o, d) < 0:
            raise _dlite.DLiteError(
                f'Error removing relations matching ({s}, {p}, {o}, {d})')

    def get_first_relation(self, s=None, p=None, o=None, d=None):
        """Returns the first relation matching `s`, `p` and `o`.
        None is returned if there are no matching relations."""
        return _collection_find_first(self._coll, s, p, o, d)

    def get_instances(self, metaid=None, property_mappings=False,
                      allow_incomplete=False, ureg=None, function_repo=None,
                      **kwargs):
        """Returns a generator over all instances in collection.

        Arguments:
            metaid: If given, only instances of this metadata will be
                returned.
            property_mappings: Whether to also iterate over new instances
                of type `metaid` instantiated from property mappings.
                Hence, if `property_mappings` is true, `metaid` is required.
            allow_incomplete: Allow "incomplete" property mappings.
                Properties with no mappings will be initialised to zero.
            ureg: Optional custom Pint unit registry.  By default the builtin
                Pint unit registry is used.
            function_repo: Repository for mapping functions.  Should map
                function IRIs to function implementations.
            kwargs: Additional keyword arguments passed to mapping_route().
        """
        iter = _CollectionIter(self, s=None, p=None, o=None, rettype='I')
        if metaid:
            if hasattr(metaid, "uri"):
                uri = metaid.uri
            else:
                uri = str(metaid).rstrip("#/")

            for inst in iter:
                if inst.meta.uri == uri:
                    yield inst

            if property_mappings:
# This import must be here to avoid circular imports
# -- consider refacturing.
                from dlite.mappings import instantiate_all

                try:
                    import pint
                    from tripper import Namespace, Triplestore
                except ImportError as exc:
                    raise ImportError(
                        "Property mappings require tripper and pint. "
                        "Please do:\n\n"
                        "    pip install pint tripper\n"
                    ) from exc

                meta = metaid if isinstance(
                    metaid, Instance) else _dlite.get_instance(
                        str(metaid).rstrip("#/"))
                if not meta:
                    raise TypeError(f"cannot instantiate metadata: {metaid}")
                if meta.is_meta:
                    meta.__class__ = Metadata

                if ureg is None:
                    quantity = pint.Quantity
                elif isinstance(ureg, pint.UnitRegistry):
                    quantity = ureg.Quantity
                elif isinstance(ureg, pint.Quantity):
                    quantity = ureg
                else:
                    raise TypeError(
                        '`ureg` must be a Pint unit registry or Quantity '
                        'class')

                ts = Triplestore(backend='collection', collection=self)
                if function_repo:
                    ts.function_repo.update(function_repo)

                for inst in instantiate_all(
                    meta=meta,
                    instances=list(self.get_instances()),
                    triplestore=ts,
                    allow_incomplete=allow_incomplete,
                    quantity=quantity,
                    **kwargs
                ):
                    yield inst

        elif property_mappings:
            raise _dlite.DLiteError(
                '`metaid` is required when `property_mappings` is true')
        else:
            for inst in iter:
                yield inst

    def get_labels(self):
        """Returns a generator over all labels."""
        return self.get_subjects(p='_is-a', o='Instance')

    def get_relations(self, s=None, p=None, o=None, d=None, rettype='t'):
        """Returns a generator over all relations matching the given
        values of `s` (subject), `p` (predicate), `o` (object) and `d`
        (datatype). See docstring for dlite.Collection for more info.

        The following values for `rettype` are supported:
        - 'I': Iterate over instances.
        - 'R': Iterate over relation objects.
        - 'T': Iterate over (s,p,o,d) tuples.
        - 't': Iterate over (s,p,o) tuples.
        - 's': Iterate over subjects.
        - 'p': Iterate over predicates.
        - 'o': Iterate over objects.
        - 'd': Iterate over datatypes.
        """
        return _CollectionIter(self, s=s, p=p, o=o, d=d, rettype=rettype)

    def get_subjects(self, p=None, o=None, d=None):
        """Returns a generator over all subjects of relations matching the
        given values of `p`, `o` and `d`."""
        return _CollectionIter(self, s=None, p=p, o=o, d=d, rettype='s')

    def get_predicates(self, s=None, o=None, d=None):
        """Returns a generator over all predicates of relations matching the
        given values of `s`, `o` and `d`."""
        return _CollectionIter(self, s=s, p=None, o=o, d=d, rettype='p')

    def get_objects(self, s=None, p=None, d=None):
        """Returns a generator over all subjects of relations matching the
        given values of `s`, `p` and `d`."""
        return _CollectionIter(self, s=s, p=p, o=None, d=d, rettype='o')

    def value(self, s=None, p=None, o=None, d=None, default=None, any=False):
        """Return pointer to the value for a pair of two criteria.

        Useful if one knows that there may only be one value.

        Parameters:
            s, p, o: Criteria to match. Two of these must not be None.
            d: If not None, the required datatype of literal objects.
            default: Value to return if no matches are found.
            any: If true, return first matching value.

        Returns:
            A pointer to the value of the `s`, `p` or `o` that is None.

        Raises:
            DLiteTypeError: Not exactly two of `s`, `p` and `o` are None.
            DLiteLookupError: No match can be found or more that one match
                if `any` is true.
        """
        return _dlite._collection_value(self, s, p, o, d, default, any)

def get_collection(id):
    """Returns a new reference to a collection with given id."""
    warn("dlite.get_collection() is deprecated.  "
         "Use dlite.get_instance() instead",
         DeprecationWarning, stacklevel=2)
    _coll = _get_collection(id=id)
    inst = _coll.asinstance()
    inst.__class__ = Collection
    return inst

del warn

class FUPath(object):
    r"""Proxy of C _FUPaths struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    n = property(_dlite.FUPath_n_get, doc=r"""n""")

    def __init__(self, pathtype):
        r"""
        __init__(self, pathtype) -> FUPath
        Creates a _Path instance of type `pathtype`.

        """
        _dlite.FUPath_swiginit(self, _dlite.new_FUPath(pathtype))
    __swig_destroy__ = _dlite.delete_FUPath

    def __repr__(self):
        r"""__repr__(self) -> char *"""
        return _dlite.FUPath___repr__(self)

    def __len__(self):
        r"""__len__(self) -> int"""
        return _dlite.FUPath___len__(self)

    def getitem(self, index):
        r"""getitem(self, index) -> char const *"""
        return _dlite.FUPath_getitem(self, index)

    def __setitem__(self, index, path):
        r"""__setitem__(self, index, path)"""
        return _dlite.FUPath___setitem__(self, index, path)

    def __delitem__(self, index):
        r"""__delitem__(self, index)"""
        return _dlite.FUPath___delitem__(self, index)

    def insert(self, index, path):
        r"""insert(self, index, path)"""
        return _dlite.FUPath_insert(self, index, path)

    def append(self, path):
        r"""append(self, path)"""
        return _dlite.FUPath_append(self, path)

    def extend(self, paths, pathsep=None):
        r"""extend(self, paths, pathsep=None)"""
        return _dlite.FUPath_extend(self, paths, pathsep)

    def get_platform(self):
        r"""get_platform(self) -> char const *"""
        return _dlite.FUPath_get_platform(self)

    def set_platform(self, platform):
        r"""set_platform(self, platform)"""
        return _dlite.FUPath_set_platform(self, platform)

    def __contains__(self, value):
        return value in self.aslist()

    def __getitem__(self, index):
        n = len(self)
        if index < 0:
            index += n
        if index < 0 or index >= n:
            raise IndexError(f'index out of range: {index}')
        return self.getitem(index)

    def __iter__(self):

        class Iter:
            def __init__(slf):
                slf.n = 0
            def __next__(slf):
                if slf.n < len(self):
                    path = self[slf.n]
                    slf.n += 1
                    return path
                else:
                    raise StopIteration()

        return Iter()

    def aslist(self):
        return [self[i] for i in range(len(self))]



# Register FUPath in _dlite:
_dlite.FUPath_swigregister(FUPath)

import sys
from importlib.metadata import entry_points

def _create_path(name):
    """Return new DLite search path object, with given name."""
    if sys.version_info < (3, 10):  # Fallback for Python < 3.10
        eps = entry_points().get(f"dlite.{name}", ())
    else:  # For Python 3.10+
        eps = entry_points(group=f"dlite.{name}")

    path = FUPath(name)
    path.name = name
    for entry_point in eps:
        path.append(entry_point.value)
    return path

# Create DLite search paths objects
storage_path = _create_path("storages")
template_path = _create_path("templates")
storage_plugin_path = _create_path("storage-plugins")
mapping_plugin_path = _create_path("mapping-plugins")
python_storage_plugin_path = _create_path("python-storage-plugins")
python_mapping_plugin_path = _create_path("python-mapping-plugins")
python_protocol_plugin_path = _create_path("python-protocol-plugins")


# Update default search paths
from pathlib import Path
pkgdir = Path(__file__).resolve().parent
sharedir = pkgdir / "share" / "dlite"
# if (sharedir / "storages").exists():
#     storage_path[-1] = sharedir / "storages"
#     #storage_path.append(sharedir / "storages")
# if (sharedir / "storage-plugins").exists():
#     storage_plugin_path[-1] = sharedir / "storage-plugins"
#     #storage_plugin_path.append(sharedir / "storage-plugins")
# if (sharedir / "mapping-plugins").exists():
#     mapping_plugin_path[-1] = sharedir / "mapping-plugins"
#     #mapping_plugin_path.append(sharedir / "mapping-plugins")
# if (sharedir / "python-storage-plugins").exists():
#     python_storage_plugin_path[-1] = sharedir / "python-storage-plugins"
#     #python_storage_plugin_path.append(sharedir / "python-storage-plugins")
# if (sharedir / "python-mapping-plugins").exists():
#     python_mapping_plugin_path[-1] = sharedir / "python-mapping-plugins"
#     #python_mapping_plugin_path.append(sharedir / "python-mapping-plugins")
if (sharedir / "python-protocol-plugins").exists():
#python_protocol_plugin_path[-1] = sharedir / "python-protocol-plugins"
    python_protocol_plugin_path.append(sharedir / "python-protocol-plugins")



def mapping(output_uri, instances):
    r"""
    mapping(output_uri, instances) -> Instance
      Returns a new instance of metadata `output_uri` by mapping the
      input instances.

    """
    return _dlite.mapping(output_uri, instances)

def python_mapping_unload():
    r"""
    python_mapping_unload()
      Unloads all currently loaded mappings.

    """
    return _dlite.python_mapping_unload()

def mapping_plugin_unload(name=None):
    r"""mapping_plugin_unload(name=None) -> int"""
    return _dlite.mapping_plugin_unload(name)
class _BehaviorRecord(object):
    r"""Proxy of C _DLiteBehavior struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_dlite._BehaviorRecord_name_get, doc=r"""name""")
    version_added = property(_dlite._BehaviorRecord_version_added_get, doc=r"""version_added""")
    version_new = property(_dlite._BehaviorRecord_version_new_get, doc=r"""version_new""")
    version_remove = property(_dlite._BehaviorRecord_version_remove_get, doc=r"""version_remove""")
    description = property(_dlite._BehaviorRecord_description_get, doc=r"""description""")
    value = property(_dlite._BehaviorRecord_value_get, _dlite._BehaviorRecord_value_set, doc=r"""value""")

    def asdict(self):
        return {
            "name": self.name,
            "value": bool(self.value),
            "version_added": self.version_added,
            "version_new": self.version_new,
            "version_remove": self.version_remove,
            "description": self.description,
        }

    def __str__(self):
        import json
        return json.dumps(self.asdict(), indent=2)


    def __init__(self):
        r"""__init__(self) -> _BehaviorRecord"""
        _dlite._BehaviorRecord_swiginit(self, _dlite.new__BehaviorRecord())
    __swig_destroy__ = _dlite.delete__BehaviorRecord

# Register _BehaviorRecord in _dlite:
_dlite._BehaviorRecord_swigregister(_BehaviorRecord)

def _behavior_nrecords():
    r"""
    _behavior_nrecords() -> size_t
    Return the number of registered behaviors.

    """
    return _dlite._behavior_nrecords()

def _behavior_recordno(n):
    r"""
    _behavior_recordno(n) -> _BehaviorRecord
    Return a pointer to record with the given number or NULL if `n` is out of
    range.

    """
    return _dlite._behavior_recordno(n)

def _behavior_record(name):
    r"""
    _behavior_record(name) -> _BehaviorRecord
    Return a pointer to the given behavior record, or NULL if `name` is
    not in the behavior table.

    """
    return _dlite._behavior_record(name)

def _behavior_get(name):
    r"""
    _behavior_get(name) -> int
    Get value of given behavior.

    Returns 1 if the behavior is on, 0 if it is off and a negative
    value on error.

    """
    return _dlite._behavior_get(name)

def _behavior_set(name, value):
    r"""
    _behavior_set(name, value) -> int
    Enable given behavior if `value` is non-zero.  Disable if `value` is zero.

    Returns non-zero on error.

    """
    return _dlite._behavior_set(name, value)


class _Behavior():
    """A class that provides easy access for setting and getting behavior
    settings.

    It is used via the singleton `dlite.Behavior`.

    The different behavior values can be accessed as attributes.

    """
    def __getattr__(self, name):
        return bool(_dlite._behavior_get(name))

    def __setattr__(self, name, value):
        _dlite._behavior_set(name, 1 if value else 0)

    def __dir__(self):
        return object.__dir__(self) + list(self.get_names())

    def get_names(self):
        """Return a generator over all registered behavior names."""
        for i in range(_dlite._behavior_nrecords()):
            yield _dlite._behavior_recordno(i).name

    def get_record(self, name):
        """Return a record with information about the given behavior."""
        rec = _dlite._behavior_record(name)
        if not rec:
            raise DLiteKeyError(f"No such behavior record: {name}")
        return rec


# A singleton for accessing behavior settings.
Behavior = _Behavior()


class _DLiteJStoreIter(object):
    r"""Proxy of C _DLiteJStoreIter struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, js, pattern=None):
        r"""
        __init__(self, js, pattern=None) -> _DLiteJStoreIter
        Iterates over instances in JSON store `js`.  If `pattern` is given, only
        instances whos metadata URI matches `pattern` are returned.

        """
        _dlite._DLiteJStoreIter_swiginit(self, _dlite.new__DLiteJStoreIter(js, pattern))
    __swig_destroy__ = _dlite.delete__DLiteJStoreIter

    def next(self):
        r"""next(self) -> char const *"""
        return _dlite._DLiteJStoreIter_next(self)

    def __next__(self):
        id = self.next()
        if id:
            return id
        raise StopIteration()

    def __iter__(self):
        return self


# Register _DLiteJStoreIter in _dlite:
_dlite._DLiteJStoreIter_swigregister(_DLiteJStoreIter)
class _JStore(object):
    r"""Proxy of C _JStore struct."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _dlite.delete__JStore

    def remove(self, id):
        r"""
        remove(self, id)
        Remove instance with given `id`.
        """
        return _dlite._JStore_remove(self, id)

    def load_file(self, INPUT):
        r"""load_file(self, INPUT)"""
        return _dlite._JStore_load_file(self, INPUT)

    def load_json(self, INPUT):
        r"""load_json(self, INPUT)"""
        return _dlite._JStore_load_json(self, INPUT)

    def add(self, inst):
        r"""
        add(self, inst)
        Add json representation of `inst` to store.
        """
        return _dlite._JStore_add(self, inst)

    def _get(self, id=None):
        r"""_get(self, id=None) -> Instance"""
        return _dlite._JStore__get(self, id)

    def get_json(self, id):
        r"""
        get_json(self, id) -> char const *
        Return JSON string for given id from store.
        """
        return _dlite._JStore_get_json(self, id)

    def get_single_id(self):
        r"""
        get_single_id(self) -> char const *
        If there is one instance in storage, return its id. Otherwise, raise an DLiteLookupError exception.
        """
        return _dlite._JStore_get_single_id(self)

    def get_ids(self, pattern=None):
        r"""
        get_ids(self, pattern=None) -> _DLiteJStoreIter
        Iterate over all id's matching pattern.
        """
        return _dlite._JStore_get_ids(self, pattern)

    def __len__(self):
        r"""__len__(self) -> int"""
        return _dlite._JStore___len__(self)

    def __bool__(self):
        r"""__bool__(self) -> bool"""
        return _dlite._JStore___bool__(self)

    def __iadd__(self, other):
        r"""__iadd__(self, other) -> _JStore"""
        return _dlite._JStore___iadd__(self, other)

    def get(self, id=None):
        """Return instance with given `id` from store.

        If `id` is None and there is exactly one instance in the store,
        return the instance.  Otherwise raise an DLiteLookupError.
        """
        inst = self._get(id=id)
        return instance_cast(inst)

    def load_dict(self, d, id=None):
        """Load dict representation of instance to the store."""
        if "properties" not in d:
            if id:
                self.load_dict(d[id], id=id)
            else:
                for id, val in d.items():
                    self.load_dict(val, id=id)
            return

        d = d.copy()
        uuid = None
        if "uuid" in d:
            uuid = d["uuid"]
        elif "uri" in d or "identity" in d:
            uuid = _dlite.get_uuid(str(d.get("uri", d.get("identity"))))

        if id and uuid and _dlite.get_uuid(id) != uuid:
            raise _dlite.DLiteInconsistentDataError(
                f"id '{id}' is not consistent with existing uuid: {uuid}"
            )
        elif not id and not uuid:
            raise _dlite.DLiteValueError(
                "`id` argument is required when dict has no 'uuid', 'uri' "
                "or 'identity' key"
            )
        elif not uuid:
            assert id
            uuid = _dlite.get_uuid(id)

        assert uuid
        d.setdefault("uuid", uuid)
        if id and id != uuid:
            d.setdefault("uri", id)

        self.load_json(json.dumps(d, cls=_JSONEncoder))

    def get_dict(self, id=None, soft7=True, single=None, with_uuid=None,
                 with_meta=False, with_parent=True, urikey=False):
        """Return dict representation of the store or item with given id.

        Arguments:
            id: If given, return dict-representation of this id.
                Otherwise, return dict-representation of the store.
            soft7: Whether to use soft7 formatting.
            single: Whether to return in single-instance format.
                If None, single-instance format is used for metadata and
                multi-instance format for data instances.
            with_uuid: Whether to include UUID in the dict.  The default
                is true if `single=True` and URI is None, otherwise it
                is false.
            with_meta: Whether to always include "meta" (even for metadata)
            with_parent: Whether to include parent info for transactions.
            urikey: Whether the URI is the preferred keys in multi-instance
                format.

        """
        d = {}
        if id:
            d[id] = json.loads(self.get_json(id))
        else:
            if single is None:
                single = False
            for _id in self.get_ids():
                d[_id] = json.loads(self.get_json(_id))

        return format_dict(
            d, id=id, soft7=soft7, single=single, with_uuid=with_uuid,
            with_meta=with_meta, with_parent=with_parent, urikey=urikey
        )



# Register _JStore in _dlite:
_dlite._JStore_swigregister(_JStore)

def JStore():
    r"""
    JStore() -> _JStore
    Store for JSON data.
    """
    val = _dlite.new_JStore()
    return val


import json
from typing import Mapping, Sequence


def format_dict(
    d, id=None, soft7=True, single=None, with_uuid=None, with_meta=False,
    with_parent=True, urikey=False,
):
    """Return a copy of `d` formatted according to the given options.

    Arguments:
        d: Input dict. This should be a dict-representation of a DLite
            instance.
        id: If given, return dict-representation of this id.
            Otherwise, return dict-representation of the store.
        soft7: Whether to use soft7 formatting.
        single: Whether to return in single-instance format.
            If None, single-instance format is used for metadata and
            multi-instance format for data instances.
        with_uuid: Whether to include UUID in the dict.  The default
            is true if `single=True` and URI is None, otherwise it
            is false.
        with_meta: Whether to always include "meta" (even for metadata)
        with_parent: Whether to include parent info for transactions.
        urikey: Whether the URI is the preferred keys in multi-instance
            format.

    Notes:
        This method works with the dict-representation and does not
        access instances.  The only exception is when `d` corresponds to
        a data instance who's dimensions is a list of dimension lengths.
        In this case the metadata is needed to get dimension names.

    """
    if not id and single and "properties" not in d and len(d) != 1:
        raise _dlite.DLiteLookupError(
            "`id` must be given for `single=True` unless there is only one item"
        )

    if id and "properties" not in d:
        uuid = _dlite.get_uuid(id)
        key = id if id in d else uuid if uuid in d else None
        if not key:
            raise _dlite.DLiteLookupError(f"no such key in store: {id}")
        return format_dict(
            d[key], id=id, soft7=soft7, single=single, with_uuid=with_uuid,
            with_meta=with_meta, with_parent=with_parent, urikey=urikey)

    dct = {}

    if "properties" not in d:
        if single:
            if len(d) != 1:
                raise dlite.DLiteValueError(
                    "Not possible to return single-instance format, use `id`"
                )
        else:
            for k, v in d.items():
                vid  = v.get("uri", v.get("identity", k))
                key = vid if urikey else v.get("uuid", _dlite.get_uuid(vid))
                dct[key] = format_dict(
                    v, id=k, soft7=soft7, single=True, with_uuid=with_uuid,
                    with_meta=with_meta, with_parent=with_parent
                )
            return dct

    uri = d.get("uri", d.get("identity"))
    uuid = d.get("uuid", _dlite.get_uuid(uri) if uri else None)
    if id and not uuid:
        if _dlite.get_uuid_version(id) == 5:
            uri = id
        uuid = _dlite.get_uuid(id)
    metaid = d.get("meta", _dlite.ENTITY_SCHEMA)
    ismeta = (
        "meta" not in d
        or d["meta"] in (_dlite.ENTITY_SCHEMA, _dlite.BASIC_METADATA_SCHEMA)
        or "properties" in d["properties"]
    )

    if single is None:
        single = ismeta
    if with_uuid is None:
       with_uuid = single and not ("uri" in d or "identity" in d)

    if not uuid and (with_uuid or not single):
        raise _dlite.DLiteTypeError("cannot infer UUID from dict")

    if with_uuid:
        dct["uuid"] = uuid
    if uri:
        dct["uri"] = uri
    if with_meta or metaid != _dlite.ENTITY_SCHEMA:
        dct["meta"] = metaid
    if ismeta and "description" in d:
        dct["description"] = d["description"]
    if with_parent and "parent" in d:
        dct["parent"] = d["parent"].copy()

    dct["dimensions"] = {} if soft7 or not ismeta else []
    if "dimensions" in d:
        if isinstance(d["dimensions"], Mapping):
            if soft7 or not ismeta:
                dct["dimensions"].update(d["dimensions"])
            else:
                for k, v in d["dimensions"].items():
                    dct["dimensions"].append({"name": k, "description": v})
        elif isinstance(d["dimensions"], Sequence):
            if soft7 and ismeta:
                for dim in d["dimensions"]:
                    dct["dimensions"][dim["name"]] = dim.get("description", "")
            elif ismeta:
                dct["dimensions"].extend(d["dimensions"])
            else:
                meta = get_instance(metaid)
                for name, value in zip(meta.dimnames(), d["dimensions"]):
                    dct["dimensions"][name] = value
        else:
            raise dlite.DLiteValueError(
                "'dimensions' must be a mapping or sequence, got: "
                f"{type(d['dimensions'])}"
            )

    dct["properties"] = {} if soft7 or not ismeta else []
    if isinstance(d["properties"], Mapping):
        if soft7 or not ismeta:
            dct["properties"].update(d["properties"])
        else:
            for k, v in d["properties"].items():
                prop = {"name": k}
                prop.update(v)
                dct["properties"].append(prop)
    elif isinstance(d["properties"], Sequence):
        if not ismeta:
            raise dlite.DLiteValueError(
                "only metadata can have a sequence of properties"
            )
        if soft7:
            for prop in d["properties"]:
                p = prop.copy()
                name = p.pop("name")
                dct["properties"][name] = p
        else:
            dct["properties"].extend(d["properties"])
    else:
        raise dlite.DLiteValueError(
            "'properties' must be a mapping or sequence, got: "
            f"{type(d['properties'])}"
        )

    if "relations" in d:
        dct["relations"] = d["repations"].copy()

    if single:
        return dct
    return {uri if uri and urikey else uuid: dct}


class _JSONEncoder(json.JSONEncoder):
    """JSON encoder that also handle bytes object."""
    def default(self, o):
        if isinstance(o, bytes):
            return "".join(f"{c:x}" for c in o)
        elif (isinstance(o, (str, bool, int, float, list, dict)) or o is None):
            return super().default(o)
        else:
            return str(o)



