# generated by datamodel-codegen:
#   filename:  pyproject.json
#   timestamp: 2024-11-20T02:30:19+00:00

from __future__ import annotations

from enum import Enum
from typing import ParamSpec, ParamSpecArgs,Annotated, Any, Dict, Generic, List, Literal, LiteralString, NamedTuple, Optional, ParamSpecKwargs, Protocol, Tuple, TypeVar, Union, Unpack, cast, dataclass_transform, get_type_hints,TypeVarTuple, overload
from typing_extensions import  TypedDict

from pydantic import (
    AnyUrl,
    BaseModel,
    ConfigDict,
    EmailStr,
    Field,
    RootModel,
    StringConstraints,
    conint,
    constr,
)
from pydantic._internal._model_construction import ModelMetaclass
from pydantic.fields import Field as PydanticModelField, PrivateAttr as PydanticModelPrivateAttr

DataModel = BaseModel


class Readme(DataModel):
    """AKA the README."""

    model_config = ConfigDict(
        extra='forbid',
    )
    content_type: Any = Field(..., alias='content-type')
    file: str = Field(..., title='README file path')


class Readme1(DataModel):
    """AKA the README."""

    model_config = ConfigDict(
        extra='forbid',
    )
    content_type: Any = Field(..., alias='content-type')
    text: str = Field(..., title='README text')


class License(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    file: str = Field(..., title='License file path')


class License1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    text: str = Field(..., title='License text')


class DynamicEnum(Enum):
    version = 'version'
    description = 'description'
    readme = 'readme'
    requires_python = 'requires-python'
    license = 'license'
    license_files = 'license-files'
    authors = 'authors'
    maintainers = 'maintainers'
    keywords = 'keywords'
    classifiers = 'classifiers'
    urls = 'urls'
    scripts = 'scripts'
    gui_scripts = 'gui-scripts'
    entry_points = 'entry-points'
    dependencies = 'dependencies'
    optional_dependencies = 'optional-dependencies'

class Tox(DataModel):
    pass

class Readme2(DataModel):
    """AKA the README."""

    model_config = ConfigDict(
        extra='forbid',
    )
    content_type: Any = Field(..., alias='content-type')
    file: str = Field(..., title='README file path')


class Readme3(DataModel):
    """AKA the README."""

    model_config = ConfigDict(
        extra='forbid',
    )
    content_type: Any = Field(..., alias='content-type')
    text: str = Field(..., title='README text')


class License2(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    file: str = Field(..., title='License file path')


class License3(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    text: str = Field(..., title='License text')


class DependencyGroups(DataModel):
    """Another dependency group to include in this one."""

    model_config = ConfigDict(
        extra='forbid',
    )
    include_group: constr(pattern='^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9._-]*[a-zA-Z0-9])$') | None = Field(None, alias='include-group')


class TargetVersionEnum(Enum):
    py33 = 'py33'
    py34 = 'py34'
    py35 = 'py35'
    py36 = 'py36'
    py37 = 'py37'
    py38 = 'py38'
    py39 = 'py39'
    py310 = 'py310'
    py311 = 'py311'
    py312 = 'py312'
    py313 = 'py313'


class PartialBlack(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    code: str | None = Field(
        None, description='Format the code passed in as a string.',
    )
    line_length: int | None = Field(
        88, alias='line-length', description='How many characters per line to allow.',
    )
    target_version: List[TargetVersionEnum] | None = Field(
        None,
        alias='target-version',
        description="Python versions that should be supported by Black's output. You should include all versions that your code supports. By default, Black will infer target versions from the project metadata in pyproject.toml. If this does not yield conclusive results, Black will use per-file auto-detection.",
    )
    pyi: bool | None = Field(
        False,
        description='Format all input files like typing stubs regardless of file extension. This is useful when piping source on standard input.',
    )
    ipynb: bool | None = Field(
        False,
        description='Format all input files like Jupyter Notebooks regardless of file extension. This is useful when piping source on standard input.',
    )
    python_cell_magics: List[str] | None = Field(
        None,
        alias='python-cell-magics',
        description='When processing Jupyter Notebooks, add the given magic to the list of known python-magics (capture, prun, pypy, python, python3, time, timeit). Useful for formatting cells with custom python magics.',
    )
    skip_source_first_line: bool | None = Field(
        False,
        alias='skip-source-first-line',
        description='Skip the first line of the source code.',
    )
    skip_string_normalization: bool | None = Field(
        False,
        alias='skip-string-normalization',
        description="Don't normalize string quotes or prefixes.",
    )
    skip_magic_trailing_comma: bool | None = Field(
        False,
        alias='skip-magic-trailing-comma',
        description="Don't use trailing commas as a reason to split lines.",
    )
    preview: bool | None = Field(
        False,
        description="Enable potentially disruptive style changes that may be added to Black's main functionality in the next major release.",
    )
    unstable: bool | None = Field(
        False,
        description="Enable potentially disruptive style changes that have known bugs or are not currently expected to make it into the stable style Black's next major release. Implies --preview.",
    )
    enable_unstable_feature: List[str] | None = Field(
        None,
        alias='enable-unstable-feature',
        description='Enable specific features included in the `--unstable` style. Requires `--preview`. No compatibility guarantees are provided on the behavior or existence of any unstable features.',
    )
    check: bool | None = Field(
        False,
        description="Don't write the files back, just return the status. Return code 0 means nothing would change. Return code 1 means some files would be reformatted. Return code 123 means there was an internal error.",
    )
    diff: bool | None = Field(
        False,
        description="Don't write the files back, just output a diff to indicate what changes Black would've made. They are printed to stdout so capturing them is simple.",
    )
    color: bool | None = Field(
        False,
        description='Show (or do not show) colored diff. Only applies when --diff is given.',
    )
    fast: bool | None = Field(
        False,
        description='By default, Black performs an AST safety check after formatting your code. The --fast flag turns off this check and the --safe flag explicitly enables it. [default: --safe]',
    )
    required_version: str | None = Field(
        None,
        alias='required-version',
        description='Require a specific version of Black to be running. This is useful for ensuring that all contributors to your project are using the same version, because different versions of Black may format code a little differently. This option can be set in a configuration file for consistent results across environments.',
    )
    exclude: str | None = Field(
        None,
        description='A regular expression that matches files and directories that should be excluded on recursive searches. An empty value means no paths are excluded. Use forward slashes for directories on all platforms (Windows, too). By default, Black also ignores all paths listed in .gitignore. Changing this value will override all default exclusions. [default: /(\\.direnv|\\.eggs|\\.git|\\.hg|\\.ipynb_checkpoints|\\.mypy_cache|\\.nox|\\.pytest_cache|\\.ruff_cache|\\.tox|\\.svn|\\.venv|\\.vscode|__pypackages__|_build|buck-out|build|dist|venv)/]',
    )
    extend_exclude: str | None = Field(
        None,
        alias='extend-exclude',
        description='Like --exclude, but adds additional files and directories on top of the default values instead of overriding them.',
    )
    force_exclude: str | None = Field(
        None,
        alias='force-exclude',
        description='Like --exclude, but files and directories matching this regex will be excluded even when they are passed explicitly as arguments. This is useful when invoking Black programmatically on changed files, such as in a pre-commit hook or editor plugin.',
    )
    include: str | None = Field(
        '(\\.pyi?|\\.ipynb)$',
        description='A regular expression that matches files and directories that should be included on recursive searches. An empty value means all files are included regardless of the name. Use forward slashes for directories on all platforms (Windows, too). Overrides all exclusions, including from .gitignore and command line options.',
    )
    workers: int | None = Field(
        None,
        description='When Black formats multiple files, it may use a process pool to speed up formatting. This option controls the number of parallel workers. This can also be specified via the BLACK_NUM_WORKERS environment variable. Defaults to the number of CPUs in the system.',
    )
    quiet: bool | None = Field(
        False,
        description='Stop emitting all non-critical output. Error messages will still be emitted (which can silenced by 2>/dev/null).',
    )
    verbose: bool | None = Field(
        False,
        description='Emit messages about files that were not changed or were ignored due to exclusion patterns. If Black is using a configuration file, a message detailing which one it is using will be emitted.',
    )


class BuildFrontend(Enum):
    """Set the tool to use to build, either "pip" (default for now), "build", or "build[uv]"."""

    pip = 'pip'
    build = 'build'
    build_uv_ = 'build[uv]'
    default = 'default'


class Name(Enum):
    pip = 'pip'
    build = 'build'
    build_uv_ = 'build[uv]'


class BuildFrontend1(DataModel):
    """Set the tool to use to build, either "pip" (default for now), "build", or "build[uv]"."""

    model_config = ConfigDict(
        extra='forbid',
    )
    name: Name
    args: List[str] | None = None


class ContainerEngine(Enum):
    docker = 'docker'
    podman = 'podman'


class Name1(Enum):
    docker = 'docker'
    podman = 'podman'


class ContainerEngine1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Name1
    create_args: List[str] | None = Field(None, alias='create-args')
    disable_host_mount: bool | None = Field(None, alias='disable-host-mount')


class Inherit(Enum):
    """How to inherit the parent's value."""

    none = 'none'
    prepend = 'prepend'
    append = 'append'


class Archs(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Change the architectures built on your machine by default.',
        title='CIBW_ARCHS',
    )


class BeforeAll(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Execute a shell command on the build system before any wheels are built.',
        title='CIBW_BEFORE_ALL',
    )


class BeforeBuild(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description="Execute a shell command preparing each wheel's build.",
        title='CIBW_BEFORE_BUILD',
    )


class BeforeTest(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Execute a shell command before testing each wheel.',
        title='CIBW_BEFORE_TEST',
    )


class BuildFrontend2(Enum):
    """Set the tool to use to build, either "pip" (default for now), "build", or "build[uv]"."""

    pip = 'pip'
    build = 'build'
    build_uv_ = 'build[uv]'
    default = 'default'


class Name2(Enum):
    pip = 'pip'
    build = 'build'
    build_uv_ = 'build[uv]'


class BuildFrontend3(DataModel):
    """Set the tool to use to build, either "pip" (default for now), "build", or "build[uv]"."""

    model_config = ConfigDict(
        extra='forbid',
    )
    name: Name2
    args: List[str] | None = None


class BuildFrontendModel(
    RootModel[
        Union[
            BuildFrontend2,
            constr(pattern=r'^pip; ?args:'),
            constr(pattern=r'^build; ?args:'),
            constr(pattern=r'^build\[uv\]; ?args:'),
            BuildFrontend3,
        ]
    ],
):
    root: BuildFrontend2 | constr(pattern='^pip; ?args:') | constr(pattern='^build; ?args:') | constr(pattern='^build\\[uv\\]; ?args:') | BuildFrontend3 = Field(
        ...,
        description='Set the tool to use to build, either "pip" (default for now), "build", or "build[uv]"',
        title='CIBW_BUILD_FRONTEND',
    )


class BuildVerbosity(RootModel[conint(ge=-3, le=3)]):
    root: conint(ge=-3, le=3) = Field(
        ...,
        description='Increase/decrease the output of pip wheel.',
        title='CIBW_BUILD_VERBOSITY',
    )


class ConfigSettings(
    RootModel[Union[str, Dict[constr(pattern=r'.+'), str | List[str]]]],
):
    root: str | Dict[constr(pattern='.+'), str | List[str]] = Field(
        ...,
        description='Specify config-settings for the build backend.',
        title='CIBW_CONFIG_SETTINGS',
    )


class ContainerEngine2(Enum):
    docker = 'docker'
    podman = 'podman'


class Name3(Enum):
    docker = 'docker'
    podman = 'podman'


class ContainerEngine3(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Name3
    create_args: List[str] | None = Field(None, alias='create-args')
    disable_host_mount: bool | None = Field(None, alias='disable-host-mount')


class ContainerEngineModel(
    RootModel[
        Union[
            ContainerEngine2,
            constr(pattern=r'^docker; ?(create_args|disable_host_mount):'),
            constr(pattern=r'^podman; ?(create_args|disable_host_mount):'),
            ContainerEngine3,
        ]
    ],
):
    root: ContainerEngine2 | constr(pattern='^docker; ?(create_args|disable_host_mount):') | constr(pattern='^podman; ?(create_args|disable_host_mount):') | ContainerEngine3 = Field(..., title='CIBW_CONTAINER_ENGINE')


class DependencyVersions(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify how cibuildwheel controls the versions of the tools it uses',
        title='CIBW_DEPENDENCY_VERSIONS',
    )


class Environment(RootModel[Union[str, Dict[constr(pattern=r'.+'), str]]]):
    root: str | Dict[constr(pattern='.+'), str] = Field(
        ...,
        description='Set environment variables needed during the build.',
        title='CIBW_ENVIRONMENT',
    )


class EnvironmentPass(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Set environment variables on the host to pass-through to the container during the build.',
        title='CIBW_ENVIRONMENT_PASS',
    )


class ManylinuxAarch64Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_AARCH64_IMAGE',
    )


class ManylinuxI686Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_I686_IMAGE',
    )


class ManylinuxPpc64leImage(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PPC64LE_IMAGE',
    )


class ManylinuxPypyAarch64Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PYPY_AARCH64_IMAGE',
    )


class ManylinuxPypyI686Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PYPY_I686_IMAGE',
    )


class ManylinuxPypyX8664Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PYPY_X86_64_IMAGE',
    )


class ManylinuxS390xImage(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_S390X_IMAGE',
    )


class ManylinuxX8664Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_X86_64_IMAGE',
    )


class MusllinuxAarch64Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_AARCH64_IMAGE',
    )


class MusllinuxArmv7lImage(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_ARMV7L_IMAGE',
    )


class MusllinuxI686Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_I686_IMAGE',
    )


class MusllinuxPpc64leImage(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_PPC64LE_IMAGE',
    )


class MusllinuxS390xImage(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_S390X_IMAGE',
    )


class MusllinuxX8664Image(RootModel[str]):
    root: str = Field(
        ...,
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_X86_64_IMAGE',
    )


class RepairWheelCommand(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Execute a shell command to repair each built wheel.',
        title='CIBW_REPAIR_WHEEL_COMMAND',
    )


class TestCommand(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Execute a shell command to test each built wheel.',
        title='CIBW_TEST_COMMAND',
    )


class TestExtras(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Install your wheel for testing using `extras_require`',
        title='CIBW_TEST_EXTRAS',
    )


class TestRequires(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Install Python dependencies before running the tests',
        title='CIBW_TEST_REQUIRES',
    )


class FollowImports(Enum):
    """Directs what to do with imports when the imported module is found as a `.py` file and not part of the files, modules and packages provided on the command line."""

    normal = 'normal'
    silent = 'silent'
    skip = 'skip'
    error = 'error'


class AllowRedefinition(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Allows variables to be redefined with an arbitrary type, as long as the redefinition is in the same block and nesting level as the original definition.',
    )


class AllowUntypedGlobals(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Causes mypy to suppress errors caused by not being able to fully infer the types of global and class variables.',
    )


class AlwaysFalse(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always false.',
    )


class AlwaysTrue(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always true.',
    )


class AnyExprsReport(RootModel[str]):
    root: str = Field(
        ...,
        description='Causes mypy to generate a text file report documenting how many expressions of type `Any` are present within your codebase.',
    )


class CacheDir(RootModel[str]):
    root: str = Field(
        ...,
        description='Specifies the location where mypy stores incremental cache info. User home directory and environment variables will be expanded. This setting will be overridden by the `MYPY_CACHE_DIR` environment variable.',
    )


class CacheFineGrained(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Include fine-grained dependency information in the cache for the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )


class CheckUntypedDefs(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Type-checks the interior of functions without type annotations.',
    )


class CoberturaXmlReport(RootModel[str]):
    root: str = Field(
        ...,
        description='Causes mypy to generate a Cobertura XML type checking coverage report.',
    )


class ColorOutput(RootModel[bool]):
    root: bool = Field(..., description='Shows error messages with color enabled.')


class CustomTypeshedDir(RootModel[str]):
    root: str = Field(
        ...,
        description='This specifies the directory where mypy looks for standard library typeshed stubs, instead of the typeshed that ships with mypy. This is primarily intended to make it easier to test typeshed changes before submitting them upstream, but also allows you to use a forked version of typeshed.',
    )


class CustomTypingModule(RootModel[str]):
    root: str = Field(
        ...,
        description='Specifies a custom module to use as a substitute for the `typing` module.',
    )


class DisableErrorCode(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ..., description='Allows disabling one or multiple error codes globally.',
    )


class DisallowAnyDecorated(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows functions that have `Any` in their signature after decorator transformation.',
    )


class DisallowAnyExplicit(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows explicit `Any` in type positions such as type annotations and generic type parameters.',
    )


class DisallowAnyExpr(RootModel[bool]):
    root: bool = Field(
        ..., description='Disallows all expressions in the module that have type `Any`.',
    )


class DisallowAnyGenerics(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows usage of generic types that do not specify explicit type parameters.',
    )


class DisallowAnyUnimported(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows usage of types that come from unfollowed imports (anything imported from an unfollowed import is automatically given a type of `Any`).',
    )


class DisallowIncompleteDefs(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows defining functions with incomplete type annotations, while still allowing entirely unannotated definitions.',
    )


class DisallowSubclassingAny(RootModel[bool]):
    root: bool = Field(..., description='Disallows subclassing a value of type `Any`.')


class DisallowUntypedCalls(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows calling functions without type annotations from functions with type annotations. Note that when used in per-module options, it enables/disables this check INSIDE the module(s) specified, not for functions that come from that module(s).',
    )


class DisallowUntypedDecorators(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Reports an error whenever a function with type annotations is decorated with a decorator without annotations.',
    )


class DisallowUntypedDefs(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows defining functions without type annotations or with incomplete type annotations (a superset of `disallow_incomplete_defs`).',
    )


class EnableErrorCode(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ..., description='Allows enabling one or multiple error codes globally.',
    )


class ErrorSummary(RootModel[bool]):
    root: bool = Field(
        ..., description='Shows a short summary line after error messages.',
    )


class FollowImportsForStubs(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Determines whether to respect the `follow_imports` setting even for stub (`.pyi`) files.',
    )


class ForceUnionSyntax(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Always use `Union[]` and `Optional[]` for union types in error messages (instead of the `|` operator), even on Python 3.10+.',
    )


class ForceUppercaseBuiltins(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Always use `List` instead of `list` in error messages, even on Python 3.9+.',
    )


class HideErrorCodes(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Hides error codes (https://mypy.readthedocs.io/en/stable/error_codes.html#error-codes) in error messages.',
    )


class IgnoreErrors(RootModel[bool]):
    root: bool = Field(..., description='Ignores all non-fatal errors.')


class IgnoreMissingImports(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Suppresses error messages about imports that cannot be resolved.',
    )


class ImplicitOptional(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Causes mypy to treat arguments with a `None` default value as having an implicit `typing.Optional` type.',
    )


class ImplicitReexport(RootModel[bool]):
    root: bool = Field(
        ...,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. When false, mypy will not re-export unless the item is imported using from-as or is included in `__all__`. Note that mypy treats stub files as if this is always disabled.',
    )


class Incremental(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Enables incremental mode (https://mypy.readthedocs.io/en/stable/command_line.html#incremental).',
    )


class JunitXml(RootModel[str]):
    root: str = Field(
        ...,
        description='Causes mypy to generate a JUnit XML test result document with type checking results. This can make it easier to integrate mypy with continuous integration (CI) tools.',
    )


class LinecountReport(RootModel[str]):
    root: str = Field(
        ...,
        description='Causes mypy to generate a text file report documenting the functions and lines that are typed and untyped within your codebase.',
    )


class LinecoverageReport(RootModel[str]):
    root: str = Field(
        ...,
        description="Causes mypy to generate a JSON file that maps each source file's absolute filename to a list of line numbers that belong to typed functions in that file.",
    )


class LineprecisionReport(RootModel[str]):
    root: str = Field(
        ...,
        description='Causes mypy to generate a flat text file report with per-module statistics of how many lines are typechecked etc.',
    )


class LocalPartialTypes(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disallows inferring variable type for `None` from two assignments in different scopes. This is always implicitly enabled when using the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )


class NoImplicitOptional(RootModel[bool]):
    root: bool = Field(..., description='Inverse of implicit_optional.')


class NoImplicitReexport(RootModel[bool]):
    root: bool = Field(
        ...,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. This flag changes the behavior to not re-export unless the item is imported using from-as or is included in `__all__`. Note this is always treated as enabled for stub files.',
    )


class NoSitePackages(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disables using type information in installed packages (see PEP 561). This will also disable searching for a usable Python executable. This acts the same as :option:`--no-site-packages <mypy --no-site-packages>` command line flag.',
    )


class Pdb(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Invokes `pdb` (https://docs.python.org/3/library/pdb.html) on fatal error.',
    )


class Plugins(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ..., description='A comma-separated list of mypy plugins.',
    )


class Pretty(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Use visually nicer output in error messages: use soft word wrap, show source code snippets, and show error location markers.',
    )


class RaiseExceptions(RootModel[bool]):
    root: bool = Field(..., description='Raise exception on fatal error.')


class ScriptsAreModules(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Makes script `x` become module `x` instead of `__main__`. This is useful when checking multiple scripts in a single run.',
    )


class ShowAbsolutePath(RootModel[bool]):
    root: bool = Field(..., description='Show absolute paths to files.')


class ShowColumnNumbers(RootModel[bool]):
    root: bool = Field(..., description='Shows column numbers in error messages.')


class ShowErrorContext(RootModel[bool]):
    root: bool = Field(
        ..., description='Prefixes each error with the relevant context.',
    )


class ShowTraceback(RootModel[bool]):
    root: bool = Field(..., description='Shows traceback on fatal error.')


class SkipCacheMtimeChecks(RootModel[bool]):
    root: bool = Field(
        ..., description='Skip cache internal consistency checks based on mtime.',
    )


class SkipVersionCheck(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Makes mypy use incremental cache data even if it was generated by a different version of mypy. (By default, mypy will perform a version check and regenerate the cache if it was written by older versions of mypy.)',
    )


class SqliteCache(RootModel[bool]):
    root: bool = Field(..., description='Use an SQLite database to store the cache.')


class Strict(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Enable all optional error checking flags. You can see the list of flags enabled by strict mode in the full `mypy --help` output. The exact list of flags enabled by `strict` may change over time.',
    )


class StrictConcatenate(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Make arguments prepended via `Concatenate` be truly positional-only.',
    )


class StrictEquality(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Prohibit equality checks, identity checks, and container checks between non-overlapping types.',
    )


class StrictOptional(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Enables or disables strict `Optional` checks. If `False`, mypy treats `None` as compatible with every type.',
    )


class UntypedCallsExclude(RootModel[Union[str, List[str]]]):
    root: str | List[str] = Field(
        ...,
        description='Selectively excludes functions and methods defined in specific packages, modules, and classes from action of `disallow_untyped_calls`. This also applies to all submodules of packages (i.e. everything inside a given prefix). Note, this option does not support per-file configuration, the exclusions list is defined globally for all your code.',
    )


class Verbosity(RootModel[int]):
    root: int = Field(
        ...,
        description='Controls how much debug output will be generated. Higher numbers are more verbose.',
    )


class WarnIncompleteStub(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Warns about missing type annotations in typeshed. This is only relevant in combination with `disallow_untyped_defs` or `disallow_incomplete_defs`.',
    )


class WarnNoReturn(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Shows errors for missing return statements on some execution paths.',
    )


class WarnReturnAny(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Shows a warning when returning a value with type `Any` from a function declared with a non-`Any` return type.',
    )


class WarnUnreachable(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Shows a warning when encountering any code inferred to be unreachable or redundant after performing type analysis.',
    )


class WarnUnusedConfigs(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Warns about per-module sections in the config file that do not match any files processed when invoking mypy. (This requires turning off incremental mode using `incremental = False`.)',
    )


class WarnUnusedIgnores(RootModel[bool]):
    root: bool = Field(
        ..., description='Warns about unneeded `# type: ignore` comments.',
    )


class XmlReport(RootModel[str]):
    root: str = Field(
        ..., description='Causes mypy to generate an XML type checking coverage report.',
    )


class ApiBan(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    msg: str = Field(..., description='The message to display when the API is used.')


class BannedAliases(RootModel[List[str]]):
    root: List[str]


class ConstantType(Enum):
    bytes = 'bytes'
    complex = 'complex'
    float = 'float'
    int = 'int'
    str = 'str'


class Convention1(Enum):
    """Use Google-style docstrings."""

    google = 'google'


class Convention2(Enum):
    """Use NumPy-style docstrings."""

    numpy = 'numpy'


class Convention3(Enum):
    """Use PEP257-style docstrings."""

    pep257 = 'pep257'


class Convention(RootModel[Union[Convention1, Convention2, Convention3]]):
    root: Convention1 | Convention2 | Convention3


class Direction1(Enum):
    """Construct a map from module to its dependencies (i.e., the modules that it imports)."""

    Dependencies = 'Dependencies'


class Direction2(Enum):
    """Construct a map from module to its dependents (i.e., the modules that import it)."""

    Dependents = 'Dependents'


class Direction(RootModel[Union[Direction1, Direction2]]):
    root: Direction1 | Direction2


class Dynamic(RootModel[Literal['dynamic']]):
    root: Literal['dynamic']


class Flake8AnnotationsOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allow_star_arg_any: bool | None = Field(
        None,
        alias='allow-star-arg-any',
        description='Whether to suppress `ANN401` for dynamically typed `*args` and `**kwargs` arguments.',
    )
    ignore_fully_untyped: bool | None = Field(
        None,
        alias='ignore-fully-untyped',
        description="Whether to suppress `ANN*` rules for any declaration that hasn't been typed at all. This makes it easier to gradually add types to a codebase.",
    )
    mypy_init_return: bool | None = Field(
        None,
        alias='mypy-init-return',
        description='Whether to allow the omission of a return type hint for `__init__` if at least one argument is annotated.',
    )
    suppress_dummy_args: bool | None = Field(
        None,
        alias='suppress-dummy-args',
        description='Whether to suppress `ANN000`-level violations for arguments matching the "dummy" variable regex (like `_`).',
    )
    suppress_none_returning: bool | None = Field(
        None,
        alias='suppress-none-returning',
        description='Whether to suppress `ANN200`-level violations for functions that meet either of the following criteria:\n\n- Contain no `return` statement. - Explicit `return` statement(s) all return `None` (explicitly or implicitly).',
    )


class Flake8BanditOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    check_typed_exception: bool | None = Field(
        None,
        alias='check-typed-exception',
        description='Whether to disallow `try`-`except`-`pass` (`S110`) for specific exception types. By default, `try`-`except`-`pass` is only disallowed for `Exception` and `BaseException`.',
    )
    hardcoded_tmp_directory: List[str] | None = Field(
        None,
        alias='hardcoded-tmp-directory',
        description='A list of directories to consider temporary.',
    )
    hardcoded_tmp_directory_extend: List[str] | None = Field(
        None,
        alias='hardcoded-tmp-directory-extend',
        description='A list of directories to consider temporary, in addition to those specified by [`hardcoded-tmp-directory`](#lint_flake8-bandit_hardcoded-tmp-directory).',
    )


class Flake8BooleanTrapOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    extend_allowed_calls: List[str] | None = Field(
        None,
        alias='extend-allowed-calls',
        description='Additional callable functions with which to allow boolean traps.\n\nExpects to receive a list of fully-qualified names (e.g., `pydantic.Field`, rather than `Field`).',
    )


class Flake8BugbearOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    extend_immutable_calls: List[str] | None = Field(
        None,
        alias='extend-immutable-calls',
        description='Additional callable functions to consider "immutable" when evaluating, e.g., the `function-call-in-default-argument` rule (`B008`) or `function-call-in-dataclass-defaults` rule (`RUF009`).\n\nExpects to receive a list of fully-qualified names (e.g., `fastapi.Query`, rather than `Query`).',
    )


class Flake8BuiltinsOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    builtins_allowed_modules: List[str] | None = Field(
        None,
        alias='builtins-allowed-modules',
        description='List of builtin module names to allow.',
    )
    builtins_ignorelist: List[str] | None = Field(
        None, alias='builtins-ignorelist', description='Ignore list of builtins.',
    )


class Flake8ComprehensionsOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allow_dict_calls_with_keyword_arguments: bool | None = Field(
        None,
        alias='allow-dict-calls-with-keyword-arguments',
        description='Allow `dict` calls that make use of keyword arguments (e.g., `dict(a=1, b=2)`).',
    )


class Flake8CopyrightOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    author: str | None = Field(
        None,
        description='Author to enforce within the copyright notice. If provided, the author must be present immediately following the copyright notice.',
    )
    min_file_size: conint(ge=0) | None = Field(
        None,
        alias='min-file-size',
        description='A minimum file size (in bytes) required for a copyright notice to be enforced. By default, all files are validated.',
    )
    notice_rgx: str | None = Field(
        None,
        alias='notice-rgx',
        description='The regular expression used to match the copyright notice, compiled with the [`regex`](https://docs.rs/regex/latest/regex/) crate. Defaults to `(?i)Copyright\\s+((?:\\(C\\)|Â©)\\s+)?\\d{4}((-|,\\s)\\d{4})*`, which matches the following:\n\n- `Copyright 2023` - `Copyright (C) 2023` - `Copyright 2021-2023` - `Copyright (C) 2021-2023` - `Copyright (C) 2021, 2023`',
    )


class Flake8ErrMsgOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max_string_length: conint(ge=0) | None = Field(
        None,
        alias='max-string-length',
        description='Maximum string length for string literals in exception messages.',
    )


class Flake8GetTextOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    extend_function_names: List[str] | None = Field(
        None,
        alias='extend-function-names',
        description='Additional function names to consider as internationalization calls, in addition to those included in [`function-names`](#lint_flake8-gettext_function-names).',
    )
    function_names: List[str] | None = Field(
        None,
        alias='function-names',
        description='The function names to consider as internationalization calls.',
    )


class Flake8ImplicitStrConcatOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allow_multiline: bool | None = Field(
        None,
        alias='allow-multiline',
        description='Whether to allow implicit string concatenations for multiline strings. By default, implicit concatenations of multiline strings are allowed (but continuation lines, delimited with a backslash, are prohibited).\n\nSetting `allow-multiline = false` will automatically disable the `explicit-string-concatenation` (`ISC003`) rule. Otherwise, both implicit and explicit multiline string concatenations would be seen as violations, making it impossible to write a linter-compliant multiline string.',
    )


class Flake8ImportConventionsOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    aliases: Dict[str, Any] | None = Field(
        None,
        description='The conventional aliases for imports. These aliases can be extended by the [`extend-aliases`](#lint_flake8-import-conventions_extend-aliases) option.',
    )
    banned_aliases: Dict[str, Any] | None = Field(
        None,
        alias='banned-aliases',
        description='A mapping from module to its banned import aliases.',
    )
    banned_from: List[str] | None = Field(
        None,
        alias='banned-from',
        description='A list of modules that should not be imported from using the `from ... import ...` syntax.\n\nFor example, given `banned-from = ["pandas"]`, `from pandas import DataFrame` would be disallowed, while `import pandas` would be allowed.',
    )
    extend_aliases: Dict[str, Any] | None = Field(
        None,
        alias='extend-aliases',
        description='A mapping from module to conventional import alias. These aliases will be added to the [`aliases`](#lint_flake8-import-conventions_aliases) mapping.',
    )


class Flake8SelfOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    extend_ignore_names: List[str] | None = Field(
        None,
        alias='extend-ignore-names',
        description='Additional names to ignore when considering `flake8-self` violations, in addition to those included in [`ignore-names`](#lint_flake8-self_ignore-names).',
    )
    ignore_names: List[str] | None = Field(
        None,
        alias='ignore-names',
        description='A list of names to ignore when considering `flake8-self` violations.',
    )


class Flake8TypeCheckingOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    exempt_modules: List[str] | None = Field(
        None,
        alias='exempt-modules',
        description='Exempt certain modules from needing to be moved into type-checking blocks.',
    )
    quote_annotations: bool | None = Field(
        None,
        alias='quote-annotations',
        description='Whether to add quotes around type annotations, if doing so would allow the corresponding import to be moved into a type-checking block.\n\nFor example, in the following, Python requires that `Sequence` be available at runtime, despite the fact that it\'s only used in a type annotation:\n\n```python from collections.abc import Sequence\n\ndef func(value: Sequence[int]) -> None: ... ```\n\nIn other words, moving `from collections.abc import Sequence` into an `if TYPE_CHECKING:` block above would cause a runtime error, as the type would no longer be available at runtime.\n\nBy default, Ruff will respect such runtime semantics and avoid moving the import to prevent such runtime errors.\n\nSetting `quote-annotations` to `true` will instruct Ruff to add quotes around the annotation (e.g., `"Sequence[int]"`), which in turn enables Ruff to move the import into an `if TYPE_CHECKING:` block, like so:\n\n```python from typing import TYPE_CHECKING\n\nif TYPE_CHECKING: from collections.abc import Sequence\n\ndef func(value: "Sequence[int]") -> None: ... ```\n\nNote that this setting has no effect when `from __future__ import annotations` is present, as `__future__` annotations are always treated equivalently to quoted annotations.',
    )
    runtime_evaluated_base_classes: List[str] | None = Field(
        None,
        alias='runtime-evaluated-base-classes',
        description='Exempt classes that list any of the enumerated classes as a base class from needing to be moved into type-checking blocks.\n\nCommon examples include Pydantic\'s `pydantic.DataModel` and SQLAlchemy\'s `sqlalchemy.orm.DeclarativeBase`, but can also support user-defined classes that inherit from those base classes. For example, if you define a common `DeclarativeBase` subclass that\'s used throughout your project (e.g., `class Base(DeclarativeBase) ...` in `base.py`), you can add it to this list (`runtime-evaluated-base-classes = ["base.Base"]`) to exempt models from being moved into type-checking blocks.',
    )
    runtime_evaluated_decorators: List[str] | None = Field(
        None,
        alias='runtime-evaluated-decorators',
        description="Exempt classes and functions decorated with any of the enumerated decorators from being moved into type-checking blocks.\n\nCommon examples include Pydantic's `@pydantic.validate_call` decorator (for functions) and attrs' `@attrs.define` decorator (for classes).",
    )
    strict: bool | None = Field(
        None,
        description="Enforce `TC001`, `TC002`, and `TC003` rules even when valid runtime imports are present for the same module.\n\nSee flake8-type-checking's [strict](https://github.com/snok/flake8-type-checking#strict) option.",
    )


class Flake8UnusedArgumentsOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ignore_variadic_names: bool | None = Field(
        None,
        alias='ignore-variadic-names',
        description='Whether to allow unused variadic arguments, like `*args` and `**kwargs`.',
    )


class ImportType(Enum):
    future = 'future'
    standard_library = 'standard-library'
    third_party = 'third-party'
    first_party = 'first-party'
    local_folder = 'local-folder'


class IndentStyle1(Enum):
    """Use tabs to indent code."""

    tab = 'tab'


class IndentStyle2(Enum):
    """Use [`IndentWidth`] spaces to indent code."""

    space = 'space'


class IndentStyle(RootModel[Union[IndentStyle1, IndentStyle2]]):
    root: IndentStyle1 | IndentStyle2


class IndentWidth(RootModel[conint(ge=1)]):
    root: conint(ge=1) = Field(..., description='The size of a tab.')


class LineEnding1(Enum):
    """The newline style is detected automatically on a file per file basis. Files with mixed line endings will be converted to the first detected line ending. Defaults to [`LineEnding::Lf`] for a files that contain no line endings."""

    auto = 'auto'


class LineEnding2(Enum):
    r"""Line endings will be converted to `\n` as is common on Unix."""

    lf = 'lf'


class LineEnding3(Enum):
    r"""Line endings will be converted to `\r\n` as is common on Windows."""

    cr_lf = 'cr-lf'


class LineEnding4(Enum):
    r"""Line endings will be converted to `\n` on Unix and `\r\n` on Windows."""

    native = 'native'


class LineEnding(RootModel[Union[LineEnding1, LineEnding2, LineEnding3, LineEnding4]]):
    root: LineEnding1 | LineEnding2 | LineEnding3 | LineEnding4


class LineLength(RootModel[conint(ge=1, le=320)]):
    root: conint(ge=1, le=320) = Field(
        ...,
        description='The length of a line of text that is considered too long.\n\nThe allowed range of values is 1..=320',
    )


class LineWidth(RootModel[conint(ge=1)]):
    root: conint(ge=1) = Field(
        ...,
        description='The maximum visual width to which the formatter should try to limit a line.',
    )


class McCabeOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    max_complexity: conint(ge=0) | None = Field(
        None,
        alias='max-complexity',
        description='The maximum McCabe complexity to allow before triggering `C901` errors.',
    )


class NameImports(RootModel[str]):
    root: str


class OutputFormat(Enum):
    concise = 'concise'
    full = 'full'
    json = 'json'
    json_lines = 'json-lines'
    junit = 'junit'
    grouped = 'grouped'
    github = 'github'
    gitlab = 'gitlab'
    pylint = 'pylint'
    rdjson = 'rdjson'
    azure = 'azure'
    sarif = 'sarif'


class ParametrizeNameType(Enum):
    csv = 'csv'
    tuple = 'tuple'
    list = 'list'


class ParametrizeValuesRowType(Enum):
    tuple = 'tuple'
    list = 'list'


class ParametrizeValuesType(Enum):
    tuple = 'tuple'
    list = 'list'


class Pep8NamingOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    classmethod_decorators: List[str] | None = Field(
        None,
        alias='classmethod-decorators',
        description='A list of decorators that, when applied to a method, indicate that the method should be treated as a class method (in addition to the builtin `@classmethod`).\n\nFor example, Ruff will expect that any method decorated by a decorator in this list takes a `cls` argument as its first argument.\n\nExpects to receive a list of fully-qualified names (e.g., `pydantic.validator`, rather than `validator`) or alternatively a plain name which is then matched against the last segment in case the decorator itself consists of a dotted name.',
    )
    extend_ignore_names: List[str] | None = Field(
        None,
        alias='extend-ignore-names',
        description='Additional names (or patterns) to ignore when considering `pep8-naming` violations, in addition to those included in [`ignore-names`](#lint_pep8-naming_ignore-names).\n\nSupports glob patterns. For example, to ignore all names starting with `test_` or ending with `_test`, you could use `ignore-names = ["test_*", "*_test"]`. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    ignore_names: List[str] | None = Field(
        None,
        alias='ignore-names',
        description='A list of names (or patterns) to ignore when considering `pep8-naming` violations.\n\nSupports glob patterns. For example, to ignore all names starting with `test_` or ending with `_test`, you could use `ignore-names = ["test_*", "*_test"]`. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    staticmethod_decorators: List[str] | None = Field(
        None,
        alias='staticmethod-decorators',
        description='A list of decorators that, when applied to a method, indicate that the method should be treated as a static method (in addition to the builtin `@staticmethod`).\n\nFor example, Ruff will expect that any method decorated by a decorator in this list has no `self` or `cls` argument.\n\nExpects to receive a list of fully-qualified names (e.g., `belay.Device.teardown`, rather than `teardown`) or alternatively a plain name which is then matched against the last segment in case the decorator itself consists of a dotted name.',
    )


class PyUpgradeOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    keep_runtime_typing: bool | None = Field(
        None,
        alias='keep-runtime-typing',
        description='Whether to avoid [PEP 585](https://peps.python.org/pep-0585/) (`List[int]` -> `list[int]`) and [PEP 604](https://peps.python.org/pep-0604/) (`Union[str, int]` -> `str | int`) rewrites even if a file imports `from __future__ import annotations`.\n\nThis setting is only applicable when the target Python version is below 3.9 and 3.10 respectively, and is most commonly used when working with libraries like Pydantic and FastAPI, which rely on the ability to parse type annotations at runtime. The use of `from __future__ import annotations` causes Python to treat the type annotations as strings, which typically allows for the use of language features that appear in later Python versions but are not yet supported by the current version (e.g., `str | int`). However, libraries that rely on runtime type annotations will break if the annotations are incompatible with the current Python version.\n\nFor example, while the following is valid Python 3.8 code due to the presence of `from __future__ import annotations`, the use of `str | int` prior to Python 3.10 will cause Pydantic to raise a `TypeError` at runtime:\n\n```python from __future__ import annotations\n\nimport pydantic\n\nclass Foo(pydantic.DataModel): bar: str | int ```',
    )


class PycodestyleOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ignore_overlong_task_comments: bool | None = Field(
        None,
        alias='ignore-overlong-task-comments',
        description='Whether line-length violations (`E501`) should be triggered for comments starting with [`task-tags`](#lint_task-tags) (by default: "TODO", "FIXME", and "XXX").',
    )
    max_doc_length: LineLength | None = Field(
        None,
        alias='max-doc-length',
        description='The maximum line length to allow for [`doc-line-too-long`](https://docs.astral.sh/ruff/rules/doc-line-too-long/) violations within documentation (`W505`), including standalone comments. By default, this is set to `null` which disables reporting violations.\n\nThe length is determined by the number of characters per line, except for lines containing Asian characters or emojis. For these lines, the [unicode width](https://unicode.org/reports/tr11/) of each character is added up to determine the length.\n\nSee the [`doc-line-too-long`](https://docs.astral.sh/ruff/rules/doc-line-too-long/) rule for more information.',
    )
    max_line_length: LineLength | None = Field(
        None,
        alias='max-line-length',
        description="The maximum line length to allow for [`line-too-long`](https://docs.astral.sh/ruff/rules/line-too-long/) violations. By default, this is set to the value of the [`line-length`](#line-length) option.\n\nUse this option when you want to detect extra-long lines that the formatter can't automatically split by setting `pycodestyle.line-length` to a value larger than [`line-length`](#line-length).\n\n```toml # The formatter wraps lines at a length of 88. line-length = 88\n\n[pycodestyle] # E501 reports lines that exceed the length of 100. max-line-length = 100 ```\n\nThe length is determined by the number of characters per line, except for lines containing East Asian characters or emojis. For these lines, the [unicode width](https://unicode.org/reports/tr11/) of each character is added up to determine the length.\n\nSee the [`line-too-long`](https://docs.astral.sh/ruff/rules/line-too-long/) rule for more information.",
    )


class PydocstyleOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    convention: Convention | None = Field(
        None,
        description='Whether to use Google-style, NumPy-style conventions, or the [PEP 257](https://peps.python.org/pep-0257/) defaults when analyzing docstring sections.\n\nEnabling a convention will disable all rules that are not included in the specified convention. As such, the intended workflow is to enable a convention and then selectively enable or disable any additional rules on top of it.\n\nFor example, to use Google-style conventions but avoid requiring documentation for every function parameter:\n\n```toml [tool.ruff.lint] # Enable all `pydocstyle` rules, limiting to those that adhere to the # Google convention via `convention = "google"`, below. select = ["D"]\n\n# On top of the Google convention, disable `D417`, which requires # documentation for every function parameter. ignore = ["D417"]\n\n[tool.ruff.lint.pydocstyle] convention = "google" ```\n\nTo enable an additional rule that\'s excluded from the convention, select the desired rule via its fully qualified rule code (e.g., `D400` instead of `D4` or `D40`):\n\n```toml [tool.ruff.lint] # Enable D400 on top of the Google convention. extend-select = ["D400"]\n\n[tool.ruff.lint.pydocstyle] convention = "google" ```',
    )
    ignore_decorators: List[str] | None = Field(
        None,
        alias='ignore-decorators',
        description='Ignore docstrings for functions or methods decorated with the specified fully-qualified decorators.',
    )
    property_decorators: List[str] | None = Field(
        None,
        alias='property-decorators',
        description='A list of decorators that, when applied to a method, indicate that the method should be treated as a property (in addition to the builtin `@property` and standard-library `@functools.cached_property`).\n\nFor example, Ruff will expect that any method decorated by a decorator in this list can use a non-imperative summary line.',
    )


class PyflakesOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowed_unused_imports: List[str] | None = Field(
        None,
        alias='allowed-unused-imports',
        description='A list of modules to ignore when considering unused imports.\n\nUsed to prevent violations for specific modules that are known to have side effects on import (e.g., `hvplot.pandas`).\n\nModules in this list are expected to be fully-qualified names (e.g., `hvplot.pandas`). Any submodule of a given module will also be ignored (e.g., given `hvplot`, `hvplot.pandas` will also be ignored).',
    )
    extend_generics: List[str] | None = Field(
        None,
        alias='extend-generics',
        description='Additional functions or classes to consider generic, such that any subscripts should be treated as type annotation (e.g., `ForeignKey` in `django.db.models.ForeignKey["User"]`.\n\nExpects to receive a list of fully-qualified names (e.g., `django.db.models.ForeignKey`, rather than `ForeignKey`).',
    )


class PylintOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allow_dunder_method_names: List[str] | None = Field(
        None,
        alias='allow-dunder-method-names',
        description='Dunder methods name to allow, in addition to the default set from the Python standard library (see `PLW3201`).',
    )
    allow_magic_value_types: List[ConstantType] | None = Field(
        None,
        alias='allow-magic-value-types',
        description='Constant types to ignore when used as "magic values" (see `PLR2004`).',
    )
    max_args: conint(ge=0) | None = Field(
        None,
        alias='max-args',
        description='Maximum number of arguments allowed for a function or method definition (see `PLR0913`).',
    )
    max_bool_expr: conint(ge=0) | None = Field(
        None,
        alias='max-bool-expr',
        description='Maximum number of Boolean expressions allowed within a single `if` statement (see `PLR0916`).',
    )
    max_branches: conint(ge=0) | None = Field(
        None,
        alias='max-branches',
        description='Maximum number of branches allowed for a function or method body (see `PLR0912`).',
    )
    max_locals: conint(ge=0) | None = Field(
        None,
        alias='max-locals',
        description='Maximum number of local variables allowed for a function or method body (see `PLR0914`).',
    )
    max_nested_blocks: conint(ge=0) | None = Field(
        None,
        alias='max-nested-blocks',
        description='Maximum number of nested blocks allowed within a function or method body (see `PLR1702`).',
    )
    max_positional_args: conint(ge=0) | None = Field(
        None,
        alias='max-positional-args',
        description='Maximum number of positional arguments allowed for a function or method definition (see `PLR0917`).\n\nIf not specified, defaults to the value of `max-args`.',
    )
    max_public_methods: conint(ge=0) | None = Field(
        None,
        alias='max-public-methods',
        description='Maximum number of public methods allowed for a class (see `PLR0904`).',
    )
    max_returns: conint(ge=0) | None = Field(
        None,
        alias='max-returns',
        description='Maximum number of return statements allowed for a function or method body (see `PLR0911`)',
    )
    max_statements: conint(ge=0) | None = Field(
        None,
        alias='max-statements',
        description='Maximum number of statements allowed for a function or method body (see `PLR0915`).',
    )


class PythonVersion(Enum):
    py37 = 'py37'
    py38 = 'py38'
    py39 = 'py39'
    py310 = 'py310'
    py311 = 'py311'
    py312 = 'py312'
    py313 = 'py313'


class Quote1(Enum):
    """Use double quotes."""

    double = 'double'


class Quote2(Enum):
    """Use single quotes."""

    single = 'single'


class Quote(RootModel[Union[Quote1, Quote2]]):
    root: Quote1 | Quote2


class QuoteStyle(Enum):
    single = 'single'
    double = 'double'
    preserve = 'preserve'


class RelativeImportsOrder1(Enum):
    """Place "closer" imports (fewer `.` characters, most local) before "further" imports (more `.` characters, least local)."""

    closest_to_furthest = 'closest-to-furthest'


class RelativeImportsOrder2(Enum):
    """Place "further" imports (more `.` characters, least local) imports before "closer" imports (fewer `.` characters, most local)."""

    furthest_to_closest = 'furthest-to-closest'


class RelativeImportsOrder(
    RootModel[Union[RelativeImportsOrder1, RelativeImportsOrder2]],
):
    root: RelativeImportsOrder1 | RelativeImportsOrder2


class RequiredVersion(RootModel[str]):
    root: str


class RuffOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    extend_markup_names: List[str] | None = Field(
        None,
        alias='extend-markup-names',
        description='A list of additional callable names that behave like [`markupsafe.Markup`].\n\nExpects to receive a list of fully-qualified names (e.g., `webhelpers.html.literal`, rather than `literal`).\n\n[markupsafe.Markup]: https://markupsafe.palletsprojects.com/en/stable/escaping/#markupsafe.Markup',
    )
    parenthesize_tuple_in_subscript: bool | None = Field(
        None,
        alias='parenthesize-tuple-in-subscript',
        description='Whether to prefer accessing items keyed by tuples with parentheses around the tuple (see `RUF031`).',
    )


class RuleSelector(Enum):
    A = 'A'
    A0 = 'A0'
    A00 = 'A00'
    A001 = 'A001'
    A002 = 'A002'
    A003 = 'A003'
    A004 = 'A004'
    A005 = 'A005'
    A006 = 'A006'
    AIR = 'AIR'
    AIR0 = 'AIR0'
    AIR00 = 'AIR00'
    AIR001 = 'AIR001'
    ALL = 'ALL'
    ANN = 'ANN'
    ANN0 = 'ANN0'
    ANN00 = 'ANN00'
    ANN001 = 'ANN001'
    ANN002 = 'ANN002'
    ANN003 = 'ANN003'
    ANN1 = 'ANN1'
    ANN10 = 'ANN10'
    ANN101 = 'ANN101'
    ANN102 = 'ANN102'
    ANN2 = 'ANN2'
    ANN20 = 'ANN20'
    ANN201 = 'ANN201'
    ANN202 = 'ANN202'
    ANN204 = 'ANN204'
    ANN205 = 'ANN205'
    ANN206 = 'ANN206'
    ANN4 = 'ANN4'
    ANN40 = 'ANN40'
    ANN401 = 'ANN401'
    ARG = 'ARG'
    ARG0 = 'ARG0'
    ARG00 = 'ARG00'
    ARG001 = 'ARG001'
    ARG002 = 'ARG002'
    ARG003 = 'ARG003'
    ARG004 = 'ARG004'
    ARG005 = 'ARG005'
    ASYNC = 'ASYNC'
    ASYNC1 = 'ASYNC1'
    ASYNC10 = 'ASYNC10'
    ASYNC100 = 'ASYNC100'
    ASYNC105 = 'ASYNC105'
    ASYNC109 = 'ASYNC109'
    ASYNC11 = 'ASYNC11'
    ASYNC110 = 'ASYNC110'
    ASYNC115 = 'ASYNC115'
    ASYNC116 = 'ASYNC116'
    ASYNC2 = 'ASYNC2'
    ASYNC21 = 'ASYNC21'
    ASYNC210 = 'ASYNC210'
    ASYNC22 = 'ASYNC22'
    ASYNC220 = 'ASYNC220'
    ASYNC221 = 'ASYNC221'
    ASYNC222 = 'ASYNC222'
    ASYNC23 = 'ASYNC23'
    ASYNC230 = 'ASYNC230'
    ASYNC25 = 'ASYNC25'
    ASYNC251 = 'ASYNC251'
    B = 'B'
    B0 = 'B0'
    B00 = 'B00'
    B002 = 'B002'
    B003 = 'B003'
    B004 = 'B004'
    B005 = 'B005'
    B006 = 'B006'
    B007 = 'B007'
    B008 = 'B008'
    B009 = 'B009'
    B01 = 'B01'
    B010 = 'B010'
    B011 = 'B011'
    B012 = 'B012'
    B013 = 'B013'
    B014 = 'B014'
    B015 = 'B015'
    B016 = 'B016'
    B017 = 'B017'
    B018 = 'B018'
    B019 = 'B019'
    B02 = 'B02'
    B020 = 'B020'
    B021 = 'B021'
    B022 = 'B022'
    B023 = 'B023'
    B024 = 'B024'
    B025 = 'B025'
    B026 = 'B026'
    B027 = 'B027'
    B028 = 'B028'
    B029 = 'B029'
    B03 = 'B03'
    B030 = 'B030'
    B031 = 'B031'
    B032 = 'B032'
    B033 = 'B033'
    B034 = 'B034'
    B035 = 'B035'
    B039 = 'B039'
    B9 = 'B9'
    B90 = 'B90'
    B901 = 'B901'
    B904 = 'B904'
    B905 = 'B905'
    B909 = 'B909'
    BLE = 'BLE'
    BLE0 = 'BLE0'
    BLE00 = 'BLE00'
    BLE001 = 'BLE001'
    C = 'C'
    C4 = 'C4'
    C40 = 'C40'
    C400 = 'C400'
    C401 = 'C401'
    C402 = 'C402'
    C403 = 'C403'
    C404 = 'C404'
    C405 = 'C405'
    C406 = 'C406'
    C408 = 'C408'
    C409 = 'C409'
    C41 = 'C41'
    C410 = 'C410'
    C411 = 'C411'
    C413 = 'C413'
    C414 = 'C414'
    C415 = 'C415'
    C416 = 'C416'
    C417 = 'C417'
    C418 = 'C418'
    C419 = 'C419'
    C42 = 'C42'
    C420 = 'C420'
    C9 = 'C9'
    C90 = 'C90'
    C901 = 'C901'
    COM = 'COM'
    COM8 = 'COM8'
    COM81 = 'COM81'
    COM812 = 'COM812'
    COM818 = 'COM818'
    COM819 = 'COM819'
    CPY = 'CPY'
    CPY0 = 'CPY0'
    CPY00 = 'CPY00'
    CPY001 = 'CPY001'
    D = 'D'
    D1 = 'D1'
    D10 = 'D10'
    D100 = 'D100'
    D101 = 'D101'
    D102 = 'D102'
    D103 = 'D103'
    D104 = 'D104'
    D105 = 'D105'
    D106 = 'D106'
    D107 = 'D107'
    D2 = 'D2'
    D20 = 'D20'
    D200 = 'D200'
    D201 = 'D201'
    D202 = 'D202'
    D203 = 'D203'
    D204 = 'D204'
    D205 = 'D205'
    D206 = 'D206'
    D207 = 'D207'
    D208 = 'D208'
    D209 = 'D209'
    D21 = 'D21'
    D210 = 'D210'
    D211 = 'D211'
    D212 = 'D212'
    D213 = 'D213'
    D214 = 'D214'
    D215 = 'D215'
    D3 = 'D3'
    D30 = 'D30'
    D300 = 'D300'
    D301 = 'D301'
    D4 = 'D4'
    D40 = 'D40'
    D400 = 'D400'
    D401 = 'D401'
    D402 = 'D402'
    D403 = 'D403'
    D404 = 'D404'
    D405 = 'D405'
    D406 = 'D406'
    D407 = 'D407'
    D408 = 'D408'
    D409 = 'D409'
    D41 = 'D41'
    D410 = 'D410'
    D411 = 'D411'
    D412 = 'D412'
    D413 = 'D413'
    D414 = 'D414'
    D415 = 'D415'
    D416 = 'D416'
    D417 = 'D417'
    D418 = 'D418'
    D419 = 'D419'
    DJ = 'DJ'
    DJ0 = 'DJ0'
    DJ00 = 'DJ00'
    DJ001 = 'DJ001'
    DJ003 = 'DJ003'
    DJ006 = 'DJ006'
    DJ007 = 'DJ007'
    DJ008 = 'DJ008'
    DJ01 = 'DJ01'
    DJ012 = 'DJ012'
    DJ013 = 'DJ013'
    DOC = 'DOC'
    DOC2 = 'DOC2'
    DOC20 = 'DOC20'
    DOC201 = 'DOC201'
    DOC202 = 'DOC202'
    DOC4 = 'DOC4'
    DOC40 = 'DOC40'
    DOC402 = 'DOC402'
    DOC403 = 'DOC403'
    DOC5 = 'DOC5'
    DOC50 = 'DOC50'
    DOC501 = 'DOC501'
    DOC502 = 'DOC502'
    DTZ = 'DTZ'
    DTZ0 = 'DTZ0'
    DTZ00 = 'DTZ00'
    DTZ001 = 'DTZ001'
    DTZ002 = 'DTZ002'
    DTZ003 = 'DTZ003'
    DTZ004 = 'DTZ004'
    DTZ005 = 'DTZ005'
    DTZ006 = 'DTZ006'
    DTZ007 = 'DTZ007'
    DTZ01 = 'DTZ01'
    DTZ011 = 'DTZ011'
    DTZ012 = 'DTZ012'
    DTZ9 = 'DTZ9'
    DTZ90 = 'DTZ90'
    DTZ901 = 'DTZ901'
    E = 'E'
    E1 = 'E1'
    E10 = 'E10'
    E101 = 'E101'
    E11 = 'E11'
    E111 = 'E111'
    E112 = 'E112'
    E113 = 'E113'
    E114 = 'E114'
    E115 = 'E115'
    E116 = 'E116'
    E117 = 'E117'
    E2 = 'E2'
    E20 = 'E20'
    E201 = 'E201'
    E202 = 'E202'
    E203 = 'E203'
    E204 = 'E204'
    E21 = 'E21'
    E211 = 'E211'
    E22 = 'E22'
    E221 = 'E221'
    E222 = 'E222'
    E223 = 'E223'
    E224 = 'E224'
    E225 = 'E225'
    E226 = 'E226'
    E227 = 'E227'
    E228 = 'E228'
    E23 = 'E23'
    E231 = 'E231'
    E24 = 'E24'
    E241 = 'E241'
    E242 = 'E242'
    E25 = 'E25'
    E251 = 'E251'
    E252 = 'E252'
    E26 = 'E26'
    E261 = 'E261'
    E262 = 'E262'
    E265 = 'E265'
    E266 = 'E266'
    E27 = 'E27'
    E271 = 'E271'
    E272 = 'E272'
    E273 = 'E273'
    E274 = 'E274'
    E275 = 'E275'
    E3 = 'E3'
    E30 = 'E30'
    E301 = 'E301'
    E302 = 'E302'
    E303 = 'E303'
    E304 = 'E304'
    E305 = 'E305'
    E306 = 'E306'
    E4 = 'E4'
    E40 = 'E40'
    E401 = 'E401'
    E402 = 'E402'
    E5 = 'E5'
    E50 = 'E50'
    E501 = 'E501'
    E502 = 'E502'
    E7 = 'E7'
    E70 = 'E70'
    E701 = 'E701'
    E702 = 'E702'
    E703 = 'E703'
    E71 = 'E71'
    E711 = 'E711'
    E712 = 'E712'
    E713 = 'E713'
    E714 = 'E714'
    E72 = 'E72'
    E721 = 'E721'
    E722 = 'E722'
    E73 = 'E73'
    E731 = 'E731'
    E74 = 'E74'
    E741 = 'E741'
    E742 = 'E742'
    E743 = 'E743'
    E9 = 'E9'
    E90 = 'E90'
    E902 = 'E902'
    E99 = 'E99'
    E999 = 'E999'
    EM = 'EM'
    EM1 = 'EM1'
    EM10 = 'EM10'
    EM101 = 'EM101'
    EM102 = 'EM102'
    EM103 = 'EM103'
    ERA = 'ERA'
    ERA0 = 'ERA0'
    ERA00 = 'ERA00'
    ERA001 = 'ERA001'
    EXE = 'EXE'
    EXE0 = 'EXE0'
    EXE00 = 'EXE00'
    EXE001 = 'EXE001'
    EXE002 = 'EXE002'
    EXE003 = 'EXE003'
    EXE004 = 'EXE004'
    EXE005 = 'EXE005'
    F = 'F'
    F4 = 'F4'
    F40 = 'F40'
    F401 = 'F401'
    F402 = 'F402'
    F403 = 'F403'
    F404 = 'F404'
    F405 = 'F405'
    F406 = 'F406'
    F407 = 'F407'
    F5 = 'F5'
    F50 = 'F50'
    F501 = 'F501'
    F502 = 'F502'
    F503 = 'F503'
    F504 = 'F504'
    F505 = 'F505'
    F506 = 'F506'
    F507 = 'F507'
    F508 = 'F508'
    F509 = 'F509'
    F52 = 'F52'
    F521 = 'F521'
    F522 = 'F522'
    F523 = 'F523'
    F524 = 'F524'
    F525 = 'F525'
    F54 = 'F54'
    F541 = 'F541'
    F6 = 'F6'
    F60 = 'F60'
    F601 = 'F601'
    F602 = 'F602'
    F62 = 'F62'
    F621 = 'F621'
    F622 = 'F622'
    F63 = 'F63'
    F631 = 'F631'
    F632 = 'F632'
    F633 = 'F633'
    F634 = 'F634'
    F7 = 'F7'
    F70 = 'F70'
    F701 = 'F701'
    F702 = 'F702'
    F704 = 'F704'
    F706 = 'F706'
    F707 = 'F707'
    F72 = 'F72'
    F722 = 'F722'
    F8 = 'F8'
    F81 = 'F81'
    F811 = 'F811'
    F82 = 'F82'
    F821 = 'F821'
    F822 = 'F822'
    F823 = 'F823'
    F84 = 'F84'
    F841 = 'F841'
    F842 = 'F842'
    F9 = 'F9'
    F90 = 'F90'
    F901 = 'F901'
    FA = 'FA'
    FA1 = 'FA1'
    FA10 = 'FA10'
    FA100 = 'FA100'
    FA102 = 'FA102'
    FAST = 'FAST'
    FAST0 = 'FAST0'
    FAST00 = 'FAST00'
    FAST001 = 'FAST001'
    FAST002 = 'FAST002'
    FAST003 = 'FAST003'
    FBT = 'FBT'
    FBT0 = 'FBT0'
    FBT00 = 'FBT00'
    FBT001 = 'FBT001'
    FBT002 = 'FBT002'
    FBT003 = 'FBT003'
    FIX = 'FIX'
    FIX0 = 'FIX0'
    FIX00 = 'FIX00'
    FIX001 = 'FIX001'
    FIX002 = 'FIX002'
    FIX003 = 'FIX003'
    FIX004 = 'FIX004'
    FLY = 'FLY'
    FLY0 = 'FLY0'
    FLY00 = 'FLY00'
    FLY002 = 'FLY002'
    FURB = 'FURB'
    FURB1 = 'FURB1'
    FURB10 = 'FURB10'
    FURB101 = 'FURB101'
    FURB103 = 'FURB103'
    FURB105 = 'FURB105'
    FURB11 = 'FURB11'
    FURB110 = 'FURB110'
    FURB113 = 'FURB113'
    FURB116 = 'FURB116'
    FURB118 = 'FURB118'
    FURB12 = 'FURB12'
    FURB129 = 'FURB129'
    FURB13 = 'FURB13'
    FURB131 = 'FURB131'
    FURB132 = 'FURB132'
    FURB136 = 'FURB136'
    FURB14 = 'FURB14'
    FURB140 = 'FURB140'
    FURB142 = 'FURB142'
    FURB145 = 'FURB145'
    FURB148 = 'FURB148'
    FURB15 = 'FURB15'
    FURB152 = 'FURB152'
    FURB154 = 'FURB154'
    FURB156 = 'FURB156'
    FURB157 = 'FURB157'
    FURB16 = 'FURB16'
    FURB161 = 'FURB161'
    FURB163 = 'FURB163'
    FURB164 = 'FURB164'
    FURB166 = 'FURB166'
    FURB167 = 'FURB167'
    FURB168 = 'FURB168'
    FURB169 = 'FURB169'
    FURB17 = 'FURB17'
    FURB171 = 'FURB171'
    FURB177 = 'FURB177'
    FURB18 = 'FURB18'
    FURB180 = 'FURB180'
    FURB181 = 'FURB181'
    FURB187 = 'FURB187'
    FURB188 = 'FURB188'
    FURB189 = 'FURB189'
    FURB19 = 'FURB19'
    FURB192 = 'FURB192'
    G = 'G'
    G0 = 'G0'
    G00 = 'G00'
    G001 = 'G001'
    G002 = 'G002'
    G003 = 'G003'
    G004 = 'G004'
    G01 = 'G01'
    G010 = 'G010'
    G1 = 'G1'
    G10 = 'G10'
    G101 = 'G101'
    G2 = 'G2'
    G20 = 'G20'
    G201 = 'G201'
    G202 = 'G202'
    I = 'I'
    I0 = 'I0'
    I00 = 'I00'
    I001 = 'I001'
    I002 = 'I002'
    ICN = 'ICN'
    ICN0 = 'ICN0'
    ICN00 = 'ICN00'
    ICN001 = 'ICN001'
    ICN002 = 'ICN002'
    ICN003 = 'ICN003'
    INP = 'INP'
    INP0 = 'INP0'
    INP00 = 'INP00'
    INP001 = 'INP001'
    INT = 'INT'
    INT0 = 'INT0'
    INT00 = 'INT00'
    INT001 = 'INT001'
    INT002 = 'INT002'
    INT003 = 'INT003'
    ISC = 'ISC'
    ISC0 = 'ISC0'
    ISC00 = 'ISC00'
    ISC001 = 'ISC001'
    ISC002 = 'ISC002'
    ISC003 = 'ISC003'
    LOG = 'LOG'
    LOG0 = 'LOG0'
    LOG00 = 'LOG00'
    LOG001 = 'LOG001'
    LOG002 = 'LOG002'
    LOG007 = 'LOG007'
    LOG009 = 'LOG009'
    LOG01 = 'LOG01'
    LOG015 = 'LOG015'
    N = 'N'
    N8 = 'N8'
    N80 = 'N80'
    N801 = 'N801'
    N802 = 'N802'
    N803 = 'N803'
    N804 = 'N804'
    N805 = 'N805'
    N806 = 'N806'
    N807 = 'N807'
    N81 = 'N81'
    N811 = 'N811'
    N812 = 'N812'
    N813 = 'N813'
    N814 = 'N814'
    N815 = 'N815'
    N816 = 'N816'
    N817 = 'N817'
    N818 = 'N818'
    N9 = 'N9'
    N99 = 'N99'
    N999 = 'N999'
    NPY = 'NPY'
    NPY0 = 'NPY0'
    NPY00 = 'NPY00'
    NPY001 = 'NPY001'
    NPY002 = 'NPY002'
    NPY003 = 'NPY003'
    NPY2 = 'NPY2'
    NPY20 = 'NPY20'
    NPY201 = 'NPY201'
    PD = 'PD'
    PD0 = 'PD0'
    PD00 = 'PD00'
    PD002 = 'PD002'
    PD003 = 'PD003'
    PD004 = 'PD004'
    PD007 = 'PD007'
    PD008 = 'PD008'
    PD009 = 'PD009'
    PD01 = 'PD01'
    PD010 = 'PD010'
    PD011 = 'PD011'
    PD012 = 'PD012'
    PD013 = 'PD013'
    PD015 = 'PD015'
    PD1 = 'PD1'
    PD10 = 'PD10'
    PD101 = 'PD101'
    PD9 = 'PD9'
    PD90 = 'PD90'
    PD901 = 'PD901'
    PERF = 'PERF'
    PERF1 = 'PERF1'
    PERF10 = 'PERF10'
    PERF101 = 'PERF101'
    PERF102 = 'PERF102'
    PERF2 = 'PERF2'
    PERF20 = 'PERF20'
    PERF203 = 'PERF203'
    PERF4 = 'PERF4'
    PERF40 = 'PERF40'
    PERF401 = 'PERF401'
    PERF402 = 'PERF402'
    PERF403 = 'PERF403'
    PGH = 'PGH'
    PGH0 = 'PGH0'
    PGH00 = 'PGH00'
    PGH003 = 'PGH003'
    PGH004 = 'PGH004'
    PGH005 = 'PGH005'
    PIE = 'PIE'
    PIE7 = 'PIE7'
    PIE79 = 'PIE79'
    PIE790 = 'PIE790'
    PIE794 = 'PIE794'
    PIE796 = 'PIE796'
    PIE8 = 'PIE8'
    PIE80 = 'PIE80'
    PIE800 = 'PIE800'
    PIE804 = 'PIE804'
    PIE807 = 'PIE807'
    PIE808 = 'PIE808'
    PIE81 = 'PIE81'
    PIE810 = 'PIE810'
    PL = 'PL'
    PLC = 'PLC'
    PLC0 = 'PLC0'
    PLC01 = 'PLC01'
    PLC010 = 'PLC010'
    PLC0105 = 'PLC0105'
    PLC013 = 'PLC013'
    PLC0131 = 'PLC0131'
    PLC0132 = 'PLC0132'
    PLC02 = 'PLC02'
    PLC020 = 'PLC020'
    PLC0205 = 'PLC0205'
    PLC0206 = 'PLC0206'
    PLC0208 = 'PLC0208'
    PLC04 = 'PLC04'
    PLC041 = 'PLC041'
    PLC0414 = 'PLC0414'
    PLC0415 = 'PLC0415'
    PLC1 = 'PLC1'
    PLC19 = 'PLC19'
    PLC190 = 'PLC190'
    PLC1901 = 'PLC1901'
    PLC2 = 'PLC2'
    PLC24 = 'PLC24'
    PLC240 = 'PLC240'
    PLC2401 = 'PLC2401'
    PLC2403 = 'PLC2403'
    PLC27 = 'PLC27'
    PLC270 = 'PLC270'
    PLC2701 = 'PLC2701'
    PLC28 = 'PLC28'
    PLC280 = 'PLC280'
    PLC2801 = 'PLC2801'
    PLC3 = 'PLC3'
    PLC30 = 'PLC30'
    PLC300 = 'PLC300'
    PLC3002 = 'PLC3002'
    PLE = 'PLE'
    PLE0 = 'PLE0'
    PLE01 = 'PLE01'
    PLE010 = 'PLE010'
    PLE0100 = 'PLE0100'
    PLE0101 = 'PLE0101'
    PLE011 = 'PLE011'
    PLE0115 = 'PLE0115'
    PLE0116 = 'PLE0116'
    PLE0117 = 'PLE0117'
    PLE0118 = 'PLE0118'
    PLE02 = 'PLE02'
    PLE023 = 'PLE023'
    PLE0237 = 'PLE0237'
    PLE024 = 'PLE024'
    PLE0241 = 'PLE0241'
    PLE03 = 'PLE03'
    PLE030 = 'PLE030'
    PLE0302 = 'PLE0302'
    PLE0303 = 'PLE0303'
    PLE0304 = 'PLE0304'
    PLE0305 = 'PLE0305'
    PLE0307 = 'PLE0307'
    PLE0308 = 'PLE0308'
    PLE0309 = 'PLE0309'
    PLE06 = 'PLE06'
    PLE060 = 'PLE060'
    PLE0604 = 'PLE0604'
    PLE0605 = 'PLE0605'
    PLE064 = 'PLE064'
    PLE0643 = 'PLE0643'
    PLE07 = 'PLE07'
    PLE070 = 'PLE070'
    PLE0704 = 'PLE0704'
    PLE1 = 'PLE1'
    PLE11 = 'PLE11'
    PLE113 = 'PLE113'
    PLE1132 = 'PLE1132'
    PLE114 = 'PLE114'
    PLE1141 = 'PLE1141'
    PLE1142 = 'PLE1142'
    PLE12 = 'PLE12'
    PLE120 = 'PLE120'
    PLE1205 = 'PLE1205'
    PLE1206 = 'PLE1206'
    PLE13 = 'PLE13'
    PLE130 = 'PLE130'
    PLE1300 = 'PLE1300'
    PLE1307 = 'PLE1307'
    PLE131 = 'PLE131'
    PLE1310 = 'PLE1310'
    PLE15 = 'PLE15'
    PLE150 = 'PLE150'
    PLE1507 = 'PLE1507'
    PLE151 = 'PLE151'
    PLE1519 = 'PLE1519'
    PLE152 = 'PLE152'
    PLE1520 = 'PLE1520'
    PLE17 = 'PLE17'
    PLE170 = 'PLE170'
    PLE1700 = 'PLE1700'
    PLE2 = 'PLE2'
    PLE25 = 'PLE25'
    PLE250 = 'PLE250'
    PLE2502 = 'PLE2502'
    PLE251 = 'PLE251'
    PLE2510 = 'PLE2510'
    PLE2512 = 'PLE2512'
    PLE2513 = 'PLE2513'
    PLE2514 = 'PLE2514'
    PLE2515 = 'PLE2515'
    PLE4 = 'PLE4'
    PLE47 = 'PLE47'
    PLE470 = 'PLE470'
    PLE4703 = 'PLE4703'
    PLR = 'PLR'
    PLR0 = 'PLR0'
    PLR01 = 'PLR01'
    PLR012 = 'PLR012'
    PLR0124 = 'PLR0124'
    PLR013 = 'PLR013'
    PLR0133 = 'PLR0133'
    PLR02 = 'PLR02'
    PLR020 = 'PLR020'
    PLR0202 = 'PLR0202'
    PLR0203 = 'PLR0203'
    PLR0206 = 'PLR0206'
    PLR04 = 'PLR04'
    PLR040 = 'PLR040'
    PLR0402 = 'PLR0402'
    PLR09 = 'PLR09'
    PLR090 = 'PLR090'
    PLR0904 = 'PLR0904'
    PLR091 = 'PLR091'
    PLR0911 = 'PLR0911'
    PLR0912 = 'PLR0912'
    PLR0913 = 'PLR0913'
    PLR0914 = 'PLR0914'
    PLR0915 = 'PLR0915'
    PLR0916 = 'PLR0916'
    PLR0917 = 'PLR0917'
    PLR1 = 'PLR1'
    PLR17 = 'PLR17'
    PLR170 = 'PLR170'
    PLR1702 = 'PLR1702'
    PLR1704 = 'PLR1704'
    PLR171 = 'PLR171'
    PLR1711 = 'PLR1711'
    PLR1714 = 'PLR1714'
    PLR1716 = 'PLR1716'
    PLR172 = 'PLR172'
    PLR1722 = 'PLR1722'
    PLR173 = 'PLR173'
    PLR1730 = 'PLR1730'
    PLR1733 = 'PLR1733'
    PLR1736 = 'PLR1736'
    PLR2 = 'PLR2'
    PLR20 = 'PLR20'
    PLR200 = 'PLR200'
    PLR2004 = 'PLR2004'
    PLR204 = 'PLR204'
    PLR2044 = 'PLR2044'
    PLR5 = 'PLR5'
    PLR55 = 'PLR55'
    PLR550 = 'PLR550'
    PLR5501 = 'PLR5501'
    PLR6 = 'PLR6'
    PLR61 = 'PLR61'
    PLR610 = 'PLR610'
    PLR6104 = 'PLR6104'
    PLR62 = 'PLR62'
    PLR620 = 'PLR620'
    PLR6201 = 'PLR6201'
    PLR63 = 'PLR63'
    PLR630 = 'PLR630'
    PLR6301 = 'PLR6301'
    PLW = 'PLW'
    PLW0 = 'PLW0'
    PLW01 = 'PLW01'
    PLW010 = 'PLW010'
    PLW0108 = 'PLW0108'
    PLW012 = 'PLW012'
    PLW0120 = 'PLW0120'
    PLW0127 = 'PLW0127'
    PLW0128 = 'PLW0128'
    PLW0129 = 'PLW0129'
    PLW013 = 'PLW013'
    PLW0131 = 'PLW0131'
    PLW0133 = 'PLW0133'
    PLW017 = 'PLW017'
    PLW0177 = 'PLW0177'
    PLW02 = 'PLW02'
    PLW021 = 'PLW021'
    PLW0211 = 'PLW0211'
    PLW024 = 'PLW024'
    PLW0245 = 'PLW0245'
    PLW04 = 'PLW04'
    PLW040 = 'PLW040'
    PLW0406 = 'PLW0406'
    PLW06 = 'PLW06'
    PLW060 = 'PLW060'
    PLW0602 = 'PLW0602'
    PLW0603 = 'PLW0603'
    PLW0604 = 'PLW0604'
    PLW064 = 'PLW064'
    PLW0642 = 'PLW0642'
    PLW07 = 'PLW07'
    PLW071 = 'PLW071'
    PLW0711 = 'PLW0711'
    PLW1 = 'PLW1'
    PLW15 = 'PLW15'
    PLW150 = 'PLW150'
    PLW1501 = 'PLW1501'
    PLW1507 = 'PLW1507'
    PLW1508 = 'PLW1508'
    PLW1509 = 'PLW1509'
    PLW151 = 'PLW151'
    PLW1510 = 'PLW1510'
    PLW1514 = 'PLW1514'
    PLW16 = 'PLW16'
    PLW164 = 'PLW164'
    PLW1641 = 'PLW1641'
    PLW2 = 'PLW2'
    PLW21 = 'PLW21'
    PLW210 = 'PLW210'
    PLW2101 = 'PLW2101'
    PLW29 = 'PLW29'
    PLW290 = 'PLW290'
    PLW2901 = 'PLW2901'
    PLW3 = 'PLW3'
    PLW32 = 'PLW32'
    PLW320 = 'PLW320'
    PLW3201 = 'PLW3201'
    PLW33 = 'PLW33'
    PLW330 = 'PLW330'
    PLW3301 = 'PLW3301'
    PT = 'PT'
    PT0 = 'PT0'
    PT00 = 'PT00'
    PT001 = 'PT001'
    PT002 = 'PT002'
    PT003 = 'PT003'
    PT004 = 'PT004'
    PT005 = 'PT005'
    PT006 = 'PT006'
    PT007 = 'PT007'
    PT008 = 'PT008'
    PT009 = 'PT009'
    PT01 = 'PT01'
    PT010 = 'PT010'
    PT011 = 'PT011'
    PT012 = 'PT012'
    PT013 = 'PT013'
    PT014 = 'PT014'
    PT015 = 'PT015'
    PT016 = 'PT016'
    PT017 = 'PT017'
    PT018 = 'PT018'
    PT019 = 'PT019'
    PT02 = 'PT02'
    PT020 = 'PT020'
    PT021 = 'PT021'
    PT022 = 'PT022'
    PT023 = 'PT023'
    PT024 = 'PT024'
    PT025 = 'PT025'
    PT026 = 'PT026'
    PT027 = 'PT027'
    PTH = 'PTH'
    PTH1 = 'PTH1'
    PTH10 = 'PTH10'
    PTH100 = 'PTH100'
    PTH101 = 'PTH101'
    PTH102 = 'PTH102'
    PTH103 = 'PTH103'
    PTH104 = 'PTH104'
    PTH105 = 'PTH105'
    PTH106 = 'PTH106'
    PTH107 = 'PTH107'
    PTH108 = 'PTH108'
    PTH109 = 'PTH109'
    PTH11 = 'PTH11'
    PTH110 = 'PTH110'
    PTH111 = 'PTH111'
    PTH112 = 'PTH112'
    PTH113 = 'PTH113'
    PTH114 = 'PTH114'
    PTH115 = 'PTH115'
    PTH116 = 'PTH116'
    PTH117 = 'PTH117'
    PTH118 = 'PTH118'
    PTH119 = 'PTH119'
    PTH12 = 'PTH12'
    PTH120 = 'PTH120'
    PTH121 = 'PTH121'
    PTH122 = 'PTH122'
    PTH123 = 'PTH123'
    PTH124 = 'PTH124'
    PTH2 = 'PTH2'
    PTH20 = 'PTH20'
    PTH201 = 'PTH201'
    PTH202 = 'PTH202'
    PTH203 = 'PTH203'
    PTH204 = 'PTH204'
    PTH205 = 'PTH205'
    PTH206 = 'PTH206'
    PTH207 = 'PTH207'
    PYI = 'PYI'
    PYI0 = 'PYI0'
    PYI00 = 'PYI00'
    PYI001 = 'PYI001'
    PYI002 = 'PYI002'
    PYI003 = 'PYI003'
    PYI004 = 'PYI004'
    PYI005 = 'PYI005'
    PYI006 = 'PYI006'
    PYI007 = 'PYI007'
    PYI008 = 'PYI008'
    PYI009 = 'PYI009'
    PYI01 = 'PYI01'
    PYI010 = 'PYI010'
    PYI011 = 'PYI011'
    PYI012 = 'PYI012'
    PYI013 = 'PYI013'
    PYI014 = 'PYI014'
    PYI015 = 'PYI015'
    PYI016 = 'PYI016'
    PYI017 = 'PYI017'
    PYI018 = 'PYI018'
    PYI019 = 'PYI019'
    PYI02 = 'PYI02'
    PYI020 = 'PYI020'
    PYI021 = 'PYI021'
    PYI024 = 'PYI024'
    PYI025 = 'PYI025'
    PYI026 = 'PYI026'
    PYI029 = 'PYI029'
    PYI03 = 'PYI03'
    PYI030 = 'PYI030'
    PYI032 = 'PYI032'
    PYI033 = 'PYI033'
    PYI034 = 'PYI034'
    PYI035 = 'PYI035'
    PYI036 = 'PYI036'
    PYI04 = 'PYI04'
    PYI041 = 'PYI041'
    PYI042 = 'PYI042'
    PYI043 = 'PYI043'
    PYI044 = 'PYI044'
    PYI045 = 'PYI045'
    PYI046 = 'PYI046'
    PYI047 = 'PYI047'
    PYI048 = 'PYI048'
    PYI049 = 'PYI049'
    PYI05 = 'PYI05'
    PYI050 = 'PYI050'
    PYI051 = 'PYI051'
    PYI052 = 'PYI052'
    PYI053 = 'PYI053'
    PYI054 = 'PYI054'
    PYI055 = 'PYI055'
    PYI056 = 'PYI056'
    PYI057 = 'PYI057'
    PYI058 = 'PYI058'
    PYI059 = 'PYI059'
    PYI06 = 'PYI06'
    PYI062 = 'PYI062'
    PYI063 = 'PYI063'
    PYI064 = 'PYI064'
    PYI066 = 'PYI066'
    Q = 'Q'
    Q0 = 'Q0'
    Q00 = 'Q00'
    Q000 = 'Q000'
    Q001 = 'Q001'
    Q002 = 'Q002'
    Q003 = 'Q003'
    Q004 = 'Q004'
    RET = 'RET'
    RET5 = 'RET5'
    RET50 = 'RET50'
    RET501 = 'RET501'
    RET502 = 'RET502'
    RET503 = 'RET503'
    RET504 = 'RET504'
    RET505 = 'RET505'
    RET506 = 'RET506'
    RET507 = 'RET507'
    RET508 = 'RET508'
    RSE = 'RSE'
    RSE1 = 'RSE1'
    RSE10 = 'RSE10'
    RSE102 = 'RSE102'
    RUF = 'RUF'
    RUF0 = 'RUF0'
    RUF00 = 'RUF00'
    RUF001 = 'RUF001'
    RUF002 = 'RUF002'
    RUF003 = 'RUF003'
    RUF005 = 'RUF005'
    RUF006 = 'RUF006'
    RUF007 = 'RUF007'
    RUF008 = 'RUF008'
    RUF009 = 'RUF009'
    RUF01 = 'RUF01'
    RUF010 = 'RUF010'
    RUF012 = 'RUF012'
    RUF013 = 'RUF013'
    RUF015 = 'RUF015'
    RUF016 = 'RUF016'
    RUF017 = 'RUF017'
    RUF018 = 'RUF018'
    RUF019 = 'RUF019'
    RUF02 = 'RUF02'
    RUF020 = 'RUF020'
    RUF021 = 'RUF021'
    RUF022 = 'RUF022'
    RUF023 = 'RUF023'
    RUF024 = 'RUF024'
    RUF026 = 'RUF026'
    RUF027 = 'RUF027'
    RUF028 = 'RUF028'
    RUF029 = 'RUF029'
    RUF03 = 'RUF03'
    RUF030 = 'RUF030'
    RUF031 = 'RUF031'
    RUF032 = 'RUF032'
    RUF033 = 'RUF033'
    RUF034 = 'RUF034'
    RUF035 = 'RUF035'
    RUF036 = 'RUF036'
    RUF1 = 'RUF1'
    RUF10 = 'RUF10'
    RUF100 = 'RUF100'
    RUF101 = 'RUF101'
    RUF2 = 'RUF2'
    RUF20 = 'RUF20'
    RUF200 = 'RUF200'
    S = 'S'
    S1 = 'S1'
    S10 = 'S10'
    S101 = 'S101'
    S102 = 'S102'
    S103 = 'S103'
    S104 = 'S104'
    S105 = 'S105'
    S106 = 'S106'
    S107 = 'S107'
    S108 = 'S108'
    S11 = 'S11'
    S110 = 'S110'
    S112 = 'S112'
    S113 = 'S113'
    S2 = 'S2'
    S20 = 'S20'
    S201 = 'S201'
    S202 = 'S202'
    S3 = 'S3'
    S30 = 'S30'
    S301 = 'S301'
    S302 = 'S302'
    S303 = 'S303'
    S304 = 'S304'
    S305 = 'S305'
    S306 = 'S306'
    S307 = 'S307'
    S308 = 'S308'
    S31 = 'S31'
    S310 = 'S310'
    S311 = 'S311'
    S312 = 'S312'
    S313 = 'S313'
    S314 = 'S314'
    S315 = 'S315'
    S316 = 'S316'
    S317 = 'S317'
    S318 = 'S318'
    S319 = 'S319'
    S32 = 'S32'
    S320 = 'S320'
    S321 = 'S321'
    S323 = 'S323'
    S324 = 'S324'
    S4 = 'S4'
    S40 = 'S40'
    S401 = 'S401'
    S402 = 'S402'
    S403 = 'S403'
    S404 = 'S404'
    S405 = 'S405'
    S406 = 'S406'
    S407 = 'S407'
    S408 = 'S408'
    S409 = 'S409'
    S41 = 'S41'
    S411 = 'S411'
    S412 = 'S412'
    S413 = 'S413'
    S415 = 'S415'
    S5 = 'S5'
    S50 = 'S50'
    S501 = 'S501'
    S502 = 'S502'
    S503 = 'S503'
    S504 = 'S504'
    S505 = 'S505'
    S506 = 'S506'
    S507 = 'S507'
    S508 = 'S508'
    S509 = 'S509'
    S6 = 'S6'
    S60 = 'S60'
    S601 = 'S601'
    S602 = 'S602'
    S603 = 'S603'
    S604 = 'S604'
    S605 = 'S605'
    S606 = 'S606'
    S607 = 'S607'
    S608 = 'S608'
    S609 = 'S609'
    S61 = 'S61'
    S610 = 'S610'
    S611 = 'S611'
    S612 = 'S612'
    S7 = 'S7'
    S70 = 'S70'
    S701 = 'S701'
    S702 = 'S702'
    SIM = 'SIM'
    SIM1 = 'SIM1'
    SIM10 = 'SIM10'
    SIM101 = 'SIM101'
    SIM102 = 'SIM102'
    SIM103 = 'SIM103'
    SIM105 = 'SIM105'
    SIM107 = 'SIM107'
    SIM108 = 'SIM108'
    SIM109 = 'SIM109'
    SIM11 = 'SIM11'
    SIM110 = 'SIM110'
    SIM112 = 'SIM112'
    SIM113 = 'SIM113'
    SIM114 = 'SIM114'
    SIM115 = 'SIM115'
    SIM116 = 'SIM116'
    SIM117 = 'SIM117'
    SIM118 = 'SIM118'
    SIM2 = 'SIM2'
    SIM20 = 'SIM20'
    SIM201 = 'SIM201'
    SIM202 = 'SIM202'
    SIM208 = 'SIM208'
    SIM21 = 'SIM21'
    SIM210 = 'SIM210'
    SIM211 = 'SIM211'
    SIM212 = 'SIM212'
    SIM22 = 'SIM22'
    SIM220 = 'SIM220'
    SIM221 = 'SIM221'
    SIM222 = 'SIM222'
    SIM223 = 'SIM223'
    SIM3 = 'SIM3'
    SIM30 = 'SIM30'
    SIM300 = 'SIM300'
    SIM4 = 'SIM4'
    SIM40 = 'SIM40'
    SIM401 = 'SIM401'
    SIM9 = 'SIM9'
    SIM90 = 'SIM90'
    SIM905 = 'SIM905'
    SIM91 = 'SIM91'
    SIM910 = 'SIM910'
    SIM911 = 'SIM911'
    SLF = 'SLF'
    SLF0 = 'SLF0'
    SLF00 = 'SLF00'
    SLF001 = 'SLF001'
    SLOT = 'SLOT'
    SLOT0 = 'SLOT0'
    SLOT00 = 'SLOT00'
    SLOT000 = 'SLOT000'
    SLOT001 = 'SLOT001'
    SLOT002 = 'SLOT002'
    T = 'T'
    T1 = 'T1'
    T10 = 'T10'
    T100 = 'T100'
    T2 = 'T2'
    T20 = 'T20'
    T201 = 'T201'
    T203 = 'T203'
    TCH = 'TCH'
    TCH0 = 'TCH0'
    TCH00 = 'TCH00'
    TCH001 = 'TCH001'
    TCH002 = 'TCH002'
    TCH003 = 'TCH003'
    TCH004 = 'TCH004'
    TCH005 = 'TCH005'
    TCH01 = 'TCH01'
    TCH010 = 'TCH010'
    TD = 'TD'
    TD0 = 'TD0'
    TD00 = 'TD00'
    TD001 = 'TD001'
    TD002 = 'TD002'
    TD003 = 'TD003'
    TD004 = 'TD004'
    TD005 = 'TD005'
    TD006 = 'TD006'
    TD007 = 'TD007'
    TID = 'TID'
    TID2 = 'TID2'
    TID25 = 'TID25'
    TID251 = 'TID251'
    TID252 = 'TID252'
    TID253 = 'TID253'
    TRY = 'TRY'
    TRY0 = 'TRY0'
    TRY00 = 'TRY00'
    TRY002 = 'TRY002'
    TRY003 = 'TRY003'
    TRY004 = 'TRY004'
    TRY2 = 'TRY2'
    TRY20 = 'TRY20'
    TRY201 = 'TRY201'
    TRY203 = 'TRY203'
    TRY3 = 'TRY3'
    TRY30 = 'TRY30'
    TRY300 = 'TRY300'
    TRY301 = 'TRY301'
    TRY4 = 'TRY4'
    TRY40 = 'TRY40'
    TRY400 = 'TRY400'
    TRY401 = 'TRY401'
    UP = 'UP'
    UP0 = 'UP0'
    UP00 = 'UP00'
    UP001 = 'UP001'
    UP003 = 'UP003'
    UP004 = 'UP004'
    UP005 = 'UP005'
    UP006 = 'UP006'
    UP007 = 'UP007'
    UP008 = 'UP008'
    UP009 = 'UP009'
    UP01 = 'UP01'
    UP010 = 'UP010'
    UP011 = 'UP011'
    UP012 = 'UP012'
    UP013 = 'UP013'
    UP014 = 'UP014'
    UP015 = 'UP015'
    UP017 = 'UP017'
    UP018 = 'UP018'
    UP019 = 'UP019'
    UP02 = 'UP02'
    UP020 = 'UP020'
    UP021 = 'UP021'
    UP022 = 'UP022'
    UP023 = 'UP023'
    UP024 = 'UP024'
    UP025 = 'UP025'
    UP026 = 'UP026'
    UP027 = 'UP027'
    UP028 = 'UP028'
    UP029 = 'UP029'
    UP03 = 'UP03'
    UP030 = 'UP030'
    UP031 = 'UP031'
    UP032 = 'UP032'
    UP033 = 'UP033'
    UP034 = 'UP034'
    UP035 = 'UP035'
    UP036 = 'UP036'
    UP037 = 'UP037'
    UP038 = 'UP038'
    UP039 = 'UP039'
    UP04 = 'UP04'
    UP040 = 'UP040'
    UP041 = 'UP041'
    UP042 = 'UP042'
    UP043 = 'UP043'
    UP044 = 'UP044'
    W = 'W'
    W1 = 'W1'
    W19 = 'W19'
    W191 = 'W191'
    W2 = 'W2'
    W29 = 'W29'
    W291 = 'W291'
    W292 = 'W292'
    W293 = 'W293'
    W3 = 'W3'
    W39 = 'W39'
    W391 = 'W391'
    W5 = 'W5'
    W50 = 'W50'
    W505 = 'W505'
    W6 = 'W6'
    W60 = 'W60'
    W605 = 'W605'
    YTT = 'YTT'
    YTT1 = 'YTT1'
    YTT10 = 'YTT10'
    YTT101 = 'YTT101'
    YTT102 = 'YTT102'
    YTT103 = 'YTT103'
    YTT2 = 'YTT2'
    YTT20 = 'YTT20'
    YTT201 = 'YTT201'
    YTT202 = 'YTT202'
    YTT203 = 'YTT203'
    YTT204 = 'YTT204'
    YTT3 = 'YTT3'
    YTT30 = 'YTT30'
    YTT301 = 'YTT301'
    YTT302 = 'YTT302'
    YTT303 = 'YTT303'


class Strictness1(Enum):
    """Ban imports that extend into the parent module or beyond."""

    parents = 'parents'


class Strictness2(Enum):
    """Ban all relative imports."""

    all = 'all'


class Strictness(RootModel[Union[Strictness1, Strictness2]]):
    root: Strictness1 | Strictness2


class Platform(Enum):
    linux = 'linux'
    windows = 'windows'
    macos = 'macos'


class Format(DataModel):
    """Options for static analysis and formatting."""

    config_path: str | None = Field(
        None,
        alias='config-path',
        description='Path to default configuration',
        title='Config-Path',
    )


class Metadata(DataModel):
    """Metadata for the project."""

    model_config = ConfigDict(
        extra='forbid',
    )
    allow_direct_references: bool | None = Field(
        None,
        alias='allow-direct-references',
        description='Whether to allow direct references',
        title='Allow-Direct-References',
    )
    allow_ambiguous_features: bool | None = Field(
        None,
        alias='allow-ambiguous-features',
        description='Whether to allow ambiguous features',
        title='Allow-Ambiguous-Features',
    )


class Override2(RootModel[Any]):
    root: Any = Field(..., description='TODO', title='Override')


class Overrides(DataModel):
    """Overrides depending on things like platform, matrix variables, or environment variables."""

    platform: Dict[str, Override2] | None = None


class Env(DataModel):
    template: str | None = Field(
        'default',
        description='Template environment to inherit from. Set to own name to make self referential (disable inheritance from âdefaultâ)',
        title='Template',
    )
    detached: bool | None = Field(
        False,
        description='Make the environment self-referential and skip project install',
        title='Detached',
    )
    dependencies: List[str] | None = Field(
        None,
        description='List of dependencies to install in the environment',
        title='Dependencies',
    )
    extra_dependencies: List[str] | None = Field(
        None,
        alias='extra-dependencies',
        description='List of extra dependencies to install in the environment in addition to the template environmentâs dependencies',
        title='Extra dependencies',
    )
    features: List[str] | None = Field(
        None,
        description='List of optional dependency groups (extras) to install',
        title='Features (extras)',
    )
    dev_mode: bool | None = Field(
        True,
        alias='dev-mode',
        description='Whether to install the project in development mode',
        title='Dev mode',
    )
    skip_install: bool | None = Field(
        False,
        alias='skip-install',
        description='Whether to skip installing the project',
        title='Skip install',
    )
    env_vars: Dict[str, str] | None = Field(
        None,
        alias='env-vars',
        description='Environment variables to set',
        title='Environment variables',
    )
    env_include: List[str] | None = Field(
        None,
        alias='env-include',
        description='Glob patterns of environment variables to include',
        title='Environment variable include',
    )
    env_exclude: List[str] | None = Field(
        None,
        alias='env-exclude',
        description='Glob patterns of environment variables to exclude',
        title='Environment variable exclude',
    )
    scripts: Dict[str, str | List[str]] | None = Field(
        None, description='Dictionary of scripts to run', title='Scripts',
    )
    pre_install_commands: List[str] | None = Field(
        None,
        alias='pre-install-commands',
        description='List of commands to run before installing the project',
        title='Pre-install commands',
    )
    post_install_commands: List[str] | None = Field(
        None,
        alias='post-install-commands',
        description='List of commands to run after installing the project',
        title='Post-install commands',
    )
    python: str | None = Field(
        None,
        description='Python version to use or an absolute path to a python interpreter',
        title='Python version',
    )
    platforms: List[Platform] | None = Field(
        None, description='List of platforms to build for', title='Platforms',
    )
    description: str | None = Field(
        None,
        description='Description of the environment for the `env show` command',
        title='Description',
    )
    type: str | None = Field(
        'virtual',
        description='Type of environment. Without plugins, the only supported type is "virtual"',
        title='Type',
    )
    matrix: List[Dict[str, List[str]]] | None = Field(
        None, description='Matrix of environments', title='Matrix',
    )
    matrix_name_format: str | None = Field(
        '{value}',
        alias='matrix-name-format',
        description='Format string for matrix names, supporting {variable} and {value} placeholders',
        title='Matrix name format',
    )
    overrides: Overrides | None = None
    requires: List[str] | None = Field(
        None, description='Required environment plugins', title='Requires',
    )


class Envs(RootModel[Optional[Dict[str, Env]]]):
    """Dictionary of environments."""

    root: Dict[str, Env] | None = None


class CollectorEnv(DataModel):
    """Environment collector plugin configuration."""

    collectors: Dict[str, Dict[str, Any]] | None = Field(
        None, description='Custom environment collectors', title='Collectors',
    )
    requires: List[str] | None = Field(
        None,
        description='Required environment collectors for automatic management',
        title='Requires',
    )


class Target(DataModel):
    dependencies: List[str] | None = Field(
        None,
        description='Additional dependencies to install in the environment',
        title='Dependencies',
    )
    require_runtime_dependencies: bool | None = Field(
        False,
        alias='require-runtime-dependencies',
        description='Whether to install the projectâs runtime dependencies',
        title='Require runtime dependencies',
    )
    require_runtime_features: List[str] | None = Field(
        None,
        alias='require-runtime-features',
        description='A list of the projectâs runtime features to install',
        title='Required runtime features',
    )
    versions: List[str] | None = Field(
        None, description='List of versions to build', title='Versions',
    )


class CustomTargets(RootModel[Optional[Dict[str, Target]]]):
    """Build targets."""

    root: Dict[str, Target] | None = None


class Hook(DataModel):
    dependencies: List[str] | None = Field(
        None,
        description='Additional dependencies installed in the build environment',
        title='Dependencies',
    )
    require_runtime_dependencies: bool | None = Field(
        False,
        alias='require-runtime-dependencies',
        description='Whether to install the projectâs runtime dependencies',
        title='Require runtime dependencies',
    )
    require_runtime_features: List[str] | None = Field(
        None,
        alias='require-runtime-features',
        description='A list of the projectâs runtime features to install',
        title='Required runtime features',
    )
    enable_by_default: bool | None = Field(
        True,
        alias='enable-by-default',
        description='Whether to enable current hook (disable to control activation using environment variables)',
        title='Conditional execution',
    )


class Hooks(RootModel[Optional[Dict[str, Hook]]]):
    """Build hooks."""

    root: Dict[str, Hook] | None = None


class Build1(DataModel):
    """Build configuration."""

    ignore_vcs: bool | None = Field(
        False,
        alias='ignore-vcs',
        description='Whether to ignore VCS .*ignore files and include those files by default',
        title='Ignore VCS in file selection',
    )
    include: List[str] | None = Field(
        None,
        description='List of glob patterns to include files',
        title='Include files',
    )
    exclude: List[str] | None = Field(
        None,
        description='List of glob patterns to exclude files',
        title='Exclude files',
    )
    artifacts: List[str] | None = Field(
        None,
        description='List of glob patterns to include VCS-ignored files',
        title='Artifact files',
    )
    only_packages: bool | None = Field(
        False,
        alias='only-packages',
        description='Whether to only include non-artifact files in packages',
        title='Excluding files outside packages',
    )
    sources: Dict[str, str] | List[str] | None = Field(
        None, description='Rewrite relative paths', title='Sources',
    )
    skip_excluded_dirs: bool | None = Field(
        False,
        alias='skip-excluded-dirs',
        description='Whether to skip excluded directories (for performance reasons)',
        title='Skip excluded dirs',
    )
    reproducible: bool | None = Field(
        True, description='Whether to make the build reproducible', title='Reproducible',
    )
    directory: str | None = Field(
        'dist',
        description='Directory to write build artifacts to',
        title='Output directory',
    )
    dev_mode_dirs: Any | None = Field(None, alias='dev-mode-dirs')
    dev_mode_exact: bool | None = Field(
        None,
        alias='dev-mode-exact',
        description='Whether to use an exact dev mode that doesnât add whole directories to PYTHONPATH',
        title='Exact dev mode',
    )
    targets: CustomTargets | None = None
    hooks: Hooks | None = None


class Build2(DataModel):
    """Build configuration."""

    ignore_vcs: bool | None = Field(
        False,
        alias='ignore-vcs',
        description='Whether to ignore VCS .*ignore files and include those files by default',
        title='Ignore VCS in file selection',
    )
    include: List[str] | None = Field(
        None,
        description='List of glob patterns to include files',
        title='Include files',
    )
    exclude: List[str] | None = Field(
        None,
        description='List of glob patterns to exclude files',
        title='Exclude files',
    )
    artifacts: List[str] | None = Field(
        None,
        description='List of glob patterns to include VCS-ignored files',
        title='Artifact files',
    )
    only_packages: bool | None = Field(
        False,
        alias='only-packages',
        description='Whether to only include non-artifact files in packages',
        title='Excluding files outside packages',
    )
    sources: Dict[str, str] | List[str] | None = Field(
        None, description='Rewrite relative paths', title='Sources',
    )
    skip_excluded_dirs: bool | None = Field(
        False,
        alias='skip-excluded-dirs',
        description='Whether to skip excluded directories (for performance reasons)',
        title='Skip excluded dirs',
    )
    reproducible: bool | None = Field(
        True, description='Whether to make the build reproducible', title='Reproducible',
    )
    directory: str | None = Field(
        'dist',
        description='Directory to write build artifacts to',
        title='Output directory',
    )
    dev_mode_dirs: List[str] | None = Field(
        None,
        alias='dev-mode-dirs',
        description='List of directories to add to PYTHONPATH in development mode',
        title='Dev mode directories',
    )
    dev_mode_exact: Any | None = Field(None, alias='dev-mode-exact')
    targets: CustomTargets | None = None
    hooks: Hooks | None = None


class Build(RootModel[Union[Build1, Build2]]):
    root: Build1 | Build2 = Field(
        ..., description='Build configuration', title='Build',
    )


class Version(DataModel):
    """Version configuration."""

    path: str | None = Field(
        None,
        description='A relative path to a file containing the project version',
        title='Path',
    )
    pattern: str | None = Field(
        None, description='A regex pattern to extract the version', title='Pattern',
    )


class Repos(DataModel):
    """Define named repositories to publish to."""

    main: Any | None = None
    test: Any | None = None


class PublishIndex(DataModel):
    """Publishing index configuration."""

    disable: bool | None = Field(
        False,
        description='Ask for confirmation when publishing to index',
        title='Confirmation',
    )
    repos: Repos | None = Field(
        None,
        description='Define named repositories to publish to',
        title='Repositories',
    )


class Publish(DataModel):
    """Publish configuration."""

    index: PublishIndex | None = None


class Define(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    env: constr(min_length=1)
    default: str | bool | None = None


class Cmake(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    minimum_version: str | None = Field(
        None,
        alias='minimum-version',
        description='DEPRECATED in 0.8; use version instead.',
    )
    version: str | None = Field(
        None,
        description='The versions of CMake to allow. If CMake is not present on the system or does not pass this specifier, it will be downloaded via PyPI if possible. An empty string will disable this check. The default on 0.10+ is "CMakeLists.txt", which will read it from the project\'s CMakeLists.txt file, or ">=3.15" if unreadable or <0.10.',
    )
    args: List[str] | None = Field(
        None,
        description='A list of args to pass to CMake when configuring the project. Setting this in config or envvar will override toml. See also ``cmake.define``.',
    )
    define: Dict[constr(pattern='.+'), str | bool | Define] | None = (
        Field(
            None,
            description='A table of defines to pass to CMake when configuring the project. Additive.',
        )
    )
    verbose: bool | None = Field(
        None, description='DEPRECATED in 0.10, use build.verbose instead.',
    )
    build_type: str | None = Field(
        'Release',
        alias='build-type',
        description='The build type to use when building the project. Valid options are: "Debug", "Release", "RelWithDebInfo", "MinSizeRel", "", etc.',
    )
    source_dir: str | None = Field(
        '.',
        alias='source-dir',
        description='The source directory to use when building the project. Currently only affects the native builder (not the setuptools plugin).',
    )
    targets: List[str] | None = Field(
        None, description='DEPRECATED in 0.10; use build.targets instead.',
    )


class Ninja(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    minimum_version: str | None = Field(
        None,
        alias='minimum-version',
        description='DEPRECATED in 0.8; use version instead.',
    )
    version: str | None = Field(
        '>=1.5',
        description='The versions of Ninja to allow. If Ninja is not present on the system or does not pass this specifier, it will be downloaded via PyPI if possible. An empty string will disable this check.',
    )
    make_fallback: bool | None = Field(
        True,
        alias='make-fallback',
        description='If Ninja is not present on the system or is older than required, it will be downloaded via PyPI if this is false.',
    )


class Level(Enum):
    """The logging level to display, "DEBUG", "INFO", "WARNING", and "ERROR" are possible options."""

    NOTSET = 'NOTSET'
    DEBUG = 'DEBUG'
    INFO = 'INFO'
    WARNING = 'WARNING'
    ERROR = 'ERROR'
    CRITICAL = 'CRITICAL'


class Logging(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    level: Level | None = Field(
        'WARNING',
        description='The logging level to display, "DEBUG", "INFO", "WARNING", and "ERROR" are possible options.',
    )


class Sdist(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    include: List[str] | None = Field(
        None,
        description='Files to include in the SDist even if they are skipped by default. Supports gitignore syntax.',
    )
    exclude: List[str] | None = Field(
        None,
        description='Files to exclude from the SDist even if they are included by default. Supports gitignore syntax.',
    )
    reproducible: bool | None = Field(
        True,
        description='If set to True, try to build a reproducible distribution (Unix and Python 3.9+ recommended).  ``SOURCE_DATE_EPOCH`` will be used for timestamps, or a fixed value if not set.',
    )
    cmake: bool | None = Field(
        False,
        description='If set to True, CMake will be run before building the SDist.',
    )


class Wheel(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    packages: List[str] | Dict[constr(pattern='.+'), str] | None = Field(
        None,
        description='A list of packages to auto-copy into the wheel. If this is not set, it will default to the first of ``src/<package>``, ``python/<package>``, or ``<package>`` if they exist.  The prefix(s) will be stripped from the package name inside the wheel. If a dict, provides a mapping of package name to source directory.',
    )
    py_api: str | None = Field(
        '',
        alias='py-api',
        description='The Python tags. The default (empty string) will use the default Python version. You can also set this to "cp37" to enable the CPython 3.7+ Stable ABI / Limited API (only on CPython and if the version is sufficient, otherwise this has no effect). Or you can set it to "py3" or "py2.py3" to ignore Python ABI compatibility. The ABI tag is inferred from this tag.',
    )
    expand_macos_universal_tags: bool | None = Field(
        False,
        alias='expand-macos-universal-tags',
        description='Fill out extra tags that are not required. This adds "x86_64" and "arm64" to the list of platforms when "universal2" is used, which helps older Pip\'s (before 21.0.1) find the correct wheel.',
    )
    install_dir: str | None = Field(
        '',
        alias='install-dir',
        description='The install directory for the wheel. This is relative to the platlib root. You might set this to the package name. The original dir is still at SKBUILD_PLATLIB_DIR (also SKBUILD_DATA_DIR, etc. are available). EXPERIMENTAL: An absolute path will be one level higher than the platlib root, giving access to "/platlib", "/data", "/headers", and "/scripts".',
    )
    license_files: List[str] | None = Field(
        None,
        alias='license-files',
        description='A list of license files to include in the wheel. Supports glob patterns.',
    )
    cmake: bool | None = Field(
        True,
        description='If set to True (the default), CMake will be run before building the wheel.',
    )
    platlib: bool | None = Field(
        None,
        description='Target the platlib or the purelib. If not set, the default is to target the platlib if wheel.cmake is true, and the purelib otherwise.',
    )
    exclude: List[str] | None = Field(
        None,
        description='A set of patterns to exclude from the wheel. This is additive to the SDist exclude patterns. This applies to the final paths in the wheel, and can exclude files from CMake output as well.  Editable installs may not respect this exclusion.',
    )
    build_tag: str | None = Field(
        '',
        alias='build-tag',
        description='The build tag to use for the wheel. If empty, no build tag is used.',
    )


class Backport(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    find_python: str | None = Field(
        '3.26.1',
        alias='find-python',
        description='If CMake is less than this value, backport a copy of FindPython. Set to 0 disable this, or the empty string.',
    )


class Mode(Enum):
    """Select the editable mode to use. Can be "redirect" (default) or "inplace"."""

    redirect = 'redirect'
    inplace = 'inplace'


class Editable(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mode: Mode | None = Field(
        'redirect',
        description='Select the editable mode to use. Can be "redirect" (default) or "inplace".',
    )
    verbose: bool | None = Field(
        True, description='Turn on verbose output for the editable mode rebuilds.',
    )
    rebuild: bool | None = Field(
        False,
        description='Rebuild the project when the package is imported. The build-directory must be set.',
    )


class Build3(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tool_args: List[str] | None = Field(
        None,
        alias='tool-args',
        description='Extra args to pass directly to the builder in the build step.',
    )
    targets: List[str] | None = Field(
        None,
        description='The build targets to use when building the project. Empty builds the default target.',
    )
    verbose: bool | None = Field(
        False, description='Verbose printout when building.',
    )


class Install(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    components: List[str] | None = Field(
        None,
        description='The components to install. If empty, all default components are installed.',
    )
    strip: bool | None = Field(
        None,
        description='Whether to strip the binaries. True for scikit-build-core 0.5+.',
    )


class Location(Enum):
    """The place to put the generated file. The "build" directory is useful for CMake files, and the "install" directory is useful for Python files, usually. You can also write directly to the "source" directory, will overwrite existing files & remember to gitignore the file."""

    install = 'install'
    build = 'build'
    source = 'source'


class Generate(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: constr(min_length=1) = Field(
        ..., description='The path (relative to platlib) for the file to generate.',
    )
    template: constr(min_length=1) = Field(
        ...,
        description='The template to use for the file. This includes string.Template style placeholders for all the metadata. If empty, a template-path must be set.',
    )
    location: Location | None = Field(
        'install',
        description='The place to put the generated file. The "build" directory is useful for CMake files, and the "install" directory is useful for Python files, usually. You can also write directly to the "source" directory, will overwrite existing files & remember to gitignore the file.',
    )


class Generate1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: constr(min_length=1) = Field(
        ..., description='The path (relative to platlib) for the file to generate.',
    )
    template_path: constr(min_length=1) = Field(
        ...,
        alias='template-path',
        description='The path to the template file. If empty, a template must be set.',
    )
    location: Location | None = Field(
        'install',
        description='The place to put the generated file. The "build" directory is useful for CMake files, and the "install" directory is useful for Python files, usually. You can also write directly to the "source" directory, will overwrite existing files & remember to gitignore the file.',
    )


class Messages(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    after_failure: str | None = Field(
        '',
        alias='after-failure',
        description='A message to print after a build failure.',
    )
    after_success: str | None = Field(
        '',
        alias='after-success',
        description='A message to print after a successful build.',
    )


class MetadataModel(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    provider: str | None = None
    provider_path: str | None = Field(None, alias='provider-path')


class IfOverrides(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    scikit_build_version: str | None = Field(
        None,
        alias='scikit-build-version',
        description='The version of scikit-build-version. Takes a specifier set.',
    )
    python_version: str | None = Field(
        None,
        alias='python-version',
        description='The two-digit Python version. Takes a specifier set.',
    )
    implementation_name: str | None = Field(
        None,
        alias='implementation-name',
        description='The value of `sys.implementation.name`. Takes a regex',
    )
    implementation_version: str | None = Field(
        None,
        alias='implementation-version',
        description='Derived from `sys.implementation.version`, following PEP 508. Takes a specifier set.',
    )
    platform_system: str | None = Field(
        None,
        alias='platform-system',
        description='The value of `sys.platform`. Takes a regex.',
    )
    platform_machine: str | None = Field(
        None,
        alias='platform-machine',
        description='The value of `platform.machine()`. Takes a regex.',
    )
    platform_node: str | None = Field(
        None,
        alias='platform-node',
        description='The value of `platform.node()`. Takes a regex.',
    )
    state: str | None = Field(
        None,
        description='The state of the build, one of `sdist`, `wheel`, `editable`, `metadata_wheel`, and `metadata_editable`. Takes a regex.',
    )
    from_sdist: bool | None = Field(
        None, alias='from-sdist', description='Whether the build is from an sdist.',
    )
    failed: bool | None = Field(
        None,
        description='Matches if the build fails. A build will be retried if there is at least one matching override with this set to true.',
    )
    system_cmake: str | None = Field(
        None,
        alias='system-cmake',
        description='The version of CMake found on the system. Takes a specifier set.',
    )
    cmake_wheel: bool | None = Field(
        None,
        alias='cmake-wheel',
        description='Whether a cmake wheel is known to be provided for this system.',
    )
    abi_flags: str | None = Field(
        None,
        alias='abi-flags',
        description='A sorted string of the abi flags. Takes a regex.',
    )
    env: Dict[constr(pattern='.*'), str | bool] | None = Field(
        None,
        description="A table of environment variables mapped to either string regexs, or booleans. Valid 'truthy' environment variables are case insensitive `true`, `on`, `yes`, `y`, `t`, or a number more than 0.",
    )


class InheritModel(Enum):
    none = 'none'
    append = 'append'
    prepend = 'prepend'


class BuildDir(RootModel[str]):
    root: str = Field(
        ...,
        description='The build directory. Defaults to a temporary directory, but can be set.',
    )


class CmakeModel(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    minimum_version: str | None = Field(
        None,
        alias='minimum-version',
        description='DEPRECATED in 0.8; use version instead.',
    )
    version: str | None = Field(
        None,
        description='The versions of CMake to allow. If CMake is not present on the system or does not pass this specifier, it will be downloaded via PyPI if possible. An empty string will disable this check. The default on 0.10+ is "CMakeLists.txt", which will read it from the project\'s CMakeLists.txt file, or ">=3.15" if unreadable or <0.10.',
    )
    args: List[str] | None = Field(
        None,
        description='A list of args to pass to CMake when configuring the project. Setting this in config or envvar will override toml. See also ``cmake.define``.',
    )
    define: Dict[constr(pattern='.+'), str | bool | Define] | None = (
        Field(
            None,
            description='A table of defines to pass to CMake when configuring the project. Additive.',
        )
    )
    verbose: bool | None = Field(
        None, description='DEPRECATED in 0.10, use build.verbose instead.',
    )
    build_type: str | None = Field(
        'Release',
        alias='build-type',
        description='The build type to use when building the project. Valid options are: "Debug", "Release", "RelWithDebInfo", "MinSizeRel", "", etc.',
    )
    source_dir: str | None = Field(
        '.',
        alias='source-dir',
        description='The source directory to use when building the project. Currently only affects the native builder (not the setuptools plugin).',
    )
    targets: List[str] | None = Field(
        None, description='DEPRECATED in 0.10; use build.targets instead.',
    )


class EditableModel(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mode: Mode | None = Field(
        'redirect',
        description='Select the editable mode to use. Can be "redirect" (default) or "inplace".',
    )
    verbose: bool | None = Field(
        True, description='Turn on verbose output for the editable mode rebuilds.',
    )
    rebuild: bool | None = Field(
        False,
        description='Rebuild the project when the package is imported. The build-directory must be set.',
    )


class Experimental(RootModel[bool]):
    root: bool = Field(
        ..., description='Enable early previews of features not finalized yet.',
    )


class Fail(RootModel[bool]):
    root: bool = Field(
        ..., description='Immediately fail the build. This is only useful in overrides.',
    )


class Generate2(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: constr(min_length=1) = Field(
        ..., description='The path (relative to platlib) for the file to generate.',
    )
    template: constr(min_length=1) = Field(
        ...,
        description='The template to use for the file. This includes string.Template style placeholders for all the metadata. If empty, a template-path must be set.',
    )
    location: Location | None = Field(
        'install',
        description='The place to put the generated file. The "build" directory is useful for CMake files, and the "install" directory is useful for Python files, usually. You can also write directly to the "source" directory, will overwrite existing files & remember to gitignore the file.',
    )


class Generate3(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: constr(min_length=1) = Field(
        ..., description='The path (relative to platlib) for the file to generate.',
    )
    template_path: constr(min_length=1) = Field(
        ...,
        alias='template-path',
        description='The path to the template file. If empty, a template must be set.',
    )
    location: Location | None = Field(
        'install',
        description='The place to put the generated file. The "build" directory is useful for CMake files, and the "install" directory is useful for Python files, usually. You can also write directly to the "source" directory, will overwrite existing files & remember to gitignore the file.',
    )


class GenerateModel(RootModel[List[Generate2 | Generate3]]):
    root: List[Generate2 | Generate3]


class LoggingModel(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    level: Level | None = Field(
        'WARNING',
        description='The logging level to display, "DEBUG", "INFO", "WARNING", and "ERROR" are possible options.',
    )


class MetadataModel1(DataModel):
    """List dynamic metadata fields and hook locations in this table."""

    model_config = ConfigDict(
        extra='forbid',
    )
    version: MetadataModel | None = None
    description: MetadataModel | None = None
    license: MetadataModel | None = None
    readme: MetadataModel | None = None
    requires_python: MetadataModel | None = Field(None, alias='requires-python')
    dependencies: MetadataModel | None = None
    optional_dependencies: MetadataModel | None = Field(
        None, alias='optional-dependencies',
    )
    entrypoints: MetadataModel | None = None
    authors: MetadataModel | None = None
    maintainers: MetadataModel | None = None
    urls: MetadataModel | None = None
    classifiers: MetadataModel | None = None
    keywords: MetadataModel | None = None
    scripts: MetadataModel | None = None
    gui_scripts: MetadataModel | None = Field(None, alias='gui-scripts')


class MinimumVersion(RootModel[str]):
    root: str = Field(
        ...,
        description='If set, this will provide a method for backward compatibility.',
    )


class StrictConfig(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Strictly check all config options. If False, warnings will be printed for unknown options. If True, an error will be raised.',
    )


class PackageName(RootModel[str]):
    root: str = Field(
        ...,
        description='Valid package name (importable or :pep:`561`).',
        title='Valid package name',
    )


class FileDirective(DataModel):
    """Value is read from a file (or list of files and then concatenated)."""

    model_config = ConfigDict(
        extra='forbid',
    )
    file: str | List[str]


class FileDirectiveForDependencies(FileDirective):
    pass


class AttrDirective(DataModel):
    """Value is read from a module attribute. Supports callables and iterables; unsupported types are cast via ``str()``."""

    model_config = ConfigDict(
        extra='forbid',
    )
    attr: str


class Find(DataModel):
    """Dynamic `package discovery <https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_."""

    model_config = ConfigDict(
        extra='forbid',
    )
    where: List[str] | None = Field(
        None,
        description='Directories to be searched for packages (Unix-style relative path)',
    )
    exclude: List[str] | None = Field(
        None,
        description="Exclude packages that match the values listed in this field. Can container shell-style wildcards (e.g. ``'pkg.*'``)",
    )
    include: List[str] | None = Field(
        None,
        description="Restrict the found packages to just the ones listed in this field. Can container shell-style wildcards (e.g. ``'pkg.*'``)",
    )
    namespaces: bool | None = Field(
        None,
        description='When ``True``, directories without a ``__init__.py`` file will also be scanned for :pep:`420`-style implicit namespaces',
    )


class FindDirective(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    find: Find | None = Field(
        None,
        description='Dynamic `package discovery <https://setuptools.pypa.io/en/latest/userguide/package_discovery.html>`_.',
    )


class File(RootModel[Union[str, List[str]]]):
    root: str | List[str]


class PartialSetuptoolsScm(DataModel):
    """Schema for the [tool.setuptools_scm] section in pyproject.toml."""

    model_config = ConfigDict(
        extra='forbid',
    )
    root: str | None = Field(
        None,
        description='Relative path to the SCM root, defaults to `.` and is relative to the file path passed in `relative_to`.',
    )
    version_scheme: str | None = Field(
        None,
        description='An entrypoint name; configures how the local version number is constructed.',
    )
    local_scheme: str | None = Field(
        None,
        description='An entrypoint name; configures how the local component of the version is constructed.',
    )
    version_file: str | None = Field(
        None,
        description='A path to a file that gets replaced with a file containing the current version. It is ideal for creating a `_version.py` file within the package, typically used to avoid using `pkg_resources.get_distribution` (which adds some overhead). Only files with `.py` and `.txt` extensions have builtin templates, for other file types it is necessary to provide version_file_template.',
    )
    version_file_template: str | None = Field(
        None,
        description='A new-style format string taking `version`, `scm_version` and `version_tuple` as parameters. `version` is the generated next_version as string, `version_tuple` is a tuple of split numbers/strings and `scm_version` is the `ScmVersion` instance the current `version` was rendered from.',
    )
    write_to: str | None = Field(
        None,
        description='Create a version file relative to the scm root; deprecated in favor of use `version_file` instead.',
    )
    relative_to: str | None = Field(
        'pyproject.toml',
        description='A file/directory from which the root can be resolved. Typically called by a script or module that is not in the root of the repository to point `setuptools_scm` at the root of the repository by supplying `__file__`.',
    )
    tag_regex: str | None = Field(
        '^(?:[\\w-]+-)?(?P<version>[vV]?\\d+(?:\\.\\d+){0,2}[^\\+]*)(?:\\+.*)?$',
        description='A Python regex string to extract the version part from any SCM tag. The regex needs to contain either a single match group, or a group named `version`, that captures the actual version information.',
    )
    parentdir_prefix_version: str | None = Field(
        None,
        description='If the normal methods for detecting the version (SCM version, sdist metadata) fail, and the parent directory name starts with `parentdir_prefix_version`, then this prefix is stripped and the rest of the parent directory name is matched with `tag_regex` to get a version string.  If this parameter is unset (the default), then this fallback is not used.\n\nThis was intended to cover GitHub\'s "release tarballs", which extract into directories named `projectname-tag/` (in which case `parentdir_prefix_version` can be set e.g. to `projectname-`).',
    )
    fallback_version: str | None = Field(
        None,
        description='A version string that will be used if no other method for detecting the version worked (e.g., when using a tarball with no metadata). If this is unset (the default), `setuptools-scm` will error if it fails to detect the version.',
    )
    git_describe_command: List[str] | None = Field(
        ['git', 'describe', '--dirty', '--tags', '--long', '--match', '*[0-9]*'],
        description='This command will be used instead the default `git describe --long` command.',
    )
    normalize: bool | None = Field(
        True,
        description='A boolean flag indicating if the version string should be normalized.',
    )
    version_cls: str | None = Field(
        'packaging.version.Version',
        description='Qualified name of an optional class used to parse, verify and possibly normalize the version string. Its constructor should receive a single string argument, and its `str` should return the normalized version string to use.',
    )


class Plugins1(DataModel):
    """Configuration for the poetry-plugin-dotenv."""

    model_config = ConfigDict(
        extra='forbid',
    )
    ignore: str | None = Field(
        None, description='Flag that prevents the plugin from loading the dotenv file.',
    )
    location: str | None = Field(
        None,
        description='Path to the dotenv file. It can be both absolute or relative.',
    )


class PoetryName(RootModel[str]):
    root: str = Field(..., description='Package name.')


class PoetryVersion(RootModel[str]):
    root: str = Field(
        ...,
        description='Version of the package. It should follow semantic versioning, but it is not enforced.',
    )


class PoetryDescription(RootModel[constr(pattern=r'^[^\n]*$')]):
    root: constr(pattern=r'^[^\n]*$') = Field(
        ..., description='Short package description.',
    )


class PoetryAuthorPattern(
    RootModel[constr(pattern=r'^(?:[- .,\w\d\'â"():&]+)(?: <(?:.+?)>)?')],
):
    root: constr(pattern=r'^(?:[- .,\w\d\'â"():&]+)(?: <(?:.+?)>)?') = Field(
        ...,
        description="Pattern that matches `Name <email>` like 'King Arthur' or 'Miss Islington &lt;miss-islington@python.org&gt;'.",
    )


class PoetryAuthors(RootModel[List[PoetryAuthorPattern]]):
    """List of authors that contributed to the package. This is typically the main maintainers, not the full list."""

    root: List[PoetryAuthorPattern] = Field(
        ...,
        description='List of authors that contributed to the package. This is typically the main maintainers, not the full list.',
    )


class PoetryMaintainers(RootModel[List[PoetryAuthorPattern]]):
    """List of maintainers, other than the original author(s), that upkeep the package."""

    root: List[PoetryAuthorPattern] = Field(
        ...,
        description='List of maintainers, other than the original author(s), that upkeep the package.',
    )


class PoetryIncludePath(RootModel[str]):
    root: str = Field(..., description='Path to file or directory to include.')


class PoetryPackageFormat(Enum):
    """A Python packaging format."""

    sdist = 'sdist'
    wheel = 'wheel'


class PoetryPackageFormats(
    RootModel[Union[PoetryPackageFormat, List[PoetryPackageFormat]]],
):
    root: PoetryPackageFormat | List[PoetryPackageFormat] = Field(
        ..., description='The format(s) for which the package must be included.',
    )


class PoetryPep440Version(RootModel[str]):
    root: str = Field(
        ...,
        description="A version constraint. Validates against the PEP 440's version pattern.",
    )


class PoetryDependency(RootModel[PoetryPep440Version]):
    root: PoetryPep440Version


class PoetryLongDependency(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    version: PoetryPep440Version
    python: str | None = Field(
        None,
        description='The python versions for which the dependency should be installed.',
    )
    platform: str | None = Field(
        None,
        description='The platform(s) for which the dependency should be installed.',
    )
    markers: str | None = Field(
        None,
        description='The PEP 508 compliant environment markers for which the dependency should be installed.',
    )
    allow_prereleases: bool | None = Field(
        None,
        alias='allow-prereleases',
        description='Whether the dependency allows prereleases or not.',
    )
    allows_prereleases: bool | None = Field(
        None,
        alias='allows-prereleases',
        description='Whether the dependency allows prereleases or not.',
    )
    optional: bool | None = Field(
        None, description='Whether the dependency is optional or not.',
    )
    extras: List[str] | None = Field(
        None, description='The required extras for this dependency.',
    )
    source: str | None = Field(
        None, description='The exclusive source used to search for this dependency.',
    )


class PoetryGitDependency(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    git: AnyUrl | constr(pattern='^([A-Za-z0-9\\-]+@|https://|http://)[A-Za-z][A-Za-z0-9+.-]*(:|/)[A-Za-z0-9\\-\\.]+(/[A-Za-z0-9\\-_\\.]+)+\\.git$') = Field(..., description='The url of the git repository.')
    branch: str | None = Field(None, description='The branch to checkout.')
    tag: str | None = Field(None, description='The tag to checkout.')
    rev: str | None = Field(None, description='The revision to checkout.')
    subdirectory: str | None = Field(
        None,
        description='The relative path to the directory where the package is located.',
    )
    python: str | None = Field(
        None,
        description='The python versions for which the dependency should be installed.',
    )
    platform: str | None = Field(
        None,
        description='The platform(s) for which the dependency should be installed.',
    )
    markers: str | None = Field(
        None,
        description='The PEP 508 compliant environment markers for which the dependency should be installed.',
    )
    allow_prereleases: bool | None = Field(
        None,
        alias='allow-prereleases',
        description='Whether the dependency allows prereleases or not.',
    )
    allows_prereleases: bool | None = Field(
        None,
        alias='allows-prereleases',
        description='Whether the dependency allows prereleases or not.',
    )
    optional: bool | None = Field(
        None, description='Whether the dependency is optional or not.',
    )
    extras: List[str] | None = Field(
        None, description='The required extras for this dependency.',
    )
    develop: bool | None = Field(
        None, description='Whether to install the dependency in development mode.',
    )


class PoetryFileDependency(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    file: str = Field(..., description='The path to the file.')
    python: str | None = Field(
        None,
        description='The python versions for which the dependency should be installed.',
    )
    platform: str | None = Field(
        None,
        description='The platform(s) for which the dependency should be installed.',
    )
    markers: str | None = Field(
        None,
        description='The PEP 508 compliant environment markers for which the dependency should be installed.',
    )
    optional: bool | None = Field(
        None, description='Whether the dependency is optional or not.',
    )
    extras: List[str] | None = Field(
        None, description='The required extras for this dependency.',
    )


class PoetryPathDependency(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str = Field(..., description='The path to the dependency.')
    python: str | None = Field(
        None,
        description='The python versions for which the dependency should be installed.',
    )
    platform: str | None = Field(
        None,
        description='The platform(s) for which the dependency should be installed.',
    )
    markers: str | None = Field(
        None,
        description='The PEP 508 compliant environment markers for which the dependency should be installed.',
    )
    optional: bool | None = Field(
        None, description='Whether the dependency is optional or not.',
    )
    extras: List[str] | None = Field(
        None, description='The required extras for this dependency.',
    )
    develop: bool | None = Field(
        None, description='Whether to install the dependency in development mode.',
    )


class PoetryUrlDependency(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    url: str = Field(..., description='The url to the file.')
    python: str | None = Field(
        None,
        description='The python versions for which the dependency should be installed.',
    )
    platform: str | None = Field(
        None,
        description='The platform(s) for which the dependency should be installed.',
    )
    markers: str | None = Field(
        None,
        description='The PEP 508 compliant environment markers for which the dependency should be installed.',
    )
    optional: bool | None = Field(
        None, description='Whether the dependency is optional or not.',
    )
    extras: List[str] | None = Field(
        None, description='The required extras for this dependency.',
    )


class PoetryMultipleConstraintsDependency(
    RootModel[
        List[
            PoetryDependency | PoetryLongDependency | PoetryGitDependency | PoetryFileDependency | PoetryPathDependency | PoetryUrlDependency
        ]
    ],
):
    root: List[
        PoetryDependency | PoetryLongDependency | PoetryGitDependency | PoetryFileDependency | PoetryPathDependency | PoetryUrlDependency
    ] = Field(..., min_length=1)


class PoetryScriptLegacy(RootModel[str]):
    root: str = Field(..., description='A simple script pointing to a callable object.')


class Type(Enum):
    """Value can be either file or console."""

    file = 'file'
    console = 'console'


class PoetryExtraScripts(DataModel):
    """Either a console entry point or a script file that'll be included in the distribution package."""

    model_config = ConfigDict(
        extra='forbid',
    )
    reference: str = Field(
        ...,
        description='If type is file this is the relative path of the script file, if console it is the module name.',
    )
    type: Type = Field(..., description='Value can be either file or console.')
    extras: List[str] | None = Field(
        None,
        description='The required extras for this script. Only applicable if type is console.',
    )


class PoetryExtraScriptLegacy(DataModel):
    """A script that should be installed only if extras are activated."""

    model_config = ConfigDict(
        extra='forbid',
    )
    callable: PoetryScriptLegacy | None = Field(
        None,
        description='The entry point of the script. Deprecated in favour of reference.',
    )
    extras: List[str] | None = Field(
        None, description='The required extras for this script.',
    )


class PoetryBuildScript(RootModel[str]):
    root: str = Field(
        ..., description='The python script file used to build extensions.',
    )


class PoetryBuildConfig(DataModel):
    """Build specific configurations."""

    model_config = ConfigDict(
        extra='forbid',
    )
    generate_setup_file: bool | None = Field(
        True,
        alias='generate-setup-file',
        description='Generate and include a setup.py file in sdist.',
    )
    script: PoetryBuildScript | None = None


class PoetryBuildSection(RootModel[Union[PoetryBuildScript, PoetryBuildConfig]]):
    root: PoetryBuildScript | PoetryBuildConfig


class Resolution(DataModel):
    """Configuration related to package resolution."""

    model_config = ConfigDict(
        extra='forbid',
    )
    allow_prereleases: bool | None = Field(
        False,
        alias='allow-prereleases',
        description='Whether to allow the use of pre-releases when resolving packages',
    )
    excludes: List[str] | None = Field(
        None,
        description='Package names to be excluded from the resolution result',
        examples=[['requests']],
    )
    respect_source_order: bool | None = Field(
        False,
        alias='respect-source-order',
        description='Whether PDM prefers package sources by order',
    )
    overrides: Dict[str, str] | None = Field(
        None,
        description='Resolution overrides for forcing specific dependency versions',
    )


class Source(Enum):
    """Dynamic version source."""

    file = 'file'
    scm = 'scm'
    call = 'call'


class Version1(DataModel):
    """Dynamic version options for PDM-backend."""

    model_config = ConfigDict(
        extra='forbid',
    )
    source: Source = Field(..., description='Dynamic version source')
    path: str | None = Field(
        None,
        description='Path to python file to read version from (file source)',
        examples=['mypackage/__init__.py'],
    )
    fallback_version: str | None = Field(
        None,
        description='Specify a default version to be used when building from a source tree where SCM is not available (since pdm-backend v2.2.0)',
        examples=['0.0.0'],
    )
    tag_filter: str | None = Field(
        None,
        description="Filters the set of tags which are considered as candidates to capture your project's version (scm source)",
        examples=['test/*'],
    )
    tag_regex: str | None = Field(
        None,
        description='Regex for reading version from source control tag (scm source)',
        examples=[
            '^test/(?:\\D*)?(?P<version>([1-9][0-9]*!)?(0|[1-9][0-9]*)(\\.(0|[1-9][0-9]*))*((a|b|c|rc)(0|[1-9][0-9]*))?(\\.post(0|[1-9][0-9]*))?(\\.dev(0|[1-9][0-9]*))?$)$',
        ],
    )
    version_format: constr(pattern='([\\w.]+):([\\w.]+)\\s*(\\([^)]+\\))?') | None = (
        Field(
            None,
            description='Used to customize the format of the version string (since pdm-backend v2.2.0)',
            examples=['mypackage.version:format_version'],
        )
    )
    getter: str | None = Field(
        None,
        description='Python callable for reading version',
        examples=[
            'mypackage.version.get_version',
            "mypackage.version.get_version('dev')",
        ],
    )
    write_to: str | None = Field(
        None,
        description='File path a generated version should be written to',
        examples=['foo/version.txt', 'foo/_version.py'],
    )
    write_template: str | None = Field(
        None,
        description='Template to use for generated version file',
        examples=["__version__ = '{}'"],
    )


class EditableBackend(Enum):
    """Format of editable wheels."""

    path = 'path'
    editables = 'editables'


class WheelDataArray1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: str = Field(..., description='Path pattern of included files')
    relative_to: str | None = Field(
        None,
        alias='relative-to',
        description='If specified, the relative paths of the matched files will be calculated based on this directory, otherwise the files will be flattened and installed directly under the scheme directory',
    )


class WheelDataArray(RootModel[List[WheelDataArray1 | str]]):
    """Path pattern specifications for build.wheel-data."""

    root: List[WheelDataArray1 | str] = Field(
        ..., description='Path pattern specifications for build.wheel-data',
    )


class EnvVars(RootModel[Optional[Dict[str, str]]]):
    """Environment variables applied when running the script."""

    root: Dict[str, str] | None = None


class EnvFile1(DataModel):
    override: str | None = Field(
        None,
        description='Path to a file with env vars. Existing vars will be overwritten',
    )
    additionalProperties: Any | None = None


class EnvFile(RootModel[Union[EnvFile1, str]]):
    root: EnvFile1 | str


class ScriptHelp(RootModel[str]):
    root: str = Field(
        ..., description='Help text for the script', examples=['Run the tests'],
    )


class PdmScript1(DataModel):
    """PDM script definition."""

    model_config = ConfigDict(
        extra='forbid',
    )
    call: str = Field(
        ...,
        description='Call to a python callable',
        examples=['foo_package.bar_module:main', "foo_package.bar_module:main('dev')"],
    )
    env: EnvVars | None = None
    env_file: EnvFile | None = None
    help: ScriptHelp | None = None


class PdmScript2(DataModel):
    """PDM script definition."""

    model_config = ConfigDict(
        extra='forbid',
    )
    cmd: str | List[str] = Field(
        ...,
        description="Command that can be run from PDM's environment",
        examples=['flask run -p 54321', ['flask', 'run', '-p', '54321']],
    )
    env: EnvVars | None = None
    env_file: EnvFile | None = None
    help: ScriptHelp | None = None


class PdmScript3(DataModel):
    """PDM script definition."""

    model_config = ConfigDict(
        extra='forbid',
    )
    shell: str = Field(
        ...,
        description='Command that will be run in a shell environment',
        examples=['cat error.log|grep CRITICAL > critical.log'],
    )
    env: EnvVars | None = None
    env_file: EnvFile | None = None
    help: ScriptHelp | None = None


class PdmScript4(DataModel):
    """PDM script definition."""

    model_config = ConfigDict(
        extra='forbid',
    )
    composite: List[str] = Field(
        ...,
        description='List of PDM scripts that should be run with this script',
        examples=[['lint', 'test'], ['lint mypackage/', 'test -v tests/']],
    )
    env: EnvVars | None = None
    env_file: EnvFile | None = None
    help: ScriptHelp | None = None
    keep_going: bool | None = Field(
        None,
        description='continue the execution of the remaining scripts after a failure',
    )


class PdmScript(
    RootModel[Union[PdmScript1 | PdmScript2 | PdmScript3 | PdmScript4, str]],
):
    root: PdmScript1 | PdmScript2 | PdmScript3 | PdmScript4 | str = Field(
        ..., description='PDM script definition', examples=['flask run -p 54321'],
    )


class Type1(Enum):
    """index or find_links."""

    index = 'index'
    find_links = 'find_links'


class PackageSource(DataModel):
    """Package source."""

    model_config = ConfigDict(
        extra='forbid',
    )
    name: str = Field(..., description='Name of the package source')
    url: str = Field(..., description='HTTP url for the package source')
    verify_ssl: bool | None = Field(
        None, description='Whether to verify certificates when using the package source',
    )
    username: str | None = Field(None, description='Username for the package source')
    password: str | None = Field(None, description='Password for the package source')
    type: Type1 | None = Field('index', description='index or find_links')
    exclude_packages: List[str] | None = Field(
        None,
        description='Glob patterns of packages that should not be used from this source. Ignored if include_packages configuration is present',
        examples=[['foo', 'foo-*']],
    )
    include_packages: List[str] | None = Field(
        None,
        description='Glob patterns of the only packages that should be used from this source',
        examples=[['foo', 'foo-*']],
    )


class CommandOptions(RootModel[List[str]]):
    """Options that can be applied to a PDM command."""

    root: List[str] = Field(
        ...,
        description='Options that can be applied to a PDM command',
        examples=[
            ['--no-isolation', '--no-self'],
            ['--no-self'],
            ['--no-cross-platform'],
        ],
    )


class DevDependency(RootModel[str]):
    root: str


class DevDependencyGroup(RootModel[List[DevDependency]]):
    root: List[DevDependency] = Field(..., examples=[['pytest>=7.4.3', 'mypy>=1.7.1']])


class TypeCheckingMode(Enum):
    """Specifies the default rule set to use. Some rules can be overridden using additional configuration flags documented below. If set to `off`, all type-checking rules are disabled, but Python syntax and semantic errors are still reported."""

    off = 'off'
    basic = 'basic'
    standard = 'standard'
    strict = 'strict'


class Diagnostic1(Enum):
    none = 'none'
    information = 'information'
    warning = 'warning'
    error = 'error'


class Diagnostic(RootModel[Union[bool, Diagnostic1]]):
    root: bool | Diagnostic1


class ExtraPaths(RootModel[List[constr(pattern=r'^(.*)$')]]):
    """Additional search paths that will be used when searching for modules imported by files."""

    root: List[constr(pattern=r'^(.*)$')] = Field(
        ...,
        description='Additional search paths that will be used when searching for modules imported by files.',
        title='Additional import search resolution paths',
    )


class PythonVersionModel(RootModel[constr(pattern=r'^3\.[0-9]+$')]):
    root: constr(pattern=r'^3\.[0-9]+$') = Field(
        ...,
        description='Specifies the version of Python that will be used to execute the source code. The version should be specified as a string in the format `M.m` where `M` is the major version and `m` is the minor (e.g. `3.0` or `3.6`). If a version is provided, pyright will generate errors if the source code makes use of language features that are not supported in that version. It will also tailor its use of type stub files, which conditionalizes type definitions based on the version. If no version is specified, pyright will use the version of the current python interpreter, if one is present.',
        examples=['3.7'],
        title='Python version to assume during type analysis',
    )


class PythonPlatform(RootModel[constr(pattern=r'^(Linux|Windows|Darwin|All)$')]):
    root: constr(pattern=r'^(Linux|Windows|Darwin|All)$') = Field(
        ...,
        description='Specifies the target platform that will be used to execute the source code. Should be one of `Windows`, `Darwin`, `Linux`, or `All`. If specified, pyright will tailor its use of type stub files, which conditionalize type definitions based on the platform. If no platform is specified, pyright will use the current platform.',
        examples=['Linux'],
        title='Python platform to assume during type analysis',
    )


class DisableBytesTypePromotions(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Disables legacy behavior where `bytearray` and `memoryview` are considered subtypes of bytes. PEP 688 deprecates this behavior, but this switch is provided to restore the older behavior.',
        title='Do not treat `bytearray` and `memoryview` as implicit subtypes of `bytes`',
    )


class StrictListInference(RootModel[bool]):
    root: bool = Field(
        ...,
        description="When inferring the type of a list, use strict type assumptions. For example, the expression `[1, 'a', 3.4]` could be inferred to be of type `list[Any]` or `list[int | str | float]`. If this setting is `true`, it will use the latter (stricter) type.",
        title='Infer strict types for list expressions',
    )


class StrictSetInference(RootModel[bool]):
    root: bool = Field(
        ...,
        description="When inferring the type of a set, use strict type assumptions. For example, the expression `{1, 'a', 3.4}` could be inferred to be of type `set[Any]` or `set[int | str | float]`. If this setting is `true`, it will use the latter (stricter) type.",
        title='Infer strict types for set expressions',
    )


class StrictDictionaryInference(RootModel[bool]):
    root: bool = Field(
        ...,
        description="When inferring the type of a dictionary's keys and values, use strict type assumptions. For example, the expression `{'a': 1, 'b': 'a'}` could be inferred to be of type `dict[str, Any]` or `dict[str, int | str]`. If this setting is `true`, it will use the latter (stricter) type.",
        title='Infer strict types for dictionary expressions',
    )


class AnalyzeUnannotatedFunctions(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Analyze and report errors for functions and methods that have no type annotations for input parameters or return types.',
        title='Analyze and report diagnostics for functions that have no annotations',
    )


class StrictParameterNoneValue(RootModel[bool]):
    root: bool = Field(
        ...,
        description='PEP 484 indicates that when a function parameter is assigned a default value of `None`, its type should implicitly be `Optional` even if the explicit type is not. When enabled, this rule requires that parameter type annotations use `Optional` explicitly in this case.',
        title='Allow implicit Optional when default parameter value is None',
    )


class EnableExperimentalFeatures(RootModel[bool]):
    root: bool = Field(
        ...,
        description='Enables a set of experimental (mostly undocumented) features that correspond to proposed or exploratory changes to the Python typing standard. These features will likely change or be removed, so they should not be used except for experimentation purposes.',
        title='Enable the use of experimental features that are not part of the Python typing spec',
    )


class EnableTypeIgnoreComments(RootModel[bool]):
    root: bool = Field(
        ...,
        description='PEP 484 defines support for `# type: ignore` comments. This switch enables or disables support for these comments. This does not affect `# pyright: ignore` comments.',
        title='Allow `# type: ignore` comments',
    )


class EnableReachabilityAnalysis(RootModel[bool]):
    root: bool = Field(
        ...,
        description='If enabled, code that is determined to be unreachable by type analysis is reported using a tagged hint. This setting does not affect code that is determined to be unreachable regardless of type analysis; such code is always reported as unreachable. This setting also has no effect when when using the command-line version of pyright because it never emits tagged hints for unreachable code.',
        title='Identify code determined to be unreachable through type analysis',
    )


class DeprecateTypingAliases(RootModel[bool]):
    root: bool = Field(
        ...,
        description='PEP 585 indicates that aliases to types in standard collections that were introduced solely to support generics are deprecated as of Python 3.9. This switch controls whether these are treated as deprecated. This applies only when `pythonVersion` is 3.9 or newer. The default value for this setting is `false` but may be switched to `true` in the future.',
        title='Treat typing-specific aliases to standard types as deprecated',
    )


class ReportGeneralTypeIssues(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for general type inconsistencies, unsupported operations, argument/parameter mismatches, etc. This covers all of the basic type-checking rules not covered by other rules. It does not include syntax errors.',
        title='Controls reporting of general type issues',
    )


class ReportPropertyTypeMismatch(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for properties where the type of the value passed to the setter is not assignable to the value returned by the getter. Such mismatches violate the intended use of properties, which are meant to act like variables.',
        title='Controls reporting of property getter/setter type mismatches',
    )


class ReportFunctionMemberAccess(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for non-standard member accesses for functions.',
        title='Controls reporting of member accesses on function objects',
    )


class ReportMissingImports(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for imports that have no corresponding imported python file or type stub file.',
        title='Controls reporting of imports that cannot be resolved',
    )


class ReportMissingModuleSource(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for imports that have no corresponding source file. This happens when a type stub is found, but the module source file was not found, indicating that the code may fail at runtime when using this execution environment. Type checking will be done using the type stub.',
        title='Controls reporting of imports that cannot be resolved to source files',
    )


class ReportInvalidTypeForm(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for type annotations that use invalid type expression forms or are semantically invalid.',
        title='Controls reporting of type expressions that use an invalid form',
    )


class ReportMissingTypeStubs(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for imports that have no corresponding type stub file (either a typeshed file or a custom type stub). The type checker requires type stubs to do its best job at analysis.',
        title='Controls reporting of imports that cannot be resolved to type stub files',
    )


class ReportImportCycles(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for cyclical import chains. These are not errors in Python, but they do slow down type analysis and often hint at architectural layering issues. Generally, they should be avoided. Note that there are import cycles in the typeshed stdlib typestub files that are ignored by this setting.',
        title='Controls reporting of module imports that create cycles in import graph',
    )


class ReportUnusedImport(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an imported symbol that is not referenced within that file.',
        title='Controls reporting of imported symbols that are not referenced within the source file',
    )


class ReportUnusedClass(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a class with a private name (starting with an underscore) that is not accessed.',
        title='Controls reporting of private classes that are not accessed',
    )


class ReportUnusedFunction(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a function or method with a private name (starting with an underscore) that is not accessed.',
        title='Controls reporting of private functions or methods that are not accessed',
    )


class ReportUnusedVariable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a variable that is not accessed. Variables whose names begin with an underscore are exempt from this check.',
        title='Controls reporting of local variables that are not accessed',
    )


class ReportDuplicateImport(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an imported symbol or module that is imported more than once.',
        title='Controls reporting of symbols or modules that are imported more than once',
    )


class ReportWildcardImportFromLibrary(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a wildcard import from an external library. The use of this language feature is highly discouraged and can result in bugs when the library is updated.',
        title='Controls reporting of wildcard import from external library',
    )


class ReportAbstractUsage(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for the attempted instantiate an abstract or protocol class or use of an abstract method.',
        title='Controls reporting of attempted instantiation of abstract class',
    )


class ReportArgumentType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for argument type incompatibilities when evaluating a call expression.',
        title='Controls reporting of incompatible argument type',
    )


class ReportAssertTypeFailure(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a type mismatch detected by the `typing.assert_type` call.',
        title='Controls reporting of type mismatch detected by `typing.assert_type` call',
    )


class ReportAssignmentType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for assignment type incompatibility.',
        title='Controls reporting of type incompatibilities for assignments',
    )


class ReportAttributeAccessIssue(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics related to attribute accesses.',
        title='Controls reporting of issues related to attribute accesses',
    )


class ReportCallIssue(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics related to call expressions and arguments passed to a call target.',
        title='Controls reporting of issues related to call expressions and arguments',
    )


class ReportInconsistentOverload(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an overloaded function that has overload signatures that are inconsistent with each other or with the implementation.',
        title='Controls reporting of inconsistencies between function overload signatures',
    )


class ReportIndexIssue(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics related to index operations and expressions.',
        title='Controls reporting of issues related to index operations and expressions',
    )


class ReportInvalidTypeArguments(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for invalid type argument usage.',
        title='Controls reporting of invalid type argument usage',
    )


class ReportNoOverloadImplementation(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an overloaded function or method if the implementation is not provided.',
        title='Controls reporting of an overloaded function or method with a missing implementation',
    )


class ReportOperatorIssue(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics related to the use of unary or binary operators (like `*` or `not`).',
        title='Controls reporting of diagnostics related to unary and binary operators',
    )


class ReportOptionalSubscript(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to subscript (index) a variable with an `Optional` type.',
        title='Controls reporting of attempts to subscript (index) a variable with `Optional` type',
    )


class ReportOptionalMemberAccess(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to access a member of a variable with an `Optional` type.',
        title='Controls reporting of attempts to access a member of a variable with `Optional` type',
    )


class ReportOptionalCall(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to call a variable with an `Optional` type.',
        title='Controls reporting of attempts to call a variable with `Optional` type',
    )


class ReportOptionalIterable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to use an `Optional` type as an iterable value (e.g. within a `for` statement).',
        title='Controls reporting of attempts to use an `Optional` type as an iterable value',
    )


class ReportOptionalContextManager(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to use an `Optional` type as a context manager (as a parameter to a `with` statement).',
        title='Controls reporting of attempts to use an `Optional` type as a parameter to a `with` statement',
    )


class ReportOptionalOperand(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to use an `Optional` type as an operand to a unary operator (like `~` or `not`) or the left-hand operator of a binary operator (like `*`, `==`, `or`).',
        title='Controls reporting of attempts to use an `Optional` type as an operand for a binary or unary operator',
    )


class ReportRedeclaration(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a symbol that has more than one type declaration.',
        title='Controls reporting of attempts to declare the type of a symbol multiple times',
    )


class ReportReturnType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics related to function return type compatibility.',
        title='Controls reporting of function return type incompatibility',
    )


class ReportTypedDictNotRequiredAccess(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an attempt to access a non-required field within a `TypedDict` without first checking whether it is present.',
        title='Controls reporting of attempts to access a non-required key in a `TypedDict` without a check for its presence',
    )


class ReportUntypedFunctionDecorator(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for function decorators that have no type annotations. These obscure the function type, defeating many type analysis features.',
        title='Controls reporting of function decorators without type annotations, which obscure function types',
    )


class ReportUntypedClassDecorator(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for class decorators that have no type annotations. These obscure the class type, defeating many type analysis features.',
        title='Controls reporting of class decorators without type annotations, which obscure class types',
    )


class ReportUntypedBaseClass(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for base classes whose type cannot be determined statically. These obscure the class type, defeating many type analysis features.',
        title='Controls reporting of a base class of an unknown type, which obscures most type checking for the class',
    )


class ReportUntypedNamedTuple(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics when `namedtuple` is used rather than `NamedTuple`. The former contains no type information, whereas the latter does.',
        title='Controls reporting of a named tuple definition that does not contain type information',
    )


class ReportPrivateUsage(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for incorrect usage of private or protected variables or functions. Protected class members begin with a single underscore (`_`) and can be accessed only by subclasses. Private class members begin with a double underscore but do not end in a double underscore and can be accessed only within the declaring class. Variables and functions declared outside of a class are considered private if their names start with either a single or double underscore, and they cannot be accessed outside of the declaring module.',
        title='Controls reporting of private variables and functions used outside of the owning class or module and usage of protected members outside of subclasses',
    )


class ReportTypeCommentUsage(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Prior to Python 3.5, the grammar did not support type annotations, so types needed to be specified using type comments. Python 3.5 eliminated the need for function type comments, and Python 3.6 eliminated the need for variable type comments. Future versions of Python will likely deprecate all support for type comments. If enabled, this check will flag any type comment usage unless it is required for compatibility with the specified language version.',
        title='Controls reporting of deprecated type comment usage',
    )


class ReportPrivateImportUsage(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for use of a symbol from a `py.typed` module that is not meant to be exported from that module.',
        title='Controls reporting of improper usage of symbol imported from a `py.typed` module that is not re-exported from that module',
    )


class ReportConstantRedefinition(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for attempts to redefine variables whose names are all-caps with underscores and numerals.',
        title='Controls reporting of attempts to redefine variables that are in all-caps',
    )


class ReportDeprecated(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for use of a class or function that has been marked as deprecated.',
        title='Controls reporting of use of deprecated class or function',
    )


class ReportIncompatibleMethodOverride(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for methods that override a method of the same name in a base class in an incompatible manner (wrong number of parameters, incompatible parameter types, or incompatible return type).',
        title='Controls reporting of method overrides in subclasses that redefine the method in an incompatible way',
    )


class ReportIncompatibleVariableOverride(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for class variable declarations that override a symbol of the same name in a base class with a type that is incompatible with the base class symbol type.',
        title='Controls reporting of overrides in subclasses that redefine a variable in an incompatible way',
    )


class ReportInconsistentConstructor(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics when an `__init__` method signature is inconsistent with a `__new__` signature.',
        title='Controls reporting of `__init__` and `__new__` methods whose signatures are inconsistent',
    )


class ReportOverlappingOverload(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for function overloads that overlap in signature and obscure each other or have incompatible return types.',
        title='Controls reporting of function overloads that overlap in signature and obscure each other or do not agree on return type',
    )


class ReportPossiblyUnboundVariable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for variables that are possibly unbound on some code paths.',
        title='Controls reporting of attempts to use variable that is possibly unbound on some code paths',
    )


class ReportMissingSuperCall(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for `__init__`, `__init_subclass__`, `__enter__` and `__exit__` methods in a subclass that fail to call through to the same-named method on a base class.',
        title='Controls reporting of missing call to parent class for inherited `__init__` methods',
    )


class ReportUninitializedInstanceVariable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for instance variables within a class that are not initialized or declared within the class body or the `__init__` method.',
        title='Controls reporting of instance variables that are not initialized in the constructor',
    )


class ReportInvalidStringEscapeSequence(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for invalid escape sequences used within string literals. The Python specification indicates that such sequences will generate a syntax error in future versions.',
        title='Controls reporting of invalid escape sequences used within string literals',
    )


class ReportUnknownParameterType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for input or return parameters for functions or methods that have an unknown type.',
        title='Controls reporting input and return parameters whose types are unknown',
    )


class ReportUnknownArgumentType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for call arguments for functions or methods that have an unknown type.',
        title='Controls reporting argument expressions whose types are unknown',
    )


class ReportUnknownLambdaType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for input or return parameters for lambdas that have an unknown type.',
        title='Controls reporting input and return parameters for lambdas whose types are unknown',
    )


class ReportUnknownVariableType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for variables that have an unknown type.',
        title='Controls reporting local variables whose types are unknown',
    )


class ReportUnknownMemberType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for class or instance variables that have an unknown type.',
        title='Controls reporting class and instance variables whose types are unknown',
    )


class ReportMissingParameterType(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for input parameters for functions or methods that are missing a type annotation. The `self` and `cls` parameters used within methods are exempt from this check.',
        title='Controls reporting input parameters that are missing a type annotation',
    )


class ReportMissingTypeArgument(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics when a generic class is used without providing explicit or implicit type arguments.',
        title='Controls reporting generic class reference with missing type arguments',
    )


class ReportInvalidTypeVarUse(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics when a `TypeVar` is used inappropriately (e.g. if a `TypeVar` appears only once) within a generic function signature.',
        title='Controls reporting improper use of type variables within function signatures',
    )


class ReportCallInDefaultInitializer(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for function calls, list expressions, set expressions, or dictionary expressions within a default value initialization expression. Such calls can mask expensive operations that are performed at module initialization time.',
        title='Controls reporting usage of function calls within a default value initializer expression',
    )


class ReportUnnecessaryIsInstance(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for `isinstance` or `issubclass` calls where the result is statically determined to be always true or always false. Such calls are often indicative of a programming error.',
        title='Controls reporting calls to `isinstance` or `issubclass` where the result is statically determined to be always (or never) true',
    )


class ReportUnnecessaryCast(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for `cast` calls that are statically determined to be unnecessary. Such calls are sometimes indicative of a programming error.',
        title='Controls reporting calls to `cast` that are unnecessary',
    )


class ReportUnnecessaryComparison(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for `==` or `!=` comparisons or other conditional expressions that are statically determined to always evaluate to `False` or `True`. Such comparisons are sometimes indicative of a programming error.',
        title='Controls reporting the use of `==` or `!=` comparisons that are unnecessary',
    )


class ReportUnnecessaryContains(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for `in` operations that are statically determined to always evaluate to `False` or `True`. Such operations are sometimes indicative of a programming error.',
        title='Controls reporting the use of `in` operations that are unnecessary',
    )


class ReportAssertAlwaysTrue(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for `assert` statement that will provably always assert because its first argument is a parenthesized tuple (for example, `assert (v > 0, "Bad value")` when the intent was probably `assert v > 0, "Bad value"`). This is a common programming error.',
        title='Controls reporting `assert` expressions that will always evaluate to `True`',
    )


class ReportSelfClsParameterName(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a missing or misnamed `self` parameter in instance methods and `cls` parameter in class methods. Instance methods in metaclasses (classes that derive from `type`) are allowed to use `cls` for instance methods.',
        title='Controls reporting missing or misnamed `self` parameters',
    )


class ReportImplicitStringConcatenation(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for two or more string literals that follow each other, indicating an implicit concatenation. This is considered a bad practice and often masks bugs such as missing commas.',
        title='Controls reporting usage of implicit concatenation of string literals',
    )


class ReportUnboundVariable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for unbound variables.',
        title='Controls reporting of attempts to use an unbound variable',
    )


class ReportUnhashable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for the use of an unhashable object in a container that requires hashability.',
        title='Controls reporting of unhashable object in container that requires hashability',
    )


class ReportUndefinedVariable(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for undefined variables.',
        title='Controls reporting of attempts to use an undefined variable',
    )


class ReportInvalidStubStatement(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for statements that are syntactically correct but have no purpose within a type stub file.',
        title='Controls reporting of type stub statements that do not conform to PEP 484',
    )


class ReportIncompleteStub(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a module-level `__getattr__` call in a type stub file, indicating that it is incomplete.',
        title='Controls reporting of incomplete type stubs that declare a module-level `__getattr__` function',
    )


class ReportUnsupportedDunderAll(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for statements that define or manipulate `__all__` in a way that is not allowed by a static type checker, thus rendering the contents of `__all__` to be unknown or incorrect. Also reports names within the `__all__` list that are not present in the module namespace.',
        title='Controls reporting of unsupported operations performed on `__all__`',
    )


class ReportUnusedCallResult(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for call statements whose return value is not used in any way and is not `None`.',
        title='Controls reporting of call expressions whose results are not consumed',
    )


class ReportUnusedCoroutine(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for call statements whose return value is not used in any way and is a `Coroutine`. This identifies a common error where an `await` keyword is mistakenly omitted.',
        title='Controls reporting of call expressions that returns `Coroutine` whose results are not consumed',
    )


class ReportUnusedExcept(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for an `except` clause that will never be reached.',
        title='Controls reporting of unreachable except clauses',
    )


class ReportUnusedExpression(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for simple expressions whose results are not used in any way.',
        title='Controls reporting of simple expressions whose value is not used in any way',
    )


class ReportUnnecessaryTypeIgnoreComment(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a `# type: ignore` or `# pyright: ignore` comment that would have no effect if removed.',
        title='Controls reporting of `# type: ignore` comments that have no effect',
    )


class ReportMatchNotExhaustive(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for a `match` statement that does not provide cases that exhaustively match against all potential types of the target expression.',
        title='Controls reporting of `match` statements that do not exhaustively match all possible values',
    )


class ReportShadowedImports(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for files that are overriding a module in the stdlib.',
        title='Controls reporting of shadowed imports of stdlib modules',
    )


class ReportImplicitOverride(RootModel[Diagnostic]):
    root: Diagnostic = Field(
        ...,
        description='Generate or suppress diagnostics for overridden methods in a class that are missing an explicit `@override` decorator.',
        title='Controls reporting overridden methods that are missing an `@override` decorator',
    )


class AnnotationStyle1(Enum):
    """Render the annotations on a single, comma-separated line."""

    line = 'line'


class AnnotationStyle2(Enum):
    """Render each annotation on its own line."""

    split = 'split'


class AnnotationStyle(RootModel[Union[AnnotationStyle1, AnnotationStyle2]]):
    root: AnnotationStyle1 | AnnotationStyle2 = Field(
        ...,
        description='Indicate the style of annotation comments, used to indicate the dependencies that requested each package.',
    )


class ConfigSettingValue1(DataModel):
    """The value consists of a single string."""

    model_config = ConfigDict(
        extra='forbid',
    )
    String: str


class ConfigSettingValue2(DataModel):
    """The value consists of a list of strings."""

    model_config = ConfigDict(
        extra='forbid',
    )
    List: List[str]


class ConfigSettingValue(RootModel[Union[ConfigSettingValue1, ConfigSettingValue2]]):
    root: ConfigSettingValue1 | ConfigSettingValue2


class ConfigSettingsModel(RootModel[Optional[Dict[str, ConfigSettingValue]]]):
    """Settings to pass to a PEP 517 build backend, structured as a map from (string) key to string or list of strings.

    See: <https://peps.python.org/pep-0517/#config-settings>
    """

    root: Dict[str, ConfigSettingValue] | None = None


class ExcludeNewer(
    RootModel[
        constr(pattern=r'^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2}))?$')
    ],
):
    root: constr(
        pattern=r'^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2}(Z|[+-]\d{2}:\d{2}))?$',
    ) = Field(
        ...,
        description='Exclude distributions uploaded after the given timestamp.\n\nAccepts both RFC 3339 timestamps (e.g., `2006-12-02T02:07:43Z`) and local dates in the same format (e.g., `2006-12-02`).',
    )


class ExtraName(RootModel[str]):
    root: str = Field(
        ...,
        description='The normalized name of an extra dependency.\n\nConverts the name to lowercase and collapses runs of `-`, `_`, and `.` down to a single `-`. For example, `---`, `.`, and `__` are all converted to a single `-`.\n\nSee: - <https://peps.python.org/pep-0685/#specification/> - <https://packaging.python.org/en/latest/specifications/name-normalization/>',
    )


class FlatIndexLocation(RootModel[str]):
    root: str = Field(
        ...,
        description='The path to a directory of distributions, or a URL to an HTML file with a flat listing of distributions.',
    )


class IndexStrategy1(Enum):
    """Only use results from the first index that returns a match for a given package name.

    While this differs from pip's behavior, it's the default index strategy as it's the most secure.
    """

    first_index = 'first-index'


class IndexStrategy2(Enum):
    """Search for every package name across all indexes, exhausting the versions from the first index before moving on to the next.

    In this strategy, we look for every package across all indexes. When resolving, we attempt to use versions from the indexes in order, such that we exhaust all available versions from the first index before moving on to the next. Further, if a version is found to be incompatible in the first index, we do not reconsider that version in subsequent indexes, even if the secondary index might contain compatible versions (e.g., variants of the same versions with different ABI tags or Python version constraints).

    See: <https://peps.python.org/pep-0708/>
    """

    unsafe_first_match = 'unsafe-first-match'


class IndexStrategy3(Enum):
    """Search for every package name across all indexes, preferring the "best" version found. If a package version is in multiple indexes, only look at the entry for the first index.

    In this strategy, we look for every package across all indexes. When resolving, we consider all versions from all indexes, choosing the "best" version found (typically, the highest compatible version).

    This most closely matches pip's behavior, but exposes the resolver to "dependency confusion" attacks whereby malicious actors can publish packages to public indexes with the same name as internal packages, causing the resolver to install the malicious package in lieu of the intended internal package.

    See: <https://peps.python.org/pep-0708/>
    """

    unsafe_best_match = 'unsafe-best-match'


class IndexStrategy(RootModel[Union[IndexStrategy1, IndexStrategy2, IndexStrategy3]]):
    root: IndexStrategy1 | IndexStrategy2 | IndexStrategy3


class IndexUrl(RootModel[str]):
    root: str = Field(
        ...,
        description='The URL of an index to use for fetching packages (e.g., `https://pypi.org/simple`).',
    )


class KeyringProviderType1(Enum):
    """Do not use keyring for credential lookup."""

    disabled = 'disabled'


class KeyringProviderType2(Enum):
    """Use the `keyring` command for credential lookup."""

    subprocess = 'subprocess'


class KeyringProviderType(RootModel[Union[KeyringProviderType1, KeyringProviderType2]]):
    root: KeyringProviderType1 | KeyringProviderType2 = Field(
        ..., description='Keyring provider type to use for credential lookup.',
    )


class LinkMode1(Enum):
    """Clone (i.e., copy-on-write) packages from the wheel into the `site-packages` directory."""

    clone = 'clone'


class LinkMode2(Enum):
    """Copy packages from the wheel into the `site-packages` directory."""

    copy = 'copy'


class LinkMode3(Enum):
    """Hard link packages from the wheel into the `site-packages` directory."""

    hardlink = 'hardlink'


class LinkMode4(Enum):
    """Symbolically link packages from the wheel into the `site-packages` directory.

    WARNING: The use of symlinks is discouraged, as they create tight coupling between the cache and the target environment. For example, clearing the cache (`uv cache clear`) will break all installed packages by way of removing the underlying source files. Use symlinks with caution.
    """

    symlink = 'symlink'


class LinkMode(RootModel[Union[LinkMode1, LinkMode2, LinkMode3, LinkMode4]]):
    root: LinkMode1 | LinkMode2 | LinkMode3 | LinkMode4


class PackageNameModel(RootModel[str]):
    root: str = Field(
        ...,
        description='The normalized name of a package.\n\nConverts the name to lowercase and collapses runs of `-`, `_`, and `.` down to a single `-`. For example, `---`, `.`, and `__` are all converted to a single `-`.\n\nSee: <https://packaging.python.org/en/latest/specifications/name-normalization/>',
    )


class PackageNameSpecifier(
    RootModel[
        constr(
            pattern=r'^(:none:|:all:|([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9._-]*[a-zA-Z0-9]))$',
        )
    ],
):
    root: constr(
        pattern=r'^(:none:|:all:|([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9._-]*[a-zA-Z0-9]))$',
    ) = Field(
        ...,
        description='The name of a package, or `:all:` or `:none:` to select or omit all packages, respectively.',
    )


class PrereleaseMode1(Enum):
    """Disallow all pre-release versions."""

    disallow = 'disallow'


class PrereleaseMode2(Enum):
    """Allow all pre-release versions."""

    allow = 'allow'


class PrereleaseMode3(Enum):
    """Allow pre-release versions if all versions of a package are pre-release."""

    if_necessary = 'if-necessary'


class PrereleaseMode4(Enum):
    """Allow pre-release versions for first-party packages with explicit pre-release markers in their version requirements."""

    explicit = 'explicit'


class PrereleaseMode5(Enum):
    """Allow pre-release versions if all versions of a package are pre-release, or if the package has an explicit pre-release marker in its version requirements."""

    if_necessary_or_explicit = 'if-necessary-or-explicit'


class PrereleaseMode(
    RootModel[
        Union[
            PrereleaseMode1,
            PrereleaseMode2,
            PrereleaseMode3,
            PrereleaseMode4,
            PrereleaseMode5,
        ]
    ],
):
    root: PrereleaseMode1 | PrereleaseMode2 | PrereleaseMode3 | PrereleaseMode4 | PrereleaseMode5


class PythonDownloads1(Enum):
    """Automatically download managed Python installations when needed."""

    automatic = 'automatic'


class PythonDownloads2(Enum):
    """Do not automatically download managed Python installations; require explicit installation."""

    manual = 'manual'


class PythonDownloads3(Enum):
    """Do not ever allow Python downloads."""

    never = 'never'


class PythonDownloads(
    RootModel[Union[PythonDownloads1, PythonDownloads2, PythonDownloads3]],
):
    root: PythonDownloads1 | PythonDownloads2 | PythonDownloads3


class PythonPreference1(Enum):
    """Only use managed Python installations; never use system Python installations."""

    only_managed = 'only-managed'


class PythonPreference2(Enum):
    """Prefer managed Python installations over system Python installations.

    System Python installations are still preferred over downloading managed Python versions. Use `only-managed` to always fetch a managed Python version.
    """

    managed = 'managed'


class PythonPreference3(Enum):
    """Prefer system Python installations over managed Python installations.

    If a system Python installation cannot be found, a managed Python installation can be used.
    """

    system = 'system'


class PythonPreference4(Enum):
    """Only use system Python installations; never use managed Python installations."""

    only_system = 'only-system'


class PythonPreference(
    RootModel[
        Union[
            PythonPreference1, PythonPreference2, PythonPreference3, PythonPreference4,
        ]
    ],
):
    root: PythonPreference1 | PythonPreference2 | PythonPreference3 | PythonPreference4


class PythonVersionModel1(RootModel[constr(pattern=r'^3\.\d+(\.\d+)?$')]):
    root: constr(pattern=r'^3\.\d+(\.\d+)?$') = Field(
        ..., description='A Python version specifier, e.g. `3.7` or `3.8.0`.',
    )


class Requirement(RootModel[str]):
    root: str = Field(..., description='A PEP 508 dependency specifier')


class ResolutionMode1(Enum):
    """Resolve the highest compatible version of each package."""

    highest = 'highest'


class ResolutionMode2(Enum):
    """Resolve the lowest compatible version of each package."""

    lowest = 'lowest'


class ResolutionMode3(Enum):
    """Resolve the lowest compatible version of any direct dependencies, and the highest compatible version of any transitive dependencies."""

    lowest_direct = 'lowest-direct'


class ResolutionMode(
    RootModel[Union[ResolutionMode1, ResolutionMode2, ResolutionMode3]],
):
    root: ResolutionMode1 | ResolutionMode2 | ResolutionMode3


class Source1(DataModel):
    """A remote Git repository, available over HTTPS or SSH.

    Example: ```toml flask = { git = "https://github.com/pallets/flask", tag = "3.0.0" } ```
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    branch: str | None = None
    git: AnyUrl = Field(
        ..., description='The repository URL (without the `git+` prefix).',
    )
    rev: str | None = None
    subdirectory: str | None = Field(
        None,
        description="The path to the directory with the `pyproject.toml`, if it's not in the archive root.",
    )
    tag: str | None = None


class Source2(DataModel):
    """A remote `http://` or `https://` URL, either a wheel (`.whl`) or a source distribution (`.zip`, `.tar.gz`).

    Example: ```toml flask = { url = "https://files.pythonhosted.org/packages/61/80/ffe1da13ad9300f87c93af113edd0638c75138c42a0994becfacac078c06/flask-3.0.3-py3-none-any.whl" } ```
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    subdirectory: str | None = Field(
        None,
        description="For source distributions, the path to the directory with the `pyproject.toml`, if it's not in the archive root.",
    )
    url: AnyUrl


class Source3(DataModel):
    """The path to a dependency, either a wheel (a `.whl` file), source distribution (a `.zip` or `.tar.gz` file), or source tree (i.e., a directory containing a `pyproject.toml` or `setup.py` file in the root)."""

    model_config = ConfigDict(
        extra='forbid',
    )
    editable: bool | None = Field(None, description='`false` by default.')
    path: str


class Source4(DataModel):
    """A dependency pinned to a specific index, e.g., `torch` after setting `torch` to `https://download.pytorch.org/whl/cu118`."""

    model_config = ConfigDict(
        extra='forbid',
    )
    index: str


class Source5(DataModel):
    """A dependency on another package in the workspace."""

    model_config = ConfigDict(
        extra='forbid',
    )
    workspace: bool = Field(
        ...,
        description='When set to `false`, the package will be fetched from the remote index, rather than included as a workspace package.',
    )


class Source6(DataModel):
    """A catch-all variant used to emit precise error messages when deserializing."""

    model_config = ConfigDict(
        extra='forbid',
    )
    branch: str | None = None
    git: str
    index: str
    path: str
    rev: str | None = None
    subdirectory: str | None = None
    tag: str | None = None
    url: str
    workspace: bool


class SourceModel(
    RootModel[Union[Source1, Source2, Source3, Source4, Source5, Source6]],
):
    root: Source1 | Source2 | Source3 | Source4 | Source5 | Source6 = Field(
        ..., description='A `tool.uv.sources` value.',
    )


class String(RootModel[str]):
    root: str


class TargetTriple1(Enum):
    """An alias for `x86_64-pc-windows-msvc`, the default target for Windows."""

    windows = 'windows'


class TargetTriple2(Enum):
    """An alias for `x86_64-unknown-linux-gnu`, the default target for Linux."""

    linux = 'linux'


class TargetTriple3(Enum):
    """An alias for `aarch64-apple-darwin`, the default target for macOS."""

    macos = 'macos'


class TargetTriple4(Enum):
    """A 64-bit x86 Windows target."""

    x86_64_pc_windows_msvc = 'x86_64-pc-windows-msvc'


class TargetTriple5(Enum):
    """A 32-bit x86 Windows target."""

    i686_pc_windows_msvc = 'i686-pc-windows-msvc'


class TargetTriple6(Enum):
    """An x86 Linux target. Equivalent to `x86_64-manylinux_2_17`."""

    x86_64_unknown_linux_gnu = 'x86_64-unknown-linux-gnu'


class TargetTriple7(Enum):
    """An ARM-based macOS target, as seen on Apple Silicon devices.

    By default, assumes the least-recent, non-EOL macOS version (12.0), but respects the `MACOSX_DEPLOYMENT_TARGET` environment variable if set.
    """

    aarch64_apple_darwin = 'aarch64-apple-darwin'


class TargetTriple8(Enum):
    """An x86 macOS target.

    By default, assumes the least-recent, non-EOL macOS version (12.0), but respects the `MACOSX_DEPLOYMENT_TARGET` environment variable if set.
    """

    x86_64_apple_darwin = 'x86_64-apple-darwin'


class TargetTriple9(Enum):
    """An ARM64 Linux target. Equivalent to `aarch64-manylinux_2_17`."""

    aarch64_unknown_linux_gnu = 'aarch64-unknown-linux-gnu'


class TargetTriple10(Enum):
    """An ARM64 Linux target."""

    aarch64_unknown_linux_musl = 'aarch64-unknown-linux-musl'


class TargetTriple11(Enum):
    """An `x86_64` Linux target."""

    x86_64_unknown_linux_musl = 'x86_64-unknown-linux-musl'


class TargetTriple12(Enum):
    """An `x86_64` target for the `manylinux_2_17` platform."""

    x86_64_manylinux_2_17 = 'x86_64-manylinux_2_17'


class TargetTriple13(Enum):
    """An `x86_64` target for the `manylinux_2_28` platform."""

    x86_64_manylinux_2_28 = 'x86_64-manylinux_2_28'


class TargetTriple14(Enum):
    """An `x86_64` target for the `manylinux_2_31` platform."""

    x86_64_manylinux_2_31 = 'x86_64-manylinux_2_31'


class TargetTriple15(Enum):
    """An ARM64 target for the `manylinux_2_17` platform."""

    aarch64_manylinux_2_17 = 'aarch64-manylinux_2_17'


class TargetTriple16(Enum):
    """An ARM64 target for the `manylinux_2_28` platform."""

    aarch64_manylinux_2_28 = 'aarch64-manylinux_2_28'


class TargetTriple17(Enum):
    """An ARM64 target for the `manylinux_2_31` platform."""

    aarch64_manylinux_2_31 = 'aarch64-manylinux_2_31'


class TargetTriple(
    RootModel[
        Union[
            TargetTriple1,
            TargetTriple2,
            TargetTriple3,
            TargetTriple4,
            TargetTriple5,
            TargetTriple6,
            TargetTriple7,
            TargetTriple8,
            TargetTriple9,
            TargetTriple10,
            TargetTriple11,
            TargetTriple12,
            TargetTriple13,
            TargetTriple14,
            TargetTriple15,
            TargetTriple16,
            TargetTriple17,
        ]
    ],
):
    root: TargetTriple1 | TargetTriple2 | TargetTriple3 | TargetTriple4 | TargetTriple5 | TargetTriple6 | TargetTriple7 | TargetTriple8 | TargetTriple9 | TargetTriple10 | TargetTriple11 | TargetTriple12 | TargetTriple13 | TargetTriple14 | TargetTriple15 | TargetTriple16 | TargetTriple17 = Field(
        ...,
        description='The supported target triples. Each triple consists of an architecture, vendor, and operating system.\n\nSee: <https://doc.rust-lang.org/nightly/rustc/platform-support.html>',
    )


class ToolUvWorkspace(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    exclude: List[String] | None = Field(
        None,
        description='Packages to exclude as workspace members. If a package matches both `members` and `exclude`, it will be excluded.\n\nSupports both globs and explicit paths.\n\nFor more information on the glob syntax, refer to the [`glob` documentation](https://docs.rs/glob/latest/glob/struct.Pattern.html).',
    )
    members: List[String] | None = Field(
        None,
        description='Packages to include as workspace members.\n\nSupports both globs and explicit paths.\n\nFor more information on the glob syntax, refer to the [`glob` documentation](https://docs.rs/glob/latest/glob/struct.Pattern.html).',
    )


class TrustedHost(RootModel[str]):
    root: str = Field(..., description='A host or host-port pair.')


class ProjectAuthor1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Any
    email: Str | None = Field(None, title='Author email')


class ProjectAuthor2(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: str | None = Field(None, title='Author name')
    email: Str


class ProjectAuthor(RootModel[Union[ProjectAuthor1, ProjectAuthor2]]):
    root: ProjectAuthor1 | ProjectAuthor2


class BuildSystem(DataModel):
    """Build-related data."""

    model_config = ConfigDict(
        extra='forbid',
    )
    requires: List[str] = Field(
        ...,
        description='A list of strings representing [PEP 508](https://www.python.org/dev/peps/pep-0508) dependencies required to execute the build system.\n',
        examples=['setuptools >= 64.0'],
        title='Build system dependencies',
    )
    build_backend: str | None = Field(
        None,
        alias='build-backend',
        description="Python path to project's build backend",
        examples=['setuptools.build_meta', 'my_build_backend:backend'],
        title='Build backend',
    )
    backend_path: List[str] | None = Field(
        None,
        alias='backend-path',
        description="paths to prepend to 'sys.path' when loading the build backend, relative to project root",
        title='Build backend directories',
    )


class Project(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str,StringConstraints(pattern=r'^([a-zA-Z\d]|[a-zA-Z\d][\w.-]*[a-zA-Z\d])$')] = Field(
        ..., title='Project name',
    )
    version: Annotated[str, StringConstraints(pattern='^v?((([0-9]+)!)?([0-9]+(\\.[0-9]+)*)([-_\\.]?(alpha|a|beta|b|preview|pre|c|rc)[-_\\.]?([0-9]+)?)?((-([0-9]+))|([-_\\.]?(post|rev|r)[-_\\.]?([0-9]+)?))?([-_\\.]?(dev)[-_\\.]?([0-9]+)?)?)(\\+([a-z0-9]+([-_\\.][a-z0-9]+)*))?$')] | None = Field(None, examples=['42.0.1', '0.3.9rc7.post0.dev5'], title='Project version')
    description: str | None = Field(None, title='Project summary description')
    readme: str | Readme | Readme1 | None = Field(
        None,
        description='AKA the README',
        examples=[
            'README.md',
            {'file': 'README.txt', 'content-type': 'text/plain'},
            {
                'text': '# Example project\n\nAn example project',
                'content-type': 'text/markdown',
            },
        ],
        title='Project full description',
    )
    requires_python: str | None = Field(
        None,
        alias='requires-python',
        examples=['>= 3.7'],
        title='Python version compatibility',
    )
    license: License | License1 | str | None = Field(
        None,
        examples=[
            {'text': 'MIT'},
            {'file': 'LICENSE'},
            'MIT',
            'LicenseRef-Proprietary',
        ],
        title='Project license',
    )
    license_files: List[str] | None = Field(
        None,
        alias='license-files',
        description='Paths or globs to paths of license files.',
    )
    authors: List[ProjectAuthor] | None = Field(None, title='Project authors')
    maintainers: List[ProjectAuthor] | None = Field(
        None, title='Project maintainers',
    )
    keywords: List[str] | None = Field(None, title='Project keywords')
    classifiers: List[str] | None = Field(None, title='Applicable Trove classifiers')
    urls: Dict[str, AnyUrl] | None = Field(
        None,
        examples=[{'homepage': 'https://example.com/example-project'}],
        title='Project URLs',
    )
    scripts: Dict[str, str] | None = Field(
        None,
        examples=[{'mycmd': 'package.module:object.function'}],
        title='Console scripts',
    )
    gui_scripts: Dict[str, str] | None = Field(
        None,
        alias='gui-scripts',
        examples=[{'mycmd': 'package.module:object.function'}],
        title='GUI scripts',
    )
    entry_points: Dict[constr(pattern='^\\w+(\\.\\w+)*$'), Dict[str, str]] | None = (
        Field(
            None,
            alias='entry-points',
            examples=[
                {'pygments.styles': {'monokai': 'package.module:object.attribute'}},
            ],
            title='Other entry-point groups',
        )
    )
    dependencies: List[str] | None = Field(
        None,
        examples=[['attrs', 'requests ~= 2.28']],
        title='Project dependency requirements',
    )
    optional_dependencies: Dict[constr(pattern='^([a-z\\d]|[a-z\\d][a-z\\d-]*[a-z\\d])$'), List[str]] | None = Field(
        None,
        alias='optional-dependencies',
        description='keys are extra names',
        examples=[{'typing': ['boto3-stubs', 'typing-extensions ~= 4.1']}],
        title='Project extra dependency requirements',
    )
    dynamic: List[DynamicEnum] = Field(
        ..., examples=[['version']], title='Dynamic metadata values',
    )


class Project1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[str, StringConstraints(pattern=r'^([a-zA-Z\d]|[a-zA-Z\d][\w.-]*[a-zA-Z\d])$')] = Field(
        ..., title='Project name',
    )
    version: Any
    description: str | None = Field(None, title='Project summary description')
    readme: str | Readme2 | Readme3 | None = Field(
        None,
        description='AKA the README',
        examples=[
            'README.md',
            {'file': 'README.txt', 'content-type': 'text/plain'},
            {
                'text': '# Example project\n\nAn example project',
                'content-type': 'text/markdown',
            },
        ],
        title='Project full description',
    )
    requires_python: str | None = Field(
        None,
        alias='requires-python',
        examples=['>= 3.7'],
        title='Python version compatibility',
    )
    license: License2 | License3 | str | None = Field(
        None,
        examples=[
            {'text': 'MIT'},
            {'file': 'LICENSE'},
            'MIT',
            'LicenseRef-Proprietary',
        ],
        title='Project license',
    )
    license_files: List[str] | None = Field(
        None,
        alias='license-files',
        description='Paths or globs to paths of license files.',
    )
    authors: List[ProjectAuthor] | None = Field(None, title='Project authors')
    maintainers: List[ProjectAuthor] | None = Field(
        None, title='Project maintainers',
    )
    keywords: List[str] | None = Field(None, title='Project keywords')
    classifiers: List[str] | None = Field(None, title='Applicable Trove classifiers')
    urls: Dict[str, AnyUrl] | None = Field(
        None,
        examples=[{'homepage': 'https://example.com/example-project'}],
        title='Project URLs',
    )
    scripts: Dict[str, str] | None = Field(
        None,
        examples=[{'mycmd': 'package.module:object.function'}],
        title='Console scripts',
    )
    gui_scripts: Dict[str, str] | None = Field(
        None,
        alias='gui-scripts',
        examples=[{'mycmd': 'package.module:object.function'}],
        title='GUI scripts',
    )
    entry_points: Dict[constr(pattern='^\\w+(\\.\\w+)*$'), Dict[str, str]] | None = (
        Field(
            None,
            alias='entry-points',
            examples=[
                {'pygments.styles': {'monokai': 'package.module:object.attribute'}},
            ],
            title='Other entry-point groups',
        )
    )
    dependencies: List[str] | None = Field(
        None,
        examples=[['attrs', 'requests ~= 2.28']],
        title='Project dependency requirements',
    )
    optional_dependencies: Dict[Annotated[str,StringConstraints(pattern='^([a-z\\d]|[a-z\\d][a-z\\d-]*[a-z\\d])$')], List[str]] | None = Field(
        default_factory=dict,
        alias='optional-dependencies',
        description='keys are extra names',
        examples=[{'typing': ['boto3-stubs', 'typing-extensions ~= 4.1']}],
        title='Project extra dependency requirements',
    )
    dynamic: List[DynamicEnum] | None = Field(
        None, examples=[['version']], title='Dynamic metadata values',
    )


class InheritModel1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    before_all: Inherit | None = Field('none', alias='before-all')
    before_build: Inherit | None = Field('none', alias='before-build')
    before_test: Inherit | None = Field('none', alias='before-test')
    config_settings: Inherit | None = Field('none', alias='config-settings')
    container_engine: Inherit | None = Field('none', alias='container-engine')
    environment: Inherit | None = 'none'
    environment_pass: Inherit | None = Field('none', alias='environment-pass')
    repair_wheel_command: Inherit | None = Field(
        'none', alias='repair-wheel-command',
    )
    test_command: Inherit | None = Field('none', alias='test-command')
    test_extras: Inherit | None = Field('none', alias='test-extras')
    test_requires: Inherit | None = Field('none', alias='test-requires')


class Override(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    select: str | List[str]
    inherit: InheritModel1 | None = None
    before_all: BeforeAll | None = Field(None, alias='before-all')
    before_build: BeforeBuild | None = Field(None, alias='before-build')
    before_test: BeforeTest | None = Field(None, alias='before-test')
    build_frontend: BuildFrontendModel | None = Field(None, alias='build-frontend')
    build_verbosity: BuildVerbosity | None = Field(None, alias='build-verbosity')
    config_settings: ConfigSettings | None = Field(None, alias='config-settings')
    container_engine: ContainerEngineModel | None = Field(
        None, alias='container-engine',
    )
    dependency_versions: DependencyVersions | None = Field(
        None, alias='dependency-versions',
    )
    environment: Environment | None = None
    environment_pass: EnvironmentPass | None = Field(None, alias='environment-pass')
    manylinux_aarch64_image: ManylinuxAarch64Image | None = Field(
        None, alias='manylinux-aarch64-image',
    )
    manylinux_i686_image: ManylinuxI686Image | None = Field(
        None, alias='manylinux-i686-image',
    )
    manylinux_ppc64le_image: ManylinuxPpc64leImage | None = Field(
        None, alias='manylinux-ppc64le-image',
    )
    manylinux_pypy_aarch64_image: ManylinuxPypyAarch64Image | None = Field(
        None, alias='manylinux-pypy_aarch64-image',
    )
    manylinux_pypy_i686_image: ManylinuxPypyI686Image | None = Field(
        None, alias='manylinux-pypy_i686-image',
    )
    manylinux_pypy_x86_64_image: ManylinuxPypyX8664Image | None = Field(
        None, alias='manylinux-pypy_x86_64-image',
    )
    manylinux_s390x_image: ManylinuxS390xImage | None = Field(
        None, alias='manylinux-s390x-image',
    )
    manylinux_x86_64_image: ManylinuxX8664Image | None = Field(
        None, alias='manylinux-x86_64-image',
    )
    musllinux_aarch64_image: MusllinuxAarch64Image | None = Field(
        None, alias='musllinux-aarch64-image',
    )
    musllinux_armv7l_image: MusllinuxArmv7lImage | None = Field(
        None, alias='musllinux-armv7l-image',
    )
    musllinux_i686_image: MusllinuxI686Image | None = Field(
        None, alias='musllinux-i686-image',
    )
    musllinux_ppc64le_image: MusllinuxPpc64leImage | None = Field(
        None, alias='musllinux-ppc64le-image',
    )
    musllinux_s390x_image: MusllinuxS390xImage | None = Field(
        None, alias='musllinux-s390x-image',
    )
    musllinux_x86_64_image: MusllinuxX8664Image | None = Field(
        None, alias='musllinux-x86_64-image',
    )
    repair_wheel_command: RepairWheelCommand | None = Field(
        None, alias='repair-wheel-command',
    )
    test_command: TestCommand | None = Field(None, alias='test-command')
    test_extras: TestExtras | None = Field(None, alias='test-extras')
    test_requires: TestRequires | None = Field(None, alias='test-requires')


class Linux(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    archs: Archs | None = None
    before_all: BeforeAll | None = Field(None, alias='before-all')
    before_build: BeforeBuild | None = Field(None, alias='before-build')
    before_test: BeforeTest | None = Field(None, alias='before-test')
    build_frontend: BuildFrontendModel | None = Field(None, alias='build-frontend')
    build_verbosity: BuildVerbosity | None = Field(None, alias='build-verbosity')
    config_settings: ConfigSettings | None = Field(None, alias='config-settings')
    container_engine: ContainerEngineModel | None = Field(
        None, alias='container-engine',
    )
    environment: Environment | None = None
    environment_pass: EnvironmentPass | None = Field(None, alias='environment-pass')
    manylinux_aarch64_image: ManylinuxAarch64Image | None = Field(
        None, alias='manylinux-aarch64-image',
    )
    manylinux_i686_image: ManylinuxI686Image | None = Field(
        None, alias='manylinux-i686-image',
    )
    manylinux_ppc64le_image: ManylinuxPpc64leImage | None = Field(
        None, alias='manylinux-ppc64le-image',
    )
    manylinux_pypy_aarch64_image: ManylinuxPypyAarch64Image | None = Field(
        None, alias='manylinux-pypy_aarch64-image',
    )
    manylinux_pypy_i686_image: ManylinuxPypyI686Image | None = Field(
        None, alias='manylinux-pypy_i686-image',
    )
    manylinux_pypy_x86_64_image: ManylinuxPypyX8664Image | None = Field(
        None, alias='manylinux-pypy_x86_64-image',
    )
    manylinux_s390x_image: ManylinuxS390xImage | None = Field(
        None, alias='manylinux-s390x-image',
    )
    manylinux_x86_64_image: ManylinuxX8664Image | None = Field(
        None, alias='manylinux-x86_64-image',
    )
    musllinux_aarch64_image: MusllinuxAarch64Image | None = Field(
        None, alias='musllinux-aarch64-image',
    )
    musllinux_armv7l_image: MusllinuxArmv7lImage | None = Field(
        None, alias='musllinux-armv7l-image',
    )
    musllinux_i686_image: MusllinuxI686Image | None = Field(
        None, alias='musllinux-i686-image',
    )
    musllinux_ppc64le_image: MusllinuxPpc64leImage | None = Field(
        None, alias='musllinux-ppc64le-image',
    )
    musllinux_s390x_image: MusllinuxS390xImage | None = Field(
        None, alias='musllinux-s390x-image',
    )
    musllinux_x86_64_image: MusllinuxX8664Image | None = Field(
        None, alias='musllinux-x86_64-image',
    )
    repair_wheel_command: str | List[str] | None = Field(
        'auditwheel repair -w {dest_dir} {wheel}',
        alias='repair-wheel-command',
        description='Execute a shell command to repair each built wheel.',
        title='CIBW_REPAIR_WHEEL_COMMAND',
    )
    test_command: TestCommand | None = Field(None, alias='test-command')
    test_extras: TestExtras | None = Field(None, alias='test-extras')
    test_requires: TestRequires | None = Field(None, alias='test-requires')


class Windows(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    archs: Archs | None = None
    before_all: BeforeAll | None = Field(None, alias='before-all')
    before_build: BeforeBuild | None = Field(None, alias='before-build')
    before_test: BeforeTest | None = Field(None, alias='before-test')
    build_frontend: BuildFrontendModel | None = Field(None, alias='build-frontend')
    build_verbosity: BuildVerbosity | None = Field(None, alias='build-verbosity')
    config_settings: ConfigSettings | None = Field(None, alias='config-settings')
    dependency_versions: DependencyVersions | None = Field(
        None, alias='dependency-versions',
    )
    environment: Environment | None = None
    repair_wheel_command: RepairWheelCommand | None = Field(
        None, alias='repair-wheel-command',
    )
    test_command: TestCommand | None = Field(None, alias='test-command')
    test_extras: TestExtras | None = Field(None, alias='test-extras')
    test_requires: TestRequires | None = Field(None, alias='test-requires')


class Macos(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    archs: Archs | None = None
    before_all: BeforeAll | None = Field(None, alias='before-all')
    before_build: BeforeBuild | None = Field(None, alias='before-build')
    before_test: BeforeTest | None = Field(None, alias='before-test')
    build_frontend: BuildFrontendModel | None = Field(None, alias='build-frontend')
    build_verbosity: BuildVerbosity | None = Field(None, alias='build-verbosity')
    config_settings: ConfigSettings | None = Field(None, alias='config-settings')
    dependency_versions: DependencyVersions | None = Field(
        None, alias='dependency-versions',
    )
    environment: Environment | None = None
    repair_wheel_command: str | List[str] | None = Field(
        'delocate-wheel --require-archs {delocate_archs} -w {dest_dir} -v {wheel}',
        alias='repair-wheel-command',
        description='Execute a shell command to repair each built wheel.',
        title='CIBW_REPAIR_WHEEL_COMMAND',
    )
    test_command: TestCommand | None = Field(None, alias='test-command')
    test_extras: TestExtras | None = Field(None, alias='test-extras')
    test_requires: TestRequires | None = Field(None, alias='test-requires')


class Pyodide(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    archs: Archs | None = None
    before_all: BeforeAll | None = Field(None, alias='before-all')
    before_build: BeforeBuild | None = Field(None, alias='before-build')
    before_test: BeforeTest | None = Field(None, alias='before-test')
    build_frontend: BuildFrontendModel | None = Field(None, alias='build-frontend')
    build_verbosity: BuildVerbosity | None = Field(None, alias='build-verbosity')
    config_settings: ConfigSettings | None = Field(None, alias='config-settings')
    dependency_versions: DependencyVersions | None = Field(
        None, alias='dependency-versions',
    )
    environment: Environment | None = None
    repair_wheel_command: RepairWheelCommand | None = Field(
        None, alias='repair-wheel-command',
    )
    test_command: TestCommand | None = Field(None, alias='test-command')
    test_extras: TestExtras | None = Field(None, alias='test-extras')
    test_requires: TestRequires | None = Field(None, alias='test-requires')


class PartialCibuildwheel(DataModel):
    """cibuildwheel's toml file, generated with ./bin/generate_schema.py --schemastore from cibuildwheel."""

    model_config = ConfigDict(
        extra='forbid',
    )
    archs: str | List[str] | None = Field(
        None,
        description='Change the architectures built on your machine by default.',
        title='CIBW_ARCHS',
    )
    before_all: str | List[str] | None = Field(
        None,
        alias='before-all',
        description='Execute a shell command on the build system before any wheels are built.',
        title='CIBW_BEFORE_ALL',
    )
    before_build: str | List[str] | None = Field(
        None,
        alias='before-build',
        description="Execute a shell command preparing each wheel's build.",
        title='CIBW_BEFORE_BUILD',
    )
    before_test: str | List[str] | None = Field(
        None,
        alias='before-test',
        description='Execute a shell command before testing each wheel.',
        title='CIBW_BEFORE_TEST',
    )
    build: str | List[str] | None = Field(
        ['*'], description='Choose the Python versions to build.', title='CIBW_BUILD',
    )
    build_frontend: BuildFrontend | constr(pattern='^pip; ?args:') | constr(pattern='^build; ?args:') | constr(pattern='^build\\[uv\\]; ?args:') | BuildFrontend1 | None = Field(
        'default',
        alias='build-frontend',
        description='Set the tool to use to build, either "pip" (default for now), "build", or "build[uv]"',
        title='CIBW_BUILD_FRONTEND',
    )
    build_verbosity: conint(ge=-3, le=3) | None = Field(
        0,
        alias='build-verbosity',
        description='Increase/decrease the output of pip wheel.',
        title='CIBW_BUILD_VERBOSITY',
    )
    config_settings: str | Dict[constr(pattern='.+'), str | List[str]] | None = Field(
        None,
        alias='config-settings',
        description='Specify config-settings for the build backend.',
        title='CIBW_CONFIG_SETTINGS',
    )
    container_engine: ContainerEngine | constr(pattern='^docker; ?(create_args|disable_host_mount):') | constr(pattern='^podman; ?(create_args|disable_host_mount):') | ContainerEngine1 | None = Field(None, alias='container-engine', title='CIBW_CONTAINER_ENGINE')
    dependency_versions: str | None = Field(
        'pinned',
        alias='dependency-versions',
        description='Specify how cibuildwheel controls the versions of the tools it uses',
        title='CIBW_DEPENDENCY_VERSIONS',
    )
    environment: str | Dict[constr(pattern='.+'), str] | None = Field(
        None,
        description='Set environment variables needed during the build.',
        title='CIBW_ENVIRONMENT',
    )
    environment_pass: str | List[str] | None = Field(
        None,
        alias='environment-pass',
        description='Set environment variables on the host to pass-through to the container during the build.',
        title='CIBW_ENVIRONMENT_PASS',
    )
    free_threaded_support: bool | None = Field(
        False,
        alias='free-threaded-support',
        description='The project supports free-threaded builds of Python (PEP703)',
        title='CIBW_FREE_THREADED_SUPPORT',
    )
    manylinux_aarch64_image: str | None = Field(
        None,
        alias='manylinux-aarch64-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_AARCH64_IMAGE',
    )
    manylinux_i686_image: str | None = Field(
        None,
        alias='manylinux-i686-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_I686_IMAGE',
    )
    manylinux_ppc64le_image: str | None = Field(
        None,
        alias='manylinux-ppc64le-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PPC64LE_IMAGE',
    )
    manylinux_pypy_aarch64_image: str | None = Field(
        None,
        alias='manylinux-pypy_aarch64-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PYPY_AARCH64_IMAGE',
    )
    manylinux_pypy_i686_image: str | None = Field(
        None,
        alias='manylinux-pypy_i686-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PYPY_I686_IMAGE',
    )
    manylinux_pypy_x86_64_image: str | None = Field(
        None,
        alias='manylinux-pypy_x86_64-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_PYPY_X86_64_IMAGE',
    )
    manylinux_s390x_image: str | None = Field(
        None,
        alias='manylinux-s390x-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_S390X_IMAGE',
    )
    manylinux_x86_64_image: str | None = Field(
        None,
        alias='manylinux-x86_64-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MANYLINUX_X86_64_IMAGE',
    )
    musllinux_aarch64_image: str | None = Field(
        None,
        alias='musllinux-aarch64-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_AARCH64_IMAGE',
    )
    musllinux_armv7l_image: str | None = Field(
        None,
        alias='musllinux-armv7l-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_ARMV7L_IMAGE',
    )
    musllinux_i686_image: str | None = Field(
        None,
        alias='musllinux-i686-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_I686_IMAGE',
    )
    musllinux_ppc64le_image: str | None = Field(
        None,
        alias='musllinux-ppc64le-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_PPC64LE_IMAGE',
    )
    musllinux_s390x_image: str | None = Field(
        None,
        alias='musllinux-s390x-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_S390X_IMAGE',
    )
    musllinux_x86_64_image: str | None = Field(
        None,
        alias='musllinux-x86_64-image',
        description='Specify alternative manylinux / musllinux container images',
        title='CIBW_MUSLLINUX_X86_64_IMAGE',
    )
    repair_wheel_command: str | List[str] | None = Field(
        None,
        alias='repair-wheel-command',
        description='Execute a shell command to repair each built wheel.',
        title='CIBW_REPAIR_WHEEL_COMMAND',
    )
    skip: str | List[str] | None = Field(
        None, description='Choose the Python versions to skip.', title='CIBW_SKIP',
    )
    test_command: str | List[str] | None = Field(
        None,
        alias='test-command',
        description='Execute a shell command to test each built wheel.',
        title='CIBW_TEST_COMMAND',
    )
    test_extras: str | List[str] | None = Field(
        None,
        alias='test-extras',
        description='Install your wheel for testing using `extras_require`',
        title='CIBW_TEST_EXTRAS',
    )
    test_requires: str | List[str] | None = Field(
        None,
        alias='test-requires',
        description='Install Python dependencies before running the tests',
        title='CIBW_TEST_REQUIRES',
    )
    test_skip: str | List[str] | None = Field(
        None,
        alias='test-skip',
        description='Skip running tests on some builds.',
        title='CIBW_TEST_SKIP',
    )
    overrides: List[Override] | None = Field(None, description='An overrides array')
    linux: Linux | None = None
    windows: Windows | None = None
    macos: Macos | None = None
    pyodide: Pyodide | None = None


class Override1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    module: str | List[str]
    ignore_missing_imports: IgnoreMissingImports | None = None
    follow_imports: FollowImports | None = 'normal'
    follow_imports_for_stubs: FollowImportsForStubs | None = None
    no_site_packages: NoSitePackages | None = None
    always_true: AlwaysTrue | None = None
    always_false: AlwaysFalse | None = None
    disallow_any_unimported: DisallowAnyUnimported | None = None
    disallow_any_expr: DisallowAnyExpr | None = None
    disallow_any_decorated: DisallowAnyDecorated | None = None
    disallow_any_explicit: DisallowAnyExplicit | None = None
    disallow_any_generics: DisallowAnyGenerics | None = None
    disallow_subclassing_any: DisallowSubclassingAny | None = None
    disallow_untyped_calls: DisallowUntypedCalls | None = None
    untyped_calls_exclude: UntypedCallsExclude | None = None
    disallow_untyped_defs: DisallowUntypedDefs | None = None
    disallow_incomplete_defs: DisallowIncompleteDefs | None = None
    check_untyped_defs: CheckUntypedDefs | None = None
    disallow_untyped_decorators: DisallowUntypedDecorators | None = None
    implicit_optional: ImplicitOptional | None = None
    no_implicit_optional: NoImplicitOptional | None = None
    no_implicit_reexport: NoImplicitReexport | None = None
    strict_optional: StrictOptional | None = None
    warn_unused_ignores: WarnUnusedIgnores | None = None
    warn_no_return: WarnNoReturn | None = None
    warn_return_any: WarnReturnAny | None = None
    warn_unreachable: WarnUnreachable | None = None
    ignore_errors: IgnoreErrors | None = None
    allow_untyped_globals: AllowUntypedGlobals | None = None
    allow_redefinition: AllowRedefinition | None = None
    local_partial_types: LocalPartialTypes | None = None
    disable_error_code: DisableErrorCode | None = None
    enable_error_code: EnableErrorCode | None = None
    implicit_reexport: ImplicitReexport | None = None
    strict_concatenate: StrictConcatenate | None = None
    strict_equality: StrictEquality | None = None
    strict: Strict | None = None
    show_error_context: ShowErrorContext | None = None
    show_column_numbers: ShowColumnNumbers | None = None
    hide_error_codes: HideErrorCodes | None = None
    pretty: Pretty | None = None
    color_output: ColorOutput | None = None
    error_summary: ErrorSummary | None = None
    show_absolute_path: ShowAbsolutePath | None = None
    force_uppercase_builtins: ForceUppercaseBuiltins | None = None
    force_union_syntax: ForceUnionSyntax | None = None
    incremental: Incremental | None = None
    cache_dir: CacheDir | None = None
    sqlite_cache: SqliteCache | None = None
    cache_fine_grained: CacheFineGrained | None = None
    skip_version_check: SkipVersionCheck | None = None
    skip_cache_mtime_checks: SkipCacheMtimeChecks | None = None
    plugins: Plugins | None = None
    pdb: Pdb | None = None
    show_traceback: ShowTraceback | None = None
    raise_exceptions: RaiseExceptions | None = None
    custom_typing_module: CustomTypingModule | None = None
    custom_typeshed_dir: CustomTypeshedDir | None = None
    warn_incomplete_stub: WarnIncompleteStub | None = None
    any_exprs_report: AnyExprsReport | None = None
    cobertura_xml_report: CoberturaXmlReport | None = None
    linecount_report: LinecountReport | None = None
    linecoverage_report: LinecoverageReport | None = None
    lineprecision_report: LineprecisionReport | None = None
    xml_report: XmlReport | None = None
    junit_xml: JunitXml | None = None
    scripts_are_modules: ScriptsAreModules | None = None
    warn_unused_configs: WarnUnusedConfigs | None = None
    verbosity: Verbosity | None = None


class PartialMypy(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    mypy_path: str | List[str] | None = Field(
        None,
        description="Specifies the paths to use, after trying the paths from `MYPYPATH` environment variable. Useful if you'd like to keep stubs in your repo, along with the config file. Multiple paths are always separated with a `:` or `,` regardless of the platform. User home directory and environment variables will be expanded.",
    )
    files: str | List[str] | None = Field(
        None,
        description='A comma-separated list of paths which should be checked by mypy if none are given on the command line. Supports recursive file globbing using `glob`, where `*` (e.g. `*.py`) matches files in the current directory and `**/` (e.g. `**/*.py`) matches files in any directories below the current one. User home directory and environment variables will be expanded.',
    )
    modules: str | List[str] | None = Field(
        None,
        description='A comma-separated list of packages which should be checked by mypy if none are given on the command line. Mypy WILL NOT recursively type check any submodules of the provided module.',
    )
    packages: str | List[str] | None = Field(
        None,
        description='A comma-separated list of packages which should be checked by mypy if none are given on the command line. Mypy WILL recursively type check any submodules of the provided package. This flag is identical to `modules` apart from this behavior.',
    )
    exclude: str | List[str] | None = Field(
        None,
        description='A regular expression that matches file names, directory names and paths which mypy should ignore while recursively discovering files to check. Use forward slashes (`/`) as directory separators on all platforms.',
    )
    namespace_packages: bool | None = Field(
        True,
        description='Enables PEP 420 style namespace packages. See the corresponding flag `--no-namespace-packages` (https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-no-namespace-packages) for more information.',
    )
    explicit_package_bases: bool | None = Field(
        False,
        description='This flag tells mypy that top-level packages will be based in either the current directory, or a member of the `MYPYPATH` environment variable or `mypy_path` config option. This option is only useful in the absence of `__init__.py`. See Mapping file paths to modules (https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-paths-to-modules) for details.',
    )
    ignore_missing_imports: bool | None = Field(
        False,
        description='Suppresses error messages about imports that cannot be resolved.',
    )
    follow_imports: FollowImports | None = Field(
        'normal',
        description='Directs what to do with imports when the imported module is found as a `.py` file and not part of the files, modules and packages provided on the command line.',
    )
    follow_imports_for_stubs: bool | None = Field(
        False,
        description='Determines whether to respect the `follow_imports` setting even for stub (`.pyi`) files.',
    )
    python_executable: str | None = Field(
        None,
        description='Specifies the path to the Python executable to inspect to collect a list of available PEP 561 packages (https://mypy.readthedocs.io/en/stable/installed_packages.html#installed-packages). User home directory and environment variables will be expanded. Defaults to the executable used to run mypy.',
    )
    no_site_packages: bool | None = Field(
        False,
        description='Disables using type information in installed packages (see PEP 561). This will also disable searching for a usable Python executable. This acts the same as :option:`--no-site-packages <mypy --no-site-packages>` command line flag.',
    )
    no_silence_site_packages: bool | None = Field(
        False,
        description='Enables reporting error messages generated within installed packages (see PEP 561 for more details on distributing type information). Those error messages are suppressed by default, since you are usually not able to control errors in 3rd party code.',
    )
    python_version: str | None = Field(
        None,
        description='Specifies the Python version used to parse and check the target program. The string should be in the format `MAJOR.MINOR` (for example, `2.7`). The default is the version of the Python interpreter used to run mypy.',
    )
    platform: str | None = Field(
        None,
        description="Specifies the OS platform for the target program, for example `darwin` or `win32` (meaning OS X or Windows, respectively). The default is the current platform as revealed by Python's `sys.platform` variable.",
    )
    always_true: str | List[str] | None = Field(
        None,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always true.',
    )
    always_false: str | List[str] | None = Field(
        None,
        description='Specifies a list of variables that mypy will treat as compile-time constants that are always false.',
    )
    disallow_any_unimported: bool | None = Field(
        False,
        description='Disallows usage of types that come from unfollowed imports (anything imported from an unfollowed import is automatically given a type of `Any`).',
    )
    disallow_any_expr: bool | None = Field(
        False,
        description='Disallows all expressions in the module that have type `Any`.',
    )
    disallow_any_decorated: bool | None = Field(
        False,
        description='Disallows functions that have `Any` in their signature after decorator transformation.',
    )
    disallow_any_explicit: bool | None = Field(
        False,
        description='Disallows explicit `Any` in type positions such as type annotations and generic type parameters.',
    )
    disallow_any_generics: bool | None = Field(
        False,
        description='Disallows usage of generic types that do not specify explicit type parameters.',
    )
    disallow_subclassing_any: bool | None = Field(
        False, description='Disallows subclassing a value of type `Any`.',
    )
    disallow_untyped_calls: bool | None = Field(
        False,
        description='Disallows calling functions without type annotations from functions with type annotations. Note that when used in per-module options, it enables/disables this check INSIDE the module(s) specified, not for functions that come from that module(s).',
    )
    untyped_calls_exclude: str | List[str] | None = Field(
        None,
        description='Selectively excludes functions and methods defined in specific packages, modules, and classes from action of `disallow_untyped_calls`. This also applies to all submodules of packages (i.e. everything inside a given prefix). Note, this option does not support per-file configuration, the exclusions list is defined globally for all your code.',
    )
    disallow_untyped_defs: bool | None = Field(
        False,
        description='Disallows defining functions without type annotations or with incomplete type annotations (a superset of `disallow_incomplete_defs`).',
    )
    disallow_incomplete_defs: bool | None = Field(
        False,
        description='Disallows defining functions with incomplete type annotations, while still allowing entirely unannotated definitions.',
    )
    check_untyped_defs: bool | None = Field(
        False,
        description='Type-checks the interior of functions without type annotations.',
    )
    disallow_untyped_decorators: bool | None = Field(
        False,
        description='Reports an error whenever a function with type annotations is decorated with a decorator without annotations.',
    )
    implicit_optional: bool | None = Field(
        False,
        description='Causes mypy to treat arguments with a `None` default value as having an implicit `typing.Optional` type.',
    )
    no_implicit_optional: bool | None = Field(
        True, description='Inverse of implicit_optional.',
    )
    no_implicit_reexport: bool | None = Field(
        False,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. This flag changes the behavior to not re-export unless the item is imported using from-as or is included in `__all__`. Note this is always treated as enabled for stub files.',
    )
    strict_optional: bool | None = Field(
        True,
        description='Enables or disables strict `Optional` checks. If `False`, mypy treats `None` as compatible with every type.',
    )
    warn_redundant_casts: bool | None = Field(
        False, description='Warns about casting an expression to its inferred type.',
    )
    warn_unused_ignores: bool | None = Field(
        False, description='Warns about unneeded `# type: ignore` comments.',
    )
    warn_no_return: bool | None = Field(
        True,
        description='Shows errors for missing return statements on some execution paths.',
    )
    warn_return_any: bool | None = Field(
        False,
        description='Shows a warning when returning a value with type `Any` from a function declared with a non-`Any` return type.',
    )
    warn_unreachable: bool | None = Field(
        False,
        description='Shows a warning when encountering any code inferred to be unreachable or redundant after performing type analysis.',
    )
    ignore_errors: bool | None = Field(
        False, description='Ignores all non-fatal errors.',
    )
    allow_untyped_globals: bool | None = Field(
        False,
        description='Causes mypy to suppress errors caused by not being able to fully infer the types of global and class variables.',
    )
    allow_redefinition: bool | None = Field(
        False,
        description='Allows variables to be redefined with an arbitrary type, as long as the redefinition is in the same block and nesting level as the original definition.',
    )
    local_partial_types: bool | None = Field(
        False,
        description='Disallows inferring variable type for `None` from two assignments in different scopes. This is always implicitly enabled when using the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )
    disable_error_code: str | List[str] | None = Field(
        None, description='Allows disabling one or multiple error codes globally.',
    )
    enable_error_code: str | List[str] | None = Field(
        None, description='Allows enabling one or multiple error codes globally.',
    )
    implicit_reexport: bool | None = Field(
        True,
        description='By default, imported values to a module are treated as exported and mypy allows other modules to import them. When false, mypy will not re-export unless the item is imported using from-as or is included in `__all__`. Note that mypy treats stub files as if this is always disabled.',
    )
    strict_concatenate: bool | None = Field(
        False,
        description='Make arguments prepended via `Concatenate` be truly positional-only.',
    )
    extra_checks: bool | None = Field(
        False,
        description='Enable additional checks that are technically correct but impractical.',
    )
    strict_equality: bool | None = Field(
        False,
        description='Prohibit equality checks, identity checks, and container checks between non-overlapping types.',
    )
    strict: bool | None = Field(
        False,
        description='Enable all optional error checking flags. You can see the list of flags enabled by strict mode in the full `mypy --help` output. The exact list of flags enabled by `strict` may change over time.',
    )
    show_error_context: bool | None = Field(
        False, description='Prefixes each error with the relevant context.',
    )
    show_column_numbers: bool | None = Field(
        False, description='Shows column numbers in error messages.',
    )
    hide_error_codes: bool | None = Field(
        False,
        description='Hides error codes (https://mypy.readthedocs.io/en/stable/error_codes.html#error-codes) in error messages.',
    )
    pretty: bool | None = Field(
        False,
        description='Use visually nicer output in error messages: use soft word wrap, show source code snippets, and show error location markers.',
    )
    color_output: bool | None = Field(
        True, description='Shows error messages with color enabled.',
    )
    error_summary: bool | None = Field(
        True, description='Shows a short summary line after error messages.',
    )
    show_absolute_path: bool | None = Field(
        False, description='Show absolute paths to files.',
    )
    force_uppercase_builtins: bool | None = Field(
        False,
        description='Always use `List` instead of `list` in error messages, even on Python 3.9+.',
    )
    force_union_syntax: bool | None = Field(
        False,
        description='Always use `Union[]` and `Optional[]` for union types in error messages (instead of the `|` operator), even on Python 3.10+.',
    )
    incremental: bool | None = Field(
        True,
        description='Enables incremental mode (https://mypy.readthedocs.io/en/stable/command_line.html#incremental).',
    )
    cache_dir: str | None = Field(
        '.mypy_cache',
        description='Specifies the location where mypy stores incremental cache info. User home directory and environment variables will be expanded. This setting will be overridden by the `MYPY_CACHE_DIR` environment variable.',
    )
    sqlite_cache: bool | None = Field(
        False, description='Use an SQLite database to store the cache.',
    )
    cache_fine_grained: bool | None = Field(
        False,
        description='Include fine-grained dependency information in the cache for the mypy daemon (https://mypy.readthedocs.io/en/stable/mypy_daemon.html).',
    )
    skip_version_check: bool | None = Field(
        False,
        description='Makes mypy use incremental cache data even if it was generated by a different version of mypy. (By default, mypy will perform a version check and regenerate the cache if it was written by older versions of mypy.)',
    )
    skip_cache_mtime_checks: bool | None = Field(
        False, description='Skip cache internal consistency checks based on mtime.',
    )
    plugins: str | List[str] | None = Field(
        None, description='A comma-separated list of mypy plugins.',
    )
    pdb: bool | None = Field(
        False,
        description='Invokes `pdb` (https://docs.python.org/3/library/pdb.html) on fatal error.',
    )
    show_traceback: bool | None = Field(
        False, description='Shows traceback on fatal error.',
    )
    raise_exceptions: bool | None = Field(
        False, description='Raise exception on fatal error.',
    )
    custom_typing_module: str | None = Field(
        None,
        description='Specifies a custom module to use as a substitute for the `typing` module.',
    )
    custom_typeshed_dir: str | None = Field(
        None,
        description='This specifies the directory where mypy looks for standard library typeshed stubs, instead of the typeshed that ships with mypy. This is primarily intended to make it easier to test typeshed changes before submitting them upstream, but also allows you to use a forked version of typeshed.',
    )
    warn_incomplete_stub: bool | None = Field(
        False,
        description='Warns about missing type annotations in typeshed. This is only relevant in combination with `disallow_untyped_defs` or `disallow_incomplete_defs`.',
    )
    any_exprs_report: str | None = Field(
        None,
        description='Causes mypy to generate a text file report documenting how many expressions of type `Any` are present within your codebase.',
    )
    cobertura_xml_report: str | None = Field(
        None,
        description='Causes mypy to generate a Cobertura XML type checking coverage report.',
    )
    linecount_report: str | None = Field(
        None,
        description='Causes mypy to generate a text file report documenting the functions and lines that are typed and untyped within your codebase.',
    )
    linecoverage_report: str | None = Field(
        None,
        description="Causes mypy to generate a JSON file that maps each source file's absolute filename to a list of line numbers that belong to typed functions in that file.",
    )
    lineprecision_report: str | None = Field(
        None,
        description='Causes mypy to generate a flat text file report with per-module statistics of how many lines are typechecked etc.',
    )
    xml_report: str | None = Field(
        None,
        description='Causes mypy to generate an XML type checking coverage report.',
    )
    junit_xml: str | None = Field(
        None,
        description='Causes mypy to generate a JUnit XML test result document with type checking results. This can make it easier to integrate mypy with continuous integration (CI) tools.',
    )
    scripts_are_modules: bool | None = Field(
        False,
        description='Makes script `x` become module `x` instead of `__main__`. This is useful when checking multiple scripts in a single run.',
    )
    warn_unused_configs: bool | None = Field(
        False,
        description='Warns about per-module sections in the config file that do not match any files processed when invoking mypy. (This requires turning off incremental mode using `incremental = False`.)',
    )
    verbosity: int | None = Field(
        0,
        description='Controls how much debug output will be generated. Higher numbers are more verbose.',
    )
    show_error_codes: bool | None = Field(
        True,
        description='DEPRECATED and UNDOCUMENTED: Now defaults to true, use `hide_error_codes` if you need to disable error codes instead.',
    )
    show_error_code_links: bool | None = Field(
        False, description='UNDOCUMENTED: show links for error codes.',
    )
    disable_bytearray_promotion: bool | None = Field(
        False,
        description='UNDOCUMENTED. Disables automatic promotion of `bytearray` to `bytes` type. Is set to `true` in strict mode.',
    )
    disable_memoryview_promotion: bool | None = Field(
        False,
        description='UNDOCUMENTED. Disables automatic promotion of `memoryview` to `bytes` type. Is set to `true` in strict mode.',
    )
    enable_incomplete_feature: str | List[str] | None = Field(
        None,
        description='Enable a preview of incomplete features that are not yet enabled by default by the current version of mypy. Note that it is not guaranteed that all features will be ultimately enabled by default.',
    )
    overrides: List[Override1] | None = None


class AnalyzeOptions(DataModel):
    """Configures Ruff's `analyze` command."""

    model_config = ConfigDict(
        extra='forbid',
    )
    detect_string_imports: bool | None = Field(
        None,
        alias='detect-string-imports',
        description='Whether to detect imports from string literals. When enabled, Ruff will search for string literals that "look like" import paths, and include them in the import map, if they resolve to valid Python modules.',
    )
    direction: Direction | None = Field(
        None,
        description='Whether to generate a map from file to files that it depends on (dependencies) or files that depend on it (dependents).',
    )
    exclude: List[str] | None = Field(
        None,
        description='A list of file patterns to exclude from analysis in addition to the files excluded globally (see [`exclude`](#exclude), and [`extend-exclude`](#extend-exclude)).\n\nExclusions are based on globs, and can be either:\n\n- Single-path patterns, like `.mypy_cache` (to exclude any directory named `.mypy_cache` in the tree), `foo.py` (to exclude any file named `foo.py`), or `foo_*.py` (to exclude any file matching `foo_*.py` ). - Relative patterns, like `directory/foo.py` (to exclude that specific file) or `directory/*.py` (to exclude any Python files in `directory`). Note that these paths are relative to the project root (e.g., the directory containing your `pyproject.toml`).\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    include_dependencies: Dict[str, Any] | None = Field(
        None,
        alias='include-dependencies',
        description='A map from file path to the list of file paths or globs that should be considered dependencies of that file, regardless of whether relevant imports are detected.',
    )
    preview: bool | None = Field(
        None,
        description='Whether to enable preview mode. When preview mode is enabled, Ruff will expose unstable commands.',
    )


class DocstringCodeLineWidth(RootModel[Union[LineWidth, Dynamic]]):
    root: LineWidth | Dynamic


class Flake8PytestStyleOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    fixture_parentheses: bool | None = Field(
        None,
        alias='fixture-parentheses',
        description='Boolean flag specifying whether `@pytest.fixture()` without parameters should have parentheses. If the option is set to `false` (the default), `@pytest.fixture` is valid and `@pytest.fixture()` is invalid. If set to `true`, `@pytest.fixture()` is valid and `@pytest.fixture` is invalid.',
    )
    mark_parentheses: bool | None = Field(
        None,
        alias='mark-parentheses',
        description='Boolean flag specifying whether `@pytest.mark.foo()` without parameters should have parentheses. If the option is set to `false` (the default), `@pytest.mark.foo` is valid and `@pytest.mark.foo()` is invalid. If set to `true`, `@pytest.mark.foo()` is valid and `@pytest.mark.foo` is invalid.',
    )
    parametrize_names_type: ParametrizeNameType | None = Field(
        None,
        alias='parametrize-names-type',
        description='Expected type for multiple argument names in `@pytest.mark.parametrize`. The following values are supported:\n\n- `csv` â a comma-separated list, e.g. `@pytest.mark.parametrize("name1,name2", ...)` - `tuple` (default) â e.g. `@pytest.mark.parametrize(("name1", "name2"), ...)` - `list` â e.g. `@pytest.mark.parametrize(["name1", "name2"], ...)`',
    )
    parametrize_values_row_type: ParametrizeValuesRowType | None = Field(
        None,
        alias='parametrize-values-row-type',
        description='Expected type for each row of values in `@pytest.mark.parametrize` in case of multiple parameters. The following values are supported:\n\n- `tuple` (default) â e.g. `@pytest.mark.parametrize(("name1", "name2"), [(1, 2), (3, 4)])` - `list` â e.g. `@pytest.mark.parametrize(("name1", "name2"), [[1, 2], [3, 4]])`',
    )
    parametrize_values_type: ParametrizeValuesType | None = Field(
        None,
        alias='parametrize-values-type',
        description='Expected type for the list of values rows in `@pytest.mark.parametrize`. The following values are supported:\n\n- `tuple` â e.g. `@pytest.mark.parametrize("name", (1, 2, 3))` - `list` (default) â e.g. `@pytest.mark.parametrize("name", [1, 2, 3])`',
    )
    raises_extend_require_match_for: List[str] | None = Field(
        None,
        alias='raises-extend-require-match-for',
        description='List of additional exception names that require a match= parameter in a `pytest.raises()` call. This extends the default list of exceptions that require a match= parameter. This option is useful if you want to extend the default list of exceptions that require a match= parameter without having to specify the entire list. Note that this option does not remove any exceptions from the default list.\n\nSupports glob patterns. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    raises_require_match_for: List[str] | None = Field(
        None,
        alias='raises-require-match-for',
        description='List of exception names that require a match= parameter in a `pytest.raises()` call.\n\nSupports glob patterns. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )


class Flake8QuotesOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    avoid_escape: bool | None = Field(
        None,
        alias='avoid-escape',
        description='Whether to avoid using single quotes if a string contains single quotes, or vice-versa with double quotes, as per [PEP 8](https://peps.python.org/pep-0008/#string-quotes). This minimizes the need to escape quotation marks within strings.',
    )
    docstring_quotes: Quote | None = Field(
        None,
        alias='docstring-quotes',
        description='Quote style to prefer for docstrings (either "single" or "double").\n\nWhen using the formatter, only "double" is compatible, as the formatter enforces double quotes for docstrings strings.',
    )
    inline_quotes: Quote | None = Field(
        None,
        alias='inline-quotes',
        description='Quote style to prefer for inline strings (either "single" or "double").\n\nWhen using the formatter, ensure that [`format.quote-style`](#format_quote-style) is set to the same preferred quote style.',
    )
    multiline_quotes: Quote | None = Field(
        None,
        alias='multiline-quotes',
        description='Quote style to prefer for multiline strings (either "single" or "double").\n\nWhen using the formatter, only "double" is compatible, as the formatter enforces double quotes for multiline strings.',
    )


class Flake8TidyImportsOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ban_relative_imports: Strictness | None = Field(
        None,
        alias='ban-relative-imports',
        description='Whether to ban all relative imports (`"all"`), or only those imports that extend into the parent module or beyond (`"parents"`).',
    )
    banned_api: Dict[str, Any] | None = Field(
        None,
        alias='banned-api',
        description='Specific modules or module members that may not be imported or accessed. Note that this rule is only meant to flag accidental uses, and can be circumvented via `eval` or `importlib`.',
    )
    banned_module_level_imports: List[str] | None = Field(
        None,
        alias='banned-module-level-imports',
        description='List of specific modules that may not be imported at module level, and should instead be imported lazily (e.g., within a function definition, or an `if TYPE_CHECKING:` block, or some other nested context).',
    )


class FormatOptions(DataModel):
    """Configures the way Ruff formats your code."""

    model_config = ConfigDict(
        extra='forbid',
    )
    docstring_code_format: bool | None = Field(
        None,
        alias='docstring-code-format',
        description='Whether to format code snippets in docstrings.\n\nWhen this is enabled, Python code examples within docstrings are automatically reformatted.\n\nFor example, when this is enabled, the following code:\n\n```python def f(x): """ Something about `f`. And an example in doctest format:\n\n>>> f(  x  )\n\nMarkdown is also supported:\n\n```py f(  x  ) ```\n\nAs are reStructuredText literal blocks::\n\nf(  x  )\n\nAnd reStructuredText code blocks:\n\n.. code-block:: python\n\nf(  x  ) """ pass ```\n\n... will be reformatted (assuming the rest of the options are set to their defaults) as:\n\n```python def f(x): """ Something about `f`. And an example in doctest format:\n\n>>> f(x)\n\nMarkdown is also supported:\n\n```py f(x) ```\n\nAs are reStructuredText literal blocks::\n\nf(x)\n\nAnd reStructuredText code blocks:\n\n.. code-block:: python\n\nf(x) """ pass ```\n\nIf a code snippet in a docstring contains invalid Python code or if the formatter would otherwise write invalid Python code, then the code example is ignored by the formatter and kept as-is.\n\nCurrently, doctest, Markdown, reStructuredText literal blocks, and reStructuredText code blocks are all supported and automatically recognized. In the case of unlabeled fenced code blocks in Markdown and reStructuredText literal blocks, the contents are assumed to be Python and reformatted. As with any other format, if the contents aren\'t valid Python, then the block is left untouched automatically.',
    )
    docstring_code_line_length: DocstringCodeLineWidth | None = Field(
        None,
        alias='docstring-code-line-length',
        description='Set the line length used when formatting code snippets in docstrings.\n\nThis only has an effect when the `docstring-code-format` setting is enabled.\n\nThe default value for this setting is `"dynamic"`, which has the effect of ensuring that any reformatted code examples in docstrings adhere to the global line length configuration that is used for the surrounding Python code. The point of this setting is that it takes the indentation of the docstring into account when reformatting code examples.\n\nAlternatively, this can be set to a fixed integer, which will result in the same line length limit being applied to all reformatted code examples in docstrings. When set to a fixed integer, the indent of the docstring is not taken into account. That is, this may result in lines in the reformatted code example that exceed the globally configured line length limit.\n\nFor example, when this is set to `20` and [`docstring-code-format`](#docstring-code-format) is enabled, then this code:\n\n```python def f(x): \'\'\' Something about `f`. And an example:\n\n.. code-block:: python\n\nfoo, bar, quux = this_is_a_long_line(lion, hippo, lemur, bear) \'\'\' pass ```\n\n... will be reformatted (assuming the rest of the options are set to their defaults) as:\n\n```python def f(x): """ Something about `f`. And an example:\n\n.. code-block:: python\n\n( foo, bar, quux, ) = this_is_a_long_line( lion, hippo, lemur, bear, ) """ pass ```',
    )
    exclude: List[str] | None = Field(
        None,
        description='A list of file patterns to exclude from formatting in addition to the files excluded globally (see [`exclude`](#exclude), and [`extend-exclude`](#extend-exclude)).\n\nExclusions are based on globs, and can be either:\n\n- Single-path patterns, like `.mypy_cache` (to exclude any directory named `.mypy_cache` in the tree), `foo.py` (to exclude any file named `foo.py`), or `foo_*.py` (to exclude any file matching `foo_*.py` ). - Relative patterns, like `directory/foo.py` (to exclude that specific file) or `directory/*.py` (to exclude any Python files in `directory`). Note that these paths are relative to the project root (e.g., the directory containing your `pyproject.toml`).\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    indent_style: IndentStyle | None = Field(
        None,
        alias='indent-style',
        description='Whether to use spaces or tabs for indentation.\n\n`indent-style = "space"` (default):\n\n```python def f(): print("Hello") #  Spaces indent the `print` statement. ```\n\n`indent-style = "tab"`:\n\n```python def f(): print("Hello") #  A tab `\\t` indents the `print` statement. ```\n\nPEP 8 recommends using spaces for [indentation](https://peps.python.org/pep-0008/#indentation). We care about accessibility; if you do not need tabs for accessibility, we do not recommend you use them.\n\nSee [`indent-width`](#indent-width) to configure the number of spaces per indentation and the tab width.',
    )
    line_ending: LineEnding | None = Field(
        None,
        alias='line-ending',
        description='The character Ruff uses at the end of a line.\n\n* `auto`: The newline style is detected automatically on a file per file basis. Files with mixed line endings will be converted to the first detected line ending. Defaults to `\\n` for files that contain no line endings. * `lf`: Line endings will be converted to `\\n`. The default line ending on Unix. * `cr-lf`: Line endings will be converted to `\\r\\n`. The default line ending on Windows. * `native`: Line endings will be converted to `\\n` on Unix and `\\r\\n` on Windows.',
    )
    preview: bool | None = Field(
        None, description='Whether to enable the unstable preview style formatting.',
    )
    quote_style: QuoteStyle | None = Field(
        None,
        alias='quote-style',
        description='Configures the preferred quote character for strings. The recommended options are\n\n* `double` (default): Use double quotes `"` * `single`: Use single quotes `\'`\n\nIn compliance with [PEP 8](https://peps.python.org/pep-0008/) and [PEP 257](https://peps.python.org/pep-0257/), Ruff prefers double quotes for triple quoted strings and docstrings even when using `quote-style = "single"`.\n\nRuff deviates from using the configured quotes if doing so prevents the need for escaping quote characters inside the string:\n\n```python a = "a string without any quotes" b = "It\'s monday morning" ```\n\nRuff will change the quotes of the string assigned to `a` to single quotes when using `quote-style = "single"`. However, Ruff uses double quotes for the string assigned to `b` because using single quotes would require escaping the `\'`, which leads to the less readable code: `\'It\\\'s monday morning\'`.\n\nIn addition, Ruff supports the quote style `preserve` for projects that already use a mixture of single and double quotes and can\'t migrate to the `double` or `single` style. The quote style `preserve` leaves the quotes of all strings unchanged.',
    )
    skip_magic_trailing_comma: bool | None = Field(
        None,
        alias='skip-magic-trailing-comma',
        description="Ruff uses existing trailing commas as an indication that short lines should be left separate. If this option is set to `true`, the magic trailing comma is ignored.\n\nFor example, Ruff leaves the arguments separate even though collapsing the arguments to a single line doesn't exceed the line length if `skip-magic-trailing-comma = false`:\n\n```python # The arguments remain on separate lines because of the trailing comma after `b` def test( a, b, ): pass ```\n\nSetting `skip-magic-trailing-comma = true` changes the formatting to:\n\n```python # The arguments remain on separate lines because of the trailing comma after `b` def test(a, b): pass ```",
    )


class ImportSection(RootModel[Union[ImportType, str]]):
    root: ImportType | str


class IsortOptions(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    case_sensitive: bool | None = Field(
        None,
        alias='case-sensitive',
        description='Sort imports taking into account case sensitivity.',
    )
    classes: List[str] | None = Field(
        None,
        description='An override list of tokens to always recognize as a Class for [`order-by-type`](#lint_isort_order-by-type) regardless of casing.',
    )
    combine_as_imports: bool | None = Field(
        None,
        alias='combine-as-imports',
        description="Combines as imports on the same line. See isort's [`combine-as-imports`](https://pycqa.github.io/isort/docs/configuration/options.html#combine-as-imports) option.",
    )
    constants: List[str] | None = Field(
        None,
        description='An override list of tokens to always recognize as a CONSTANT for [`order-by-type`](#lint_isort_order-by-type) regardless of casing.',
    )
    default_section: ImportSection | None = Field(
        None,
        alias='default-section',
        description="Define a default section for any imports that don't fit into the specified [`section-order`](#lint_isort_section-order).",
    )
    detect_same_package: bool | None = Field(
        None,
        alias='detect-same-package',
        description='Whether to automatically mark imports from within the same package as first-party. For example, when `detect-same-package = true`, then when analyzing files within the `foo` package, any imports from within the `foo` package will be considered first-party.\n\nThis heuristic is often unnecessary when `src` is configured to detect all first-party sources; however, if `src` is _not_ configured, this heuristic can be useful to detect first-party imports from _within_ (but not _across_) first-party packages.',
    )
    extra_standard_library: List[str] | None = Field(
        None,
        alias='extra-standard-library',
        description='A list of modules to consider standard-library, in addition to those known to Ruff in advance.\n\nSupports glob patterns. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    force_single_line: bool | None = Field(
        None,
        alias='force-single-line',
        description='Forces all from imports to appear on their own line.',
    )
    force_sort_within_sections: bool | None = Field(
        None,
        alias='force-sort-within-sections',
        description="Don't sort straight-style imports (like `import sys`) before from-style imports (like `from itertools import groupby`). Instead, sort the imports by module, independent of import style.",
    )
    force_to_top: List[str] | None = Field(
        None,
        alias='force-to-top',
        description='Force specific imports to the top of their appropriate section.',
    )
    force_wrap_aliases: bool | None = Field(
        None,
        alias='force-wrap-aliases',
        description="Force `import from` statements with multiple members and at least one alias (e.g., `import A as B`) to wrap such that every line contains exactly one member. For example, this formatting would be retained, rather than condensing to a single line:\n\n```python from .utils import ( test_directory as test_directory, test_id as test_id ) ```\n\nNote that this setting is only effective when combined with `combine-as-imports = true`. When [`combine-as-imports`](#lint_isort_combine-as-imports) isn't enabled, every aliased `import from` will be given its own line, in which case, wrapping is not necessary.\n\nWhen using the formatter, ensure that [`format.skip-magic-trailing-comma`](#format_skip-magic-trailing-comma) is set to `false` (default) when enabling `force-wrap-aliases` to avoid that the formatter collapses members if they all fit on a single line.",
    )
    forced_separate: List[str] | None = Field(
        None,
        alias='forced-separate',
        description='A list of modules to separate into auxiliary block(s) of imports, in the order specified.',
    )
    from_first: bool | None = Field(
        None,
        alias='from-first',
        description='Whether to place `import from` imports before straight imports when sorting.\n\nFor example, by default, imports will be sorted such that straight imports appear before `import from` imports, as in: ```python import os import sys from typing import List ```\n\nSetting `from-first = true` will instead sort such that `import from` imports appear before straight imports, as in: ```python from typing import List import os import sys ```',
    )
    known_first_party: List[str] | None = Field(
        None,
        alias='known-first-party',
        description='A list of modules to consider first-party, regardless of whether they can be identified as such via introspection of the local filesystem.\n\nSupports glob patterns. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    known_local_folder: List[str] | None = Field(
        None,
        alias='known-local-folder',
        description='A list of modules to consider being a local folder. Generally, this is reserved for relative imports (`from . import module`).\n\nSupports glob patterns. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    known_third_party: List[str] | None = Field(
        None,
        alias='known-third-party',
        description='A list of modules to consider third-party, regardless of whether they can be identified as such via introspection of the local filesystem.\n\nSupports glob patterns. For more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    length_sort: bool | None = Field(
        None,
        alias='length-sort',
        description='Sort imports by their string length, such that shorter imports appear before longer imports. For example, by default, imports will be sorted alphabetically, as in: ```python import collections import os ```\n\nSetting `length-sort = true` will instead sort such that shorter imports appear before longer imports, as in: ```python import os import collections ```',
    )
    length_sort_straight: bool | None = Field(
        None,
        alias='length-sort-straight',
        description="Sort straight imports by their string length. Similar to [`length-sort`](#lint_isort_length-sort), but applies only to straight imports and doesn't affect `from` imports.",
    )
    lines_after_imports: int | None = Field(
        None,
        alias='lines-after-imports',
        description='The number of blank lines to place after imports. Use `-1` for automatic determination.\n\nRuff uses at most one blank line after imports in typing stub files (files with `.pyi` extension) in accordance to the typing style recommendations ([source](https://typing.readthedocs.io/en/latest/source/stubs.html#blank-lines)).\n\nWhen using the formatter, only the values `-1`, `1`, and `2` are compatible because it enforces at least one empty and at most two empty lines after imports.',
    )
    lines_between_types: conint(ge=0) | None = Field(
        None,
        alias='lines-between-types',
        description='The number of lines to place between "direct" and `import from` imports.\n\nWhen using the formatter, only the values `0` and `1` are compatible because it preserves up to one empty line after imports in nested blocks.',
    )
    no_lines_before: List[ImportSection] | None = Field(
        None,
        alias='no-lines-before',
        description='A list of sections that should _not_ be delineated from the previous section via empty lines.',
    )
    no_sections: bool | None = Field(
        None,
        alias='no-sections',
        description='Put all imports into the same section bucket.\n\nFor example, rather than separating standard library and third-party imports, as in: ```python import os import sys\n\nimport numpy import pandas ```\n\nSetting `no-sections = true` will instead group all imports into a single section: ```python import numpy import os import pandas import sys ```',
    )
    order_by_type: bool | None = Field(
        None,
        alias='order-by-type',
        description='Order imports by type, which is determined by case, in addition to alphabetically.',
    )
    relative_imports_order: RelativeImportsOrder | None = Field(
        None,
        alias='relative-imports-order',
        description='Whether to place "closer" imports (fewer `.` characters, most local) before "further" imports (more `.` characters, least local), or vice versa.\n\nThe default ("furthest-to-closest") is equivalent to isort\'s [`reverse-relative`](https://pycqa.github.io/isort/docs/configuration/options.html#reverse-relative) default (`reverse-relative = false`); setting this to "closest-to-furthest" is equivalent to isort\'s `reverse-relative = true`.',
    )
    required_imports: List[NameImports] | None = Field(
        None,
        alias='required-imports',
        description='Add the specified import line to all files.',
    )
    section_order: List[ImportSection] | None = Field(
        None,
        alias='section-order',
        description='Override in which order the sections should be output. Can be used to move custom sections.',
    )
    sections: Dict[str, Any] | None = Field(
        None,
        description='A list of mappings from section names to modules.\n\nBy default, imports are categorized according to their type (e.g., `future`, `third-party`, and so on). This setting allows you to group modules into custom sections, to augment or override the built-in sections.\n\nFor example, to group all testing utilities, you could create a `testing` section: ```toml testing = ["pytest", "hypothesis"] ```\n\nThe values in the list are treated as glob patterns. For example, to match all packages in the LangChain ecosystem (`langchain-core`, `langchain-openai`, etc.): ```toml langchain = ["langchain-*"] ```\n\nCustom sections should typically be inserted into the [`section-order`](#lint_isort_section-order) list to ensure that they\'re displayed as a standalone group and in the intended order, as in: ```toml section-order = [ "future", "standard-library", "third-party", "first-party", "local-folder", "testing" ] ```\n\nIf a custom section is omitted from [`section-order`](#lint_isort_section-order), imports in that section will be assigned to the [`default-section`](#lint_isort_default-section) (which defaults to `third-party`).',
    )
    single_line_exclusions: List[str] | None = Field(
        None,
        alias='single-line-exclusions',
        description='One or more modules to exclude from the single line rule.',
    )
    split_on_trailing_comma: bool | None = Field(
        None,
        alias='split-on-trailing-comma',
        description="If a comma is placed after the last member in a multi-line import, then the imports will never be folded into one line.\n\nSee isort's [`split-on-trailing-comma`](https://pycqa.github.io/isort/docs/configuration/options.html#split-on-trailing-comma) option.\n\nWhen using the formatter, ensure that [`format.skip-magic-trailing-comma`](#format_skip-magic-trailing-comma) is set to `false` (default) when enabling `split-on-trailing-comma` to avoid that the formatter removes the trailing commas.",
    )
    variables: List[str] | None = Field(
        None,
        description='An override list of tokens to always recognize as a var for [`order-by-type`](#lint_isort_order-by-type) regardless of casing.',
    )


class LintOptions(DataModel):
    """Configures how Ruff checks your code.

    Options specified in the `lint` section take precedence over the deprecated top-level settings.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    allowed_confusables: List[constr(min_length=1, max_length=1)] | None = Field(
        None,
        alias='allowed-confusables',
        description='A list of allowed "confusable" Unicode characters to ignore when enforcing `RUF001`, `RUF002`, and `RUF003`.',
    )
    dummy_variable_rgx: str | None = Field(
        None,
        alias='dummy-variable-rgx',
        description='A regular expression used to identify "dummy" variables, or those which should be ignored when enforcing (e.g.) unused-variable rules. The default expression matches `_`, `__`, and `_var`, but not `_var_`.',
    )
    exclude: List[str] | None = Field(
        None,
        description='A list of file patterns to exclude from linting in addition to the files excluded globally (see [`exclude`](#exclude), and [`extend-exclude`](#extend-exclude)).\n\nExclusions are based on globs, and can be either:\n\n- Single-path patterns, like `.mypy_cache` (to exclude any directory named `.mypy_cache` in the tree), `foo.py` (to exclude any file named `foo.py`), or `foo_*.py` (to exclude any file matching `foo_*.py` ). - Relative patterns, like `directory/foo.py` (to exclude that specific file) or `directory/*.py` (to exclude any Python files in `directory`). Note that these paths are relative to the project root (e.g., the directory containing your `pyproject.toml`).\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    explicit_preview_rules: bool | None = Field(
        None,
        alias='explicit-preview-rules',
        description='Whether to require exact codes to select preview rules. When enabled, preview rules will not be selected by prefixes â the full code of each preview rule will be required to enable the rule.',
    )
    extend_fixable: List[RuleSelector] | None = Field(
        None,
        alias='extend-fixable',
        description='A list of rule codes or prefixes to consider fixable, in addition to those specified by [`fixable`](#lint_fixable).',
    )
    extend_ignore: List[RuleSelector] | None = Field(
        None,
        alias='extend-ignore',
        description='A list of rule codes or prefixes to ignore, in addition to those specified by `ignore`.',
    )
    extend_per_file_ignores: Dict[str, Any] | None = Field(
        None,
        alias='extend-per-file-ignores',
        description='A list of mappings from file pattern to rule codes or prefixes to exclude, in addition to any rules excluded by [`per-file-ignores`](#lint_per-file-ignores).',
    )
    extend_safe_fixes: List[RuleSelector] | None = Field(
        None,
        alias='extend-safe-fixes',
        description='A list of rule codes or prefixes for which unsafe fixes should be considered safe.',
    )
    extend_select: List[RuleSelector] | None = Field(
        None,
        alias='extend-select',
        description='A list of rule codes or prefixes to enable, in addition to those specified by [`select`](#lint_select).',
    )
    extend_unfixable: List[RuleSelector] | None = Field(
        None,
        alias='extend-unfixable',
        description='A list of rule codes or prefixes to consider non-auto-fixable, in addition to those specified by [`unfixable`](#lint_unfixable).',
    )
    extend_unsafe_fixes: List[RuleSelector] | None = Field(
        None,
        alias='extend-unsafe-fixes',
        description='A list of rule codes or prefixes for which safe fixes should be considered unsafe.',
    )
    external: List[str] | None = Field(
        None,
        description='A list of rule codes or prefixes that are unsupported by Ruff, but should be preserved when (e.g.) validating `# noqa` directives. Useful for retaining `# noqa` directives that cover plugins not yet implemented by Ruff.',
    )
    fixable: List[RuleSelector] | None = Field(
        None,
        description='A list of rule codes or prefixes to consider fixable. By default, all rules are considered fixable.',
    )
    flake8_annotations: Flake8AnnotationsOptions | None = Field(
        None,
        alias='flake8-annotations',
        description='Options for the `flake8-annotations` plugin.',
    )
    flake8_bandit: Flake8BanditOptions | None = Field(
        None,
        alias='flake8-bandit',
        description='Options for the `flake8-bandit` plugin.',
    )
    flake8_boolean_trap: Flake8BooleanTrapOptions | None = Field(
        None,
        alias='flake8-boolean-trap',
        description='Options for the `flake8-boolean-trap` plugin.',
    )
    flake8_bugbear: Flake8BugbearOptions | None = Field(
        None,
        alias='flake8-bugbear',
        description='Options for the `flake8-bugbear` plugin.',
    )
    flake8_builtins: Flake8BuiltinsOptions | None = Field(
        None,
        alias='flake8-builtins',
        description='Options for the `flake8-builtins` plugin.',
    )
    flake8_comprehensions: Flake8ComprehensionsOptions | None = Field(
        None,
        alias='flake8-comprehensions',
        description='Options for the `flake8-comprehensions` plugin.',
    )
    flake8_copyright: Flake8CopyrightOptions | None = Field(
        None,
        alias='flake8-copyright',
        description='Options for the `flake8-copyright` plugin.',
    )
    flake8_errmsg: Flake8ErrMsgOptions | None = Field(
        None,
        alias='flake8-errmsg',
        description='Options for the `flake8-errmsg` plugin.',
    )
    flake8_gettext: Flake8GetTextOptions | None = Field(
        None,
        alias='flake8-gettext',
        description='Options for the `flake8-gettext` plugin.',
    )
    flake8_implicit_str_concat: Flake8ImplicitStrConcatOptions | None = Field(
        None,
        alias='flake8-implicit-str-concat',
        description='Options for the `flake8-implicit-str-concat` plugin.',
    )
    flake8_import_conventions: Flake8ImportConventionsOptions | None = Field(
        None,
        alias='flake8-import-conventions',
        description='Options for the `flake8-import-conventions` plugin.',
    )
    flake8_pytest_style: Flake8PytestStyleOptions | None = Field(
        None,
        alias='flake8-pytest-style',
        description='Options for the `flake8-pytest-style` plugin.',
    )
    flake8_quotes: Flake8QuotesOptions | None = Field(
        None,
        alias='flake8-quotes',
        description='Options for the `flake8-quotes` plugin.',
    )
    flake8_self: Flake8SelfOptions | None = Field(
        None, alias='flake8-self', description='Options for the `flake8_self` plugin.',
    )
    flake8_tidy_imports: Flake8TidyImportsOptions | None = Field(
        None,
        alias='flake8-tidy-imports',
        description='Options for the `flake8-tidy-imports` plugin.',
    )
    flake8_type_checking: Flake8TypeCheckingOptions | None = Field(
        None,
        alias='flake8-type-checking',
        description='Options for the `flake8-type-checking` plugin.',
    )
    flake8_unused_arguments: Flake8UnusedArgumentsOptions | None = Field(
        None,
        alias='flake8-unused-arguments',
        description='Options for the `flake8-unused-arguments` plugin.',
    )
    ignore: List[RuleSelector] | None = Field(
        None,
        description='A list of rule codes or prefixes to ignore. Prefixes can specify exact rules (like `F841`), entire categories (like `F`), or anything in between.\n\nWhen breaking ties between enabled and disabled rules (via `select` and `ignore`, respectively), more specific prefixes override less specific prefixes.',
    )
    ignore_init_module_imports: bool | None = Field(
        None,
        alias='ignore-init-module-imports',
        description="Avoid automatically removing unused imports in `__init__.py` files. Such imports will still be flagged, but with a dedicated message suggesting that the import is either added to the module's `__all__` symbol, or re-exported with a redundant alias (e.g., `import os as os`).\n\nThis option is enabled by default, but you can opt-in to removal of imports via an unsafe fix.",
    )
    isort: IsortOptions | None = Field(
        None, description='Options for the `isort` plugin.',
    )
    logger_objects: List[str] | None = Field(
        None,
        alias='logger-objects',
        description='A list of objects that should be treated equivalently to a `logging.Logger` object.\n\nThis is useful for ensuring proper diagnostics (e.g., to identify `logging` deprecations and other best-practices) for projects that re-export a `logging.Logger` object from a common module.\n\nFor example, if you have a module `logging_setup.py` with the following contents: ```python import logging\n\nlogger = logging.getLogger(__name__) ```\n\nAdding `"logging_setup.logger"` to `logger-objects` will ensure that `logging_setup.logger` is treated as a `logging.Logger` object when imported from other modules (e.g., `from logging_setup import logger`).',
    )
    mccabe: McCabeOptions | None = Field(
        None, description='Options for the `mccabe` plugin.',
    )
    pep8_naming: Pep8NamingOptions | None = Field(
        None, alias='pep8-naming', description='Options for the `pep8-naming` plugin.',
    )
    per_file_ignores: Dict[str, Any] | None = Field(
        None,
        alias='per-file-ignores',
        description="A list of mappings from file pattern to rule codes or prefixes to exclude, when considering any matching files. An initial '!' negates the file pattern.",
    )
    preview: bool | None = Field(
        None,
        description='Whether to enable preview mode. When preview mode is enabled, Ruff will use unstable rules and fixes.',
    )
    pycodestyle: PycodestyleOptions | None = Field(
        None, description='Options for the `pycodestyle` plugin.',
    )
    pydocstyle: PydocstyleOptions | None = Field(
        None, description='Options for the `pydocstyle` plugin.',
    )
    pyflakes: PyflakesOptions | None = Field(
        None, description='Options for the `pyflakes` plugin.',
    )
    pylint: PylintOptions | None = Field(
        None, description='Options for the `pylint` plugin.',
    )
    pyupgrade: PyUpgradeOptions | None = Field(
        None, description='Options for the `pyupgrade` plugin.',
    )
    ruff: RuffOptions | None = Field(
        None, description='Options for the `ruff` plugin',
    )
    select: List[RuleSelector] | None = Field(
        None,
        description='A list of rule codes or prefixes to enable. Prefixes can specify exact rules (like `F841`), entire categories (like `F`), or anything in between.\n\nWhen breaking ties between enabled and disabled rules (via `select` and `ignore`, respectively), more specific prefixes override less specific prefixes.',
    )
    task_tags: List[str] | None = Field(
        None,
        alias='task-tags',
        description='A list of task tags to recognize (e.g., "TODO", "FIXME", "XXX").\n\nComments starting with these tags will be ignored by commented-out code detection (`ERA`), and skipped by line-length rules (`E501`) if [`ignore-overlong-task-comments`](#lint_pycodestyle_ignore-overlong-task-comments) is set to `true`.',
    )
    typing_modules: List[str] | None = Field(
        None,
        alias='typing-modules',
        description='A list of modules whose exports should be treated equivalently to members of the `typing` module.\n\nThis is useful for ensuring proper type annotation inference for projects that re-export `typing` and `typing_extensions` members from a compatibility module. If omitted, any members imported from modules apart from `typing` and `typing_extensions` will be treated as ordinary Python objects.',
    )
    unfixable: List[RuleSelector] | None = Field(
        None, description='A list of rule codes or prefixes to consider non-fixable.',
    )


class Hatch1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    metadata: Metadata | None = None
    env: CollectorEnv | None = None
    envs: Envs | None = None
    build: Build | None = None
    version: Any | None = None
    publish: Publish | None = None


class Hatch2(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    metadata: Metadata | None = None
    env: CollectorEnv | None = None
    envs: Envs | None = None
    build: Build | None = None
    version: Version
    publish: Publish | None = None


class Hatch(RootModel[Union[Hatch1, Hatch2]]):
    root: Hatch1 | Hatch2 = Field(..., title='Hatch')


class If(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    any: IfOverrides


class Cmake1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    args: InheritModel | None = 'none'
    define: InheritModel | None = 'none'
    targets: InheritModel | None = 'none'


class Sdist1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    include: InheritModel | None = 'none'
    exclude: InheritModel | None = 'none'


class Wheel1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    packages: InheritModel | None = 'none'
    license_files: InheritModel | None = Field('none', alias='license-files')
    exclude: InheritModel | None = 'none'


class Build4(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    tool_args: InheritModel | None = Field('none', alias='tool-args')
    targets: InheritModel | None = 'none'


class Install1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    components: InheritModel | None = 'none'


class Inherit1(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    cmake: Cmake1 | None = None
    sdist: Sdist1 | None = None
    wheel: Wheel1 | None = None
    build: Build4 | None = None
    install: Install1 | None = None


class Override3(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    if_: IfOverrides | If = Field(..., alias='if')
    inherit: Inherit1 | None = None
    cmake: CmakeModel | None = None
    ninja: Ninja | None = None
    logging: LoggingModel | None = None
    sdist: Sdist | None = None
    wheel: Wheel | None = None
    backport: Backport | None = None
    editable: EditableModel | None = None
    build: Build3 | None = None
    install: Install | None = None
    generate: GenerateModel | None = None
    messages: Messages | None = None
    metadata: MetadataModel1 | None = None
    strict_config: StrictConfig | None = Field(None, alias='strict-config')
    experimental: Experimental | None = None
    minimum_version: MinimumVersion | None = Field(None, alias='minimum-version')
    build_dir: BuildDir | None = Field(None, alias='build-dir')
    fail: Fail | None = None


class PartialScikitBuild(DataModel):
    """Scikit-build-core's settings."""

    model_config = ConfigDict(
        extra='forbid',
    )
    cmake: Cmake | None = None
    ninja: Ninja | None = None
    logging: Logging | None = None
    sdist: Sdist | None = None
    wheel: Wheel | None = None
    backport: Backport | None = None
    editable: Editable | None = None
    build: Build3 | None = None
    install: Install | None = None
    generate: List[Generate | Generate1] | None = None
    messages: Messages | None = None
    metadata: MetadataModel1 | None = Field(
        None,
        description='List dynamic metadata fields and hook locations in this table.',
    )
    strict_config: bool | None = Field(
        True,
        alias='strict-config',
        description='Strictly check all config options. If False, warnings will be printed for unknown options. If True, an error will be raised.',
    )
    experimental: bool | None = Field(
        False, description='Enable early previews of features not finalized yet.',
    )
    minimum_version: str | None = Field(
        None,
        alias='minimum-version',
        description='If set, this will provide a method for backward compatibility.',
    )
    build_dir: str | None = Field(
        '',
        alias='build-dir',
        description='The build directory. Defaults to a temporary directory, but can be set.',
    )
    fail: bool | None = Field(
        False,
        description='Immediately fail the build. This is only useful in overrides.',
    )
    overrides: List[Override3] | None = Field(
        None,
        description='A list of overrides to apply to the settings, based on the `if` selector.',
    )


class Readme4(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    content_type: str | None = Field(None, alias='content-type')
    file: File


class Dynamic1(DataModel):
    """Instructions for loading :pep:`621`-related metadata dynamically."""

    model_config = ConfigDict(
        extra='forbid',
    )
    version: AttrDirective | FileDirective | None = Field(
        None,
        description='A version dynamically loaded via either the ``attr:`` or ``file:`` directives. Please make sure the given file or attribute respects :pep:`440`. Also ensure to set ``project.dynamic`` accordingly.',
    )
    classifiers: FileDirective | None = None
    description: FileDirective | None = None
    entry_points: FileDirective | None = Field(None, alias='entry-points')
    dependencies: FileDirectiveForDependencies | None = None
    optional_dependencies: Dict[constr(pattern='.+'), FileDirectiveForDependencies] | None = Field(None, alias='optional-dependencies')
    readme: FileDirective | Readme4 | None = None


class PartialSetuptools(DataModel):
    """``setuptools``-specific configurations that can be set by users that require customization. These configurations are completely optional and probably can be skipped when creating simple packages. They are equivalent to some of the `Keywords <https://setuptools.pypa.io/en/latest/references/keywords.html>`_ used by the ``setup.py`` file, and can be set via the ``tool.setuptools`` table. It considers only ``setuptools`` `parameters <https://setuptools.pypa.io/en/latest/userguide/pyproject_config.html#setuptools-specific-configuration>`_ that are not covered by :pep:`621`; and intentionally excludes ``dependency_links`` and ``setup_requires`` (incompatible with modern workflows/standards)."""

    model_config = ConfigDict(
        extra='forbid',
    )
    platforms: List[str] | None = None
    provides: List[str] | None = Field(
        None,
        description='Package and virtual package names contained within this package **(not supported by pip)**',
    )
    obsoletes: List[str] | None = Field(
        None,
        description='Packages which this package renders obsolete **(not supported by pip)**',
    )
    zip_safe: bool | None = Field(
        None,
        alias='zip-safe',
        description='Whether the project can be safely installed and run from a zip file. **OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and ``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).',
    )
    script_files: List[str] | None = Field(
        None,
        alias='script-files',
        description='Legacy way of defining scripts (entry-points are preferred). Equivalent to the ``script`` keyword in ``setup.py`` (it was renamed to avoid confusion with entry-point based ``project.scripts`` defined in :pep:`621`). **DISCOURAGED**: generic script wrappers are tricky and may not work properly. Whenever possible, please use ``project.scripts`` instead.',
    )
    eager_resources: List[str] | None = Field(
        None,
        alias='eager-resources',
        description='Resources that should be extracted together, if any of them is needed, or if any C extensions included in the project are imported. **OBSOLETE**: only relevant for ``pkg_resources``, ``easy_install`` and ``setup.py install`` in the context of ``eggs`` (**DEPRECATED**).',
    )
    packages: List[PackageName] | FindDirective | None = Field(
        None,
        description='Packages that should be included in the distribution. It can be given either as a list of package identifiers or as a ``dict``-like structure with a single key ``find`` which corresponds to a dynamic call to ``setuptools.config.expand.find_packages`` function. The ``find`` key is associated with a nested ``dict``-like structure that can contain ``where``, ``include``, ``exclude`` and ``namespaces`` keys, mimicking the keyword arguments of the associated function.',
    )
    package_dir: Dict[constr(pattern='^.*$'), str] | None = Field(
        None,
        alias='package-dir',
        description=':class:`dict`-like structure mapping from package names to directories where their code can be found. The empty string (as key) means that all packages are contained inside the given directory will be included in the distribution.',
    )
    package_data: Dict[constr(pattern='^.*$'), List[str]] | None = Field(
        None,
        alias='package-data',
        description='Mapping from package names to lists of glob patterns. Usually this option is not needed when using ``include-package-data = true`` For more information on how to include data files, check ``setuptools`` `docs <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.',
    )
    include_package_data: bool | None = Field(
        None,
        alias='include-package-data',
        description='Automatically include any data files inside the package directories that are specified by ``MANIFEST.in`` For more information on how to include data files, check ``setuptools`` `docs <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.',
    )
    exclude_package_data: Dict[constr(pattern='^.*$'), List[str]] | None = Field(
        None,
        alias='exclude-package-data',
        description='Mapping from package names to lists of glob patterns that should be excluded For more information on how to include data files, check ``setuptools`` `docs <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.',
    )
    namespace_packages: List[str] | None = Field(
        None,
        alias='namespace-packages',
        description='**DEPRECATED**: use implicit namespaces instead (:pep:`420`).',
    )
    py_modules: List[str] | None = Field(
        None, alias='py-modules', description='Modules that setuptools will manipulate',
    )
    data_files: Dict[constr(pattern='^.*$'), List[str]] | None = Field(
        None,
        alias='data-files',
        description='``dict``-like structure where each key represents a directory and the value is a list of glob patterns that should be installed in them. **DISCOURAGED**: please notice this might not work as expected with wheels. Whenever possible, consider using data files inside the package directories (or create a new namespace package that only contains data files). See `data files support <https://setuptools.pypa.io/en/latest/userguide/datafiles.html>`_.',
    )
    cmdclass: Dict[constr(pattern='^.*$'), str] | None = Field(
        None,
        description='Mapping of distutils-style command names to ``setuptools.Command`` subclasses which in turn should be represented by strings with a qualified class name (i.e., "dotted" form with module), e.g.::\n\n     cmdclass = {mycmd = "pkg.subpkg.module.CommandClass"}\n\n The command class should be a directly defined at the top-level of the containing module (no class nesting).',
    )
    license_files: List[str] | None = Field(
        None,
        alias='license-files',
        description="**PROVISIONAL**: list of glob patterns for all license files being distributed. (likely to become standard with :pep:`639`). By default: ``['LICEN[CS]E*', 'COPYING*', 'NOTICE*', 'AUTHORS*']``",
    )
    dynamic: Dynamic1 | None = Field(
        None,
        description='Instructions for loading :pep:`621`-related metadata dynamically',
    )


class Package(DataModel):
    """Information about where the package resides."""

    model_config = ConfigDict(
        extra='forbid',
    )
    include: PoetryIncludePath
    from_: str | None = Field(
        None,
        alias='from',
        description='Where the source directory of the package resides.',
    )
    format: PoetryPackageFormats | None = None
    to: str | None = Field(
        None,
        description='Where the package should be installed in the final distribution.',
    )


class Include(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    path: PoetryIncludePath
    format: PoetryPackageFormats | None = None


class Dependencies(DataModel):
    """This is a hash of package name (keys) and version constraints (values) that are required to run this package."""

    python: PoetryDependency = Field(
        ..., description='The Python versions the package is compatible with.',
    )


class PoetryDependencyAny(
    RootModel[
        Union[
            PoetryDependency,
            PoetryLongDependency,
            PoetryGitDependency,
            PoetryFileDependency,
            PoetryPathDependency,
            PoetryUrlDependency,
            PoetryMultipleConstraintsDependency,
        ]
    ],
):
    root: PoetryDependency | PoetryLongDependency | PoetryGitDependency | PoetryFileDependency | PoetryPathDependency | PoetryUrlDependency | PoetryMultipleConstraintsDependency


class PoetryScriptTable(RootModel[Union[PoetryExtraScriptLegacy, PoetryExtraScripts]]):
    root: PoetryExtraScriptLegacy | PoetryExtraScripts


class DevDependencies(DataModel):
    """Development dependencies."""

    dev: DevDependencyGroup | None = Field(
        None, description='The default dev dependencies',
    )


class Options(DataModel):
    """Default options applied to a PDM command."""

    add: CommandOptions | None = None
    build: CommandOptions | None = None
    cache: CommandOptions | None = None
    completion: CommandOptions | None = None
    config: CommandOptions | None = None
    export: CommandOptions | None = None
    fix: CommandOptions | None = None
    import_: CommandOptions | None = Field(None, alias='import')
    info: CommandOptions | None = None
    init: CommandOptions | None = None
    install: CommandOptions | None = None
    list: CommandOptions | None = None
    lock: CommandOptions | None = None
    publish: CommandOptions | None = None
    remove: CommandOptions | None = None
    run: CommandOptions | None = None
    search: CommandOptions | None = None
    self: CommandOptions | None = None
    show: CommandOptions | None = None
    sync: CommandOptions | None = None
    update: CommandOptions | None = None
    use: CommandOptions | None = None
    venv: CommandOptions | None = None


class FieldModel(DataModel):
    """Shared options for all scripts
    https://pdm-project.org/latest/usage/scripts/#shared-options.
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    env: EnvVars | None = None
    env_file: EnvFile | None = None


class Scripts(DataModel):
    """Definition of PDM scripts."""

    field_: FieldModel | None = Field(
        None,
        alias='_',
        description='Shared options for all scripts\nhttps://pdm-project.org/latest/usage/scripts/#shared-options',
    )
    post_init: PdmScript | None = None
    pre_install: PdmScript | None = None
    post_install: PdmScript | None = None
    pre_lock: PdmScript | None = None
    post_lock: PdmScript | None = None
    pre_build: PdmScript | None = None
    post_build: PdmScript | None = None
    pre_publish: PdmScript | None = None
    post_publish: PdmScript | None = None
    pre_script: PdmScript | None = None
    post_script: PdmScript | None = None
    pre_run: PdmScript | None = None
    post_run: PdmScript | None = None


class WheelData(DataModel):
    """Configuration for additional files to be written to a user's site-packages directory."""

    model_config = ConfigDict(
        extra='forbid',
    )
    scripts: WheelDataArray | None = None
    purelib: WheelDataArray | None = None
    platlib: WheelDataArray | None = None
    include: WheelDataArray | None = None
    platinclude: WheelDataArray | None = None
    data: WheelDataArray | None = None


class Build5(DataModel):
    """Configuration related to the build process with pdm-backend."""

    model_config = ConfigDict(
        extra='forbid',
    )
    includes: List[str] | None = Field(
        None,
        description='Path patterns of files to be included in the package',
        examples=[['mypackage/', 'script.py']],
    )
    excludes: List[str] | None = Field(
        None,
        description='Path patterns of files to be excluded from package',
        examples=[['**/*.json']],
    )
    source_includes: List[str] | None = Field(
        None,
        alias='source-includes',
        description='Path patterns of files that are needed for building but not meant to be copied to the site-packages directory',
        examples=[['scripts/', 'tests/']],
    )
    package_dir: str | None = Field(
        None,
        alias='package-dir',
        description='Directory where packages are located. The default value is src if src/ is found and . otherwise',
        examples=['mysrc', 'src', '.'],
    )
    custom_hook: str | None = Field(
        'pdm_build.py',
        alias='custom-hook',
        description='Python file that should be run before every build',
        examples=['build.py'],
    )
    run_setuptools: bool | None = Field(
        False,
        alias='run-setuptools',
        description='Whether to auto-generate setup.py and run setuptools with it. Useful for building C extensions',
    )
    is_purelib: bool | None = Field(
        None,
        alias='is-purelib',
        description='Whether builds should be platform specific',
    )
    editable_backend: EditableBackend | None = Field(
        'path', alias='editable-backend', description='Format of editable wheels',
    )
    wheel_data: WheelData | None = Field(
        None,
        alias='wheel-data',
        description="Configuration for additional files to be written to a user's site-packages directory",
    )


class PartialPdm(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    distribution: bool | None = Field(
        True, description='Whether the project needs to be distributed',
    )
    ignore_package_warnings: List[str] | None = Field(
        None,
        description='Ignore package resolution warnings for packages matching the given patterns (PDM v2.10.0)',
        examples=[['scipy', 'tensorflow-*']],
    )
    dev_dependencies: DevDependencies | None = Field(
        None, alias='dev-dependencies', description='Development dependencies',
    )
    resolution: Resolution | None = Field(
        None, description='Configuration related to package resolution',
    )
    options: Options | None = Field(
        None,
        description='Default options applied to a PDM command',
        examples=[
            {
                'add': ['--no-isolation', '--no-self'],
                'install': ['--no-self'],
                'lock': ['--no-cross-platform'],
            },
        ],
    )
    plugins: List[str] | None = Field(
        None,
        description='List of PDM plugins required for this project',
        examples=[['pdm-packer']],
    )
    source: List[PackageSource] | None = Field(
        None, description='Sources used for package resolution',
    )
    scripts: Scripts | None = Field(None, description='Definition of PDM scripts')
    version: Version1 | None = Field(
        None, description='Dynamic version options for PDM-backend',
    )
    build: Build5 | None = Field(
        None, description='Configuration related to the build process with pdm-backend',
    )


class ExecutionEnvironment(DataModel):
    root: constr(pattern=r'^(.*)$') = Field(
        ...,
        description='Root path for the code that will execute within this execution environment.',
        title='Path to code subdirectory to which these settings apply',
    )
    disableBytesTypePromotions: DisableBytesTypePromotions | None = None
    strictListInference: StrictListInference | None = None
    strictSetInference: StrictSetInference | None = None
    strictDictionaryInference: StrictDictionaryInference | None = None
    analyzeUnannotatedFunctions: AnalyzeUnannotatedFunctions | None = None
    strictParameterNoneValue: StrictParameterNoneValue | None = None
    enableExperimentalFeatures: EnableExperimentalFeatures | None = None
    enableTypeIgnoreComments: EnableTypeIgnoreComments | None = None
    enableReachabilityAnalysis: EnableReachabilityAnalysis | None = None
    deprecateTypingAliases: DeprecateTypingAliases | None = None
    reportGeneralTypeIssues: ReportGeneralTypeIssues | None = None
    reportPropertyTypeMismatch: ReportPropertyTypeMismatch | None = None
    reportFunctionMemberAccess: ReportFunctionMemberAccess | None = None
    reportMissingImports: ReportMissingImports | None = None
    reportMissingModuleSource: ReportMissingModuleSource | None = None
    reportInvalidTypeForm: ReportInvalidTypeForm | None = None
    reportMissingTypeStubs: ReportMissingTypeStubs | None = None
    reportImportCycles: ReportImportCycles | None = None
    reportUnusedImport: ReportUnusedImport | None = None
    reportUnusedClass: ReportUnusedClass | None = None
    reportUnusedFunction: ReportUnusedFunction | None = None
    reportUnusedVariable: ReportUnusedVariable | None = None
    reportDuplicateImport: ReportDuplicateImport | None = None
    reportWildcardImportFromLibrary: ReportWildcardImportFromLibrary | None = None
    reportAbstractUsage: ReportAbstractUsage | None = None
    reportArgumentType: ReportArgumentType | None = None
    reportAssertTypeFailure: ReportAssertTypeFailure | None = None
    reportAssignmentType: ReportAssignmentType | None = None
    reportAttributeAccessIssue: ReportAttributeAccessIssue | None = None
    reportCallIssue: ReportCallIssue | None = None
    reportInconsistentOverload: ReportInconsistentOverload | None = None
    reportIndexIssue: ReportIndexIssue | None = None
    reportInvalidTypeArguments: ReportInvalidTypeArguments | None = None
    reportNoOverloadImplementation: ReportNoOverloadImplementation | None = None
    reportOperatorIssue: ReportOperatorIssue | None = None
    reportOptionalSubscript: ReportOptionalSubscript | None = None
    reportOptionalMemberAccess: ReportOptionalMemberAccess | None = None
    reportOptionalCall: ReportOptionalCall | None = None
    reportOptionalIterable: ReportOptionalIterable | None = None
    reportOptionalContextManager: ReportOptionalContextManager | None = None
    reportOptionalOperand: ReportOptionalOperand | None = None
    reportRedeclaration: ReportRedeclaration | None = None
    reportReturnType: ReportReturnType | None = None
    reportTypedDictNotRequiredAccess: ReportTypedDictNotRequiredAccess | None = None
    reportUntypedFunctionDecorator: ReportUntypedFunctionDecorator | None = None
    reportUntypedClassDecorator: ReportUntypedClassDecorator | None = None
    reportUntypedBaseClass: ReportUntypedBaseClass | None = None
    reportUntypedNamedTuple: ReportUntypedNamedTuple | None = None
    reportPrivateUsage: ReportPrivateUsage | None = None
    reportTypeCommentUsage: ReportTypeCommentUsage | None = None
    reportPrivateImportUsage: ReportPrivateImportUsage | None = None
    reportConstantRedefinition: ReportConstantRedefinition | None = None
    reportDeprecated: ReportDeprecated | None = None
    reportIncompatibleMethodOverride: ReportIncompatibleMethodOverride | None = None
    reportIncompatibleVariableOverride: ReportIncompatibleVariableOverride | None = (
        None
    )
    reportInconsistentConstructor: ReportInconsistentConstructor | None = None
    reportOverlappingOverload: ReportOverlappingOverload | None = None
    reportPossiblyUnboundVariable: ReportPossiblyUnboundVariable | None = None
    reportMissingSuperCall: ReportMissingSuperCall | None = None
    reportUninitializedInstanceVariable: ReportUninitializedInstanceVariable | None = None
    reportInvalidStringEscapeSequence: ReportInvalidStringEscapeSequence | None = (
        None
    )
    reportUnknownParameterType: ReportUnknownParameterType | None = None
    reportUnknownArgumentType: ReportUnknownArgumentType | None = None
    reportUnknownLambdaType: ReportUnknownLambdaType | None = None
    reportUnknownVariableType: ReportUnknownVariableType | None = None
    reportUnknownMemberType: ReportUnknownMemberType | None = None
    reportMissingParameterType: ReportMissingParameterType | None = None
    reportMissingTypeArgument: ReportMissingTypeArgument | None = None
    reportInvalidTypeVarUse: ReportInvalidTypeVarUse | None = None
    reportCallInDefaultInitializer: ReportCallInDefaultInitializer | None = None
    reportUnnecessaryIsInstance: ReportUnnecessaryIsInstance | None = None
    reportUnnecessaryCast: ReportUnnecessaryCast | None = None
    reportUnnecessaryComparison: ReportUnnecessaryComparison | None = None
    reportUnnecessaryContains: ReportUnnecessaryContains | None = None
    reportAssertAlwaysTrue: ReportAssertAlwaysTrue | None = None
    reportSelfClsParameterName: ReportSelfClsParameterName | None = None
    reportImplicitStringConcatenation: ReportImplicitStringConcatenation | None = (
        None
    )
    reportUnboundVariable: ReportUnboundVariable | None = None
    reportUnhashable: ReportUnhashable | None = None
    reportUndefinedVariable: ReportUndefinedVariable | None = None
    reportInvalidStubStatement: ReportInvalidStubStatement | None = None
    reportIncompleteStub: ReportIncompleteStub | None = None
    reportUnsupportedDunderAll: ReportUnsupportedDunderAll | None = None
    reportUnusedCallResult: ReportUnusedCallResult | None = None
    reportUnusedCoroutine: ReportUnusedCoroutine | None = None
    reportUnusedExcept: ReportUnusedExcept | None = None
    reportUnusedExpression: ReportUnusedExpression | None = None
    reportUnnecessaryTypeIgnoreComment: ReportUnnecessaryTypeIgnoreComment | None = (
        None
    )
    reportMatchNotExhaustive: ReportMatchNotExhaustive | None = None
    reportShadowedImports: ReportShadowedImports | None = None
    reportImplicitOverride: ReportImplicitOverride | None = None
    extraPaths: ExtraPaths | None = None
    pythonVersion: PythonVersionModel | None = None
    pythonPlatform: PythonPlatform | None = None


class PartialPyright(DataModel):
    """Pyright Configuration Schema."""

    extends: constr(pattern='^(.*)$') | None = Field(
        None,
        description='Path to another `.json` or `.toml` file that is used as a "base configuration", allowing this configuration to inherit configuration settings. Top-level keys within this configuration overwrite top-level keys in the base configuration. Multiple levels of inheritance are supported. Relative paths specified in a configuration file are resolved relative to the location of that configuration file.',
        title='Path to configuration file that this configuration extends',
    )
    include: List[constr(pattern='^(.*)$')] | None = Field(
        None,
        description='Paths of directories or files that should be considered part of the project. If no paths are specified, pyright defaults to the directory that contains the config file. Paths may contain wildcard characters: `**` (a directory or multiple levels of directories), `*` (a sequence of zero or more characters), or `?` (a single character). If no include paths are specified, the root path for the workspace is assumed.',
        title='Files and directories included in type analysis',
    )
    exclude: List[constr(pattern='^(.*)$')] | None = Field(
        None,
        description='Paths of directories or files that should not be considered part of the project. These override the includes directories and files, allowing specific subdirectories to be excluded. Note that files in the exclude paths may still be included in the analysis if they are referenced (imported) by source files that are not excluded. Paths may contain wildcard characters: `**` (a directory or multiple levels of directories), `*` (a sequence of zero or more characters), or `?` (a single character). If no exclude paths are specified, Pyright automatically excludes the following: `**/node_modules`, `**/__pycache__`, `**/.*` and any virtual environment directories.',
        title='Files and directories excluded from type analysis',
    )
    ignore: List[constr(pattern='^(.*)$')] | None = Field(
        None,
        description='Paths of directories or files whose diagnostic output (errors and warnings) should be suppressed even if they are an included file or within the transitive closure of an included file. Paths may contain wildcard characters: `**` (a directory or multiple levels of directories), `*` (a sequence of zero or more characters), or `?` (a single character).',
        title='Files and directories whose diagnostics are suppressed',
    )
    strict: List[constr(pattern='^(.*)$')] | None = Field(
        None,
        description='Paths of directories or files that should use "strict" analysis if they are included. This is the same as manually adding a `# pyright: strict` comment. In strict mode, most type-checking rules are enabled. Paths may contain wildcard characters: `**` (a directory or multiple levels of directories), `*` (a sequence of zero or more characters), or `?` (a single character).',
        title='Files and directories that should use "strict" type checking rules',
    )
    defineConstant: Dict[str, str | bool] | None = Field(
        None,
        description='Set of identifiers that should be assumed to contain a constant value wherever used within this program. For example, `{ "DEBUG": true }` indicates that pyright should assume that the identifier `DEBUG` will always be equal to `True`. If this identifier is used within a conditional expression (such as `if not DEBUG:`) pyright will use the indicated value to determine whether the guarded block is reachable or not. Member expressions that reference one of these constants (e.g. `my_module.DEBUG`) are also supported.',
        title='Identifiers that should be treated as constants',
    )
    typeCheckingMode: TypeCheckingMode | None = Field(
        'standard',
        description='Specifies the default rule set to use. Some rules can be overridden using additional configuration flags documented below. If set to `off`, all type-checking rules are disabled, but Python syntax and semantic errors are still reported.',
        title='Specifies the default rule set to use for type checking',
    )
    useLibraryCodeForTypes: bool | None = Field(
        True,
        description='Determines whether pyright reads, parses and analyzes library code to extract type information in the absence of type stub files. Type information will typically be incomplete. We recommend using type stubs where possible.',
        title='Use library implementations to extract type information when type stub is not present',
    )
    typeshedPath: constr(pattern='^(.*)$') | None = Field(
        '',
        description="Path to a directory that contains `typeshed` type stub files. Pyright ships with a bundled copy of `typeshed` type stubs. If you want to use a different version of `typeshed` stubs, you can clone the `typeshed` GitHub repo (https://github.com/python/typeshed) to a local directory and reference the location with this path. This option is useful if you're actively contributing updates to `typeshed`.",
        title='Path to directory containing `typeshed` type stub files',
    )
    stubPath: constr(pattern='^(.*)$') | None = Field(
        './typings',
        description="Path to a directory that contains custom type stubs. Each package's type stub file(s) are expected to be in its own subdirectory.",
        examples=['src/typestubs'],
        title='Path to directory containing custom type stub files',
    )
    disableBytesTypePromotions: DisableBytesTypePromotions | None = None
    strictListInference: StrictListInference | None = None
    strictSetInference: StrictSetInference | None = None
    strictDictionaryInference: StrictDictionaryInference | None = None
    analyzeUnannotatedFunctions: AnalyzeUnannotatedFunctions | None = None
    strictParameterNoneValue: StrictParameterNoneValue | None = None
    enableExperimentalFeatures: EnableExperimentalFeatures | None = None
    enableTypeIgnoreComments: EnableTypeIgnoreComments | None = None
    enableReachabilityAnalysis: EnableReachabilityAnalysis | None = None
    deprecateTypingAliases: DeprecateTypingAliases | None = None
    reportGeneralTypeIssues: ReportGeneralTypeIssues | None = None
    reportPropertyTypeMismatch: ReportPropertyTypeMismatch | None = None
    reportFunctionMemberAccess: ReportFunctionMemberAccess | None = None
    reportMissingImports: ReportMissingImports | None = None
    reportMissingModuleSource: ReportMissingModuleSource | None = None
    reportInvalidTypeForm: ReportInvalidTypeForm | None = None
    reportMissingTypeStubs: ReportMissingTypeStubs | None = None
    reportImportCycles: ReportImportCycles | None = None
    reportUnusedImport: ReportUnusedImport | None = None
    reportUnusedClass: ReportUnusedClass | None = None
    reportUnusedFunction: ReportUnusedFunction | None = None
    reportUnusedVariable: ReportUnusedVariable | None = None
    reportDuplicateImport: ReportDuplicateImport | None = None
    reportWildcardImportFromLibrary: ReportWildcardImportFromLibrary | None = None
    reportAbstractUsage: ReportAbstractUsage | None = None
    reportArgumentType: ReportArgumentType | None = None
    reportAssertTypeFailure: ReportAssertTypeFailure | None = None
    reportAssignmentType: ReportAssignmentType | None = None
    reportAttributeAccessIssue: ReportAttributeAccessIssue | None = None
    reportCallIssue: ReportCallIssue | None = None
    reportInconsistentOverload: ReportInconsistentOverload | None = None
    reportIndexIssue: ReportIndexIssue | None = None
    reportInvalidTypeArguments: ReportInvalidTypeArguments | None = None
    reportNoOverloadImplementation: ReportNoOverloadImplementation | None = None
    reportOperatorIssue: ReportOperatorIssue | None = None
    reportOptionalSubscript: ReportOptionalSubscript | None = None
    reportOptionalMemberAccess: ReportOptionalMemberAccess | None = None
    reportOptionalCall: ReportOptionalCall | None = None
    reportOptionalIterable: ReportOptionalIterable | None = None
    reportOptionalContextManager: ReportOptionalContextManager | None = None
    reportOptionalOperand: ReportOptionalOperand | None = None
    reportRedeclaration: ReportRedeclaration | None = None
    reportReturnType: ReportReturnType | None = None
    reportTypedDictNotRequiredAccess: ReportTypedDictNotRequiredAccess | None = None
    reportUntypedFunctionDecorator: ReportUntypedFunctionDecorator | None = None
    reportUntypedClassDecorator: ReportUntypedClassDecorator | None = None
    reportUntypedBaseClass: ReportUntypedBaseClass | None = None
    reportUntypedNamedTuple: ReportUntypedNamedTuple | None = None
    reportPrivateUsage: ReportPrivateUsage | None = None
    reportTypeCommentUsage: ReportTypeCommentUsage | None = None
    reportPrivateImportUsage: ReportPrivateImportUsage | None = None
    reportConstantRedefinition: ReportConstantRedefinition | None = None
    reportDeprecated: ReportDeprecated | None = None
    reportIncompatibleMethodOverride: ReportIncompatibleMethodOverride | None = None
    reportIncompatibleVariableOverride: ReportIncompatibleVariableOverride | None = (
        None
    )
    reportInconsistentConstructor: ReportInconsistentConstructor | None = None
    reportOverlappingOverload: ReportOverlappingOverload | None = None
    reportPossiblyUnboundVariable: ReportPossiblyUnboundVariable | None = None
    reportMissingSuperCall: ReportMissingSuperCall | None = None
    reportUninitializedInstanceVariable: ReportUninitializedInstanceVariable | None = None
    reportInvalidStringEscapeSequence: ReportInvalidStringEscapeSequence | None = (
        None
    )
    reportUnknownParameterType: ReportUnknownParameterType | None = None
    reportUnknownArgumentType: ReportUnknownArgumentType | None = None
    reportUnknownLambdaType: ReportUnknownLambdaType | None = None
    reportUnknownVariableType: ReportUnknownVariableType | None = None
    reportUnknownMemberType: ReportUnknownMemberType | None = None
    reportMissingParameterType: ReportMissingParameterType | None = None
    reportMissingTypeArgument: ReportMissingTypeArgument | None = None
    reportInvalidTypeVarUse: ReportInvalidTypeVarUse | None = None
    reportCallInDefaultInitializer: ReportCallInDefaultInitializer | None = None
    reportUnnecessaryIsInstance: ReportUnnecessaryIsInstance | None = None
    reportUnnecessaryCast: ReportUnnecessaryCast | None = None
    reportUnnecessaryComparison: ReportUnnecessaryComparison | None = None
    reportUnnecessaryContains: ReportUnnecessaryContains | None = None
    reportAssertAlwaysTrue: ReportAssertAlwaysTrue | None = None
    reportSelfClsParameterName: ReportSelfClsParameterName | None = None
    reportImplicitStringConcatenation: ReportImplicitStringConcatenation | None = (
        None
    )
    reportUnboundVariable: ReportUnboundVariable | None = None
    reportUnhashable: ReportUnhashable | None = None
    reportUndefinedVariable: ReportUndefinedVariable | None = None
    reportInvalidStubStatement: ReportInvalidStubStatement | None = None
    reportIncompleteStub: ReportIncompleteStub | None = None
    reportUnsupportedDunderAll: ReportUnsupportedDunderAll | None = None
    reportUnusedCallResult: ReportUnusedCallResult | None = None
    reportUnusedCoroutine: ReportUnusedCoroutine | None = None
    reportUnusedExcept: ReportUnusedExcept | None = None
    reportUnusedExpression: ReportUnusedExpression | None = None
    reportUnnecessaryTypeIgnoreComment: ReportUnnecessaryTypeIgnoreComment | None = (
        None
    )
    reportMatchNotExhaustive: ReportMatchNotExhaustive | None = None
    reportShadowedImports: ReportShadowedImports | None = None
    reportImplicitOverride: ReportImplicitOverride | None = None
    extraPaths: ExtraPaths | None = None
    pythonVersion: PythonVersionModel | None = None
    pythonPlatform: PythonPlatform | None = None
    venvPath: constr(pattern='^(.*)$') | None = Field(
        '',
        description="Path to a directory containing one or more subdirectories, each of which contains a virtual environment. When used in conjunction with a `venv` setting, pyright will search for imports in the virtual environment's site-packages directory rather than the paths specified by the default Python interpreter. If you are working on a project with other developers, it is best not to specify this setting in the config file, since this path will typically differ for each developer. Instead, it can be specified on the command line or in a per-user setting.",
        title='Path to directory containing a folder of virtual environments',
    )
    venv: constr(pattern='^(.*)$') | None = Field(
        '',
        description='Used in conjunction with the `venvPath`, specifies the virtual environment to use.',
        examples=['python37'],
        title='Name of virtual environment subdirectory within `venvPath`',
    )
    verboseOutput: bool | None = Field(
        False,
        description='Specifies whether output logs should be verbose. This is useful when diagnosing certain problems like import resolution issues.',
        title='Output verbose logging',
    )
    executionEnvironments: List[ExecutionEnvironment] | None = Field(
        None,
        description='Specifies a list of execution environments. Execution environments are searched from start to finish by comparing the path of a source file with the root path specified in the execution environment.',
        title='Analysis settings to use for specified subdirectories of code',
    )


class PipOptions(DataModel):
    """Settings that are specific to the `uv pip` command-line interface.

    These values will be ignored when running commands outside the `uv pip` namespace (e.g., `uv lock`, `uvx`).
    """

    model_config = ConfigDict(
        extra='forbid',
    )
    all_extras: bool | None = Field(
        None,
        alias='all-extras',
        description='Include all optional dependencies.\n\nOnly applies to `pyproject.toml`, `setup.py`, and `setup.cfg` sources.',
    )
    allow_empty_requirements: bool | None = Field(
        None,
        alias='allow-empty-requirements',
        description='Allow `uv pip sync` with empty requirements, which will clear the environment of all packages.',
    )
    allow_insecure_host: List[TrustedHost] | None = Field(
        None,
        alias='allow-insecure-host',
        description="Allow insecure connections to host.\n\nExpects to receive either a hostname (e.g., `localhost`), a host-port pair (e.g., `localhost:8080`), or a URL (e.g., `https://localhost`).\n\nWARNING: Hosts included in this list will not be verified against the system's certificate store. Only use `--allow-insecure-host` in a secure network with verified sources, as it bypasses SSL verification and could expose you to MITM attacks.",
    )
    annotation_style: AnnotationStyle | None = Field(
        None,
        alias='annotation-style',
        description='The style of the annotation comments included in the output file, used to indicate the source of each package.',
    )
    break_system_packages: bool | None = Field(
        None,
        alias='break-system-packages',
        description='Allow uv to modify an `EXTERNALLY-MANAGED` Python installation.\n\nWARNING: `--break-system-packages` is intended for use in continuous integration (CI) environments, when installing into Python installations that are managed by an external package manager, like `apt`. It should be used with caution, as such Python installations explicitly recommend against modifications by other package managers (like uv or pip).',
    )
    compile_bytecode: bool | None = Field(
        None,
        alias='compile-bytecode',
        description='Compile Python files to bytecode after installation.\n\nBy default, uv does not compile Python (`.py`) files to bytecode (`__pycache__/*.pyc`); instead, compilation is performed lazily the first time a module is imported. For use-cases in which start time is critical, such as CLI applications and Docker containers, this option can be enabled to trade longer installation times for faster start times.\n\nWhen enabled, uv will process the entire site-packages directory (including packages that are not being modified by the current operation) for consistency. Like pip, it will also ignore errors.',
    )
    config_settings: ConfigSettingsModel | None = Field(
        None,
        alias='config-settings',
        description='Settings to pass to the [PEP 517](https://peps.python.org/pep-0517/) build backend, specified as `KEY=VALUE` pairs.',
    )
    custom_compile_command: str | None = Field(
        None,
        alias='custom-compile-command',
        description='The header comment to include at the top of the output file generated by `uv pip compile`.\n\nUsed to reflect custom build scripts and commands that wrap `uv pip compile`.',
    )
    emit_build_options: bool | None = Field(
        None,
        alias='emit-build-options',
        description='Include `--no-binary` and `--only-binary` entries in the output file generated by `uv pip compile`.',
    )
    emit_find_links: bool | None = Field(
        None,
        alias='emit-find-links',
        description='Include `--find-links` entries in the output file generated by `uv pip compile`.',
    )
    emit_index_annotation: bool | None = Field(
        None,
        alias='emit-index-annotation',
        description='Include comment annotations indicating the index used to resolve each package (e.g., `# from https://pypi.org/simple`).',
    )
    emit_index_url: bool | None = Field(
        None,
        alias='emit-index-url',
        description='Include `--index-url` and `--extra-index-url` entries in the output file generated by `uv pip compile`.',
    )
    emit_marker_expression: bool | None = Field(
        None,
        alias='emit-marker-expression',
        description='Whether to emit a marker string indicating the conditions under which the set of pinned dependencies is valid.\n\nThe pinned dependencies may be valid even when the marker expression is false, but when the expression is true, the requirements are known to be correct.',
    )
    exclude_newer: ExcludeNewer | None = Field(
        None,
        alias='exclude-newer',
        description="Limit candidate packages to those that were uploaded prior to the given date.\n\nAccepts both [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) timestamps (e.g., `2006-12-02T02:07:43Z`) and local dates in the same format (e.g., `2006-12-02`) in your system's configured time zone.",
    )
    extra: List[ExtraName] | None = Field(
        None,
        description='Include optional dependencies from the extra group name; may be provided more than once.\n\nOnly applies to `pyproject.toml`, `setup.py`, and `setup.cfg` sources.',
    )
    extra_index_url: List[IndexUrl] | None = Field(
        None,
        alias='extra-index-url',
        description="Extra URLs of package indexes to use, in addition to `--index-url`.\n\nAccepts either a repository compliant with [PEP 503](https://peps.python.org/pep-0503/) (the simple repository API), or a local directory laid out in the same format.\n\nAll indexes provided via this flag take priority over the index specified by [`index_url`](#index-url). When multiple indexes are provided, earlier values take priority.\n\nTo control uv's resolution strategy when multiple indexes are present, see [`index_strategy`](#index-strategy).",
    )
    find_links: List[FlatIndexLocation] | None = Field(
        None,
        alias='find-links',
        description='Locations to search for candidate distributions, in addition to those found in the registry indexes.\n\nIf a path, the target must be a directory that contains packages as wheel files (`.whl`) or source distributions (`.tar.gz` or `.zip`) at the top level.\n\nIf a URL, the page must contain a flat list of links to package files adhering to the formats described above.',
    )
    generate_hashes: bool | None = Field(
        None,
        alias='generate-hashes',
        description='Include distribution hashes in the output file.',
    )
    index_strategy: IndexStrategy | None = Field(
        None,
        alias='index-strategy',
        description='The strategy to use when resolving against multiple index URLs.\n\nBy default, uv will stop at the first index on which a given package is available, and limit resolutions to those present on that first index (`first-match`). This prevents "dependency confusion" attacks, whereby an attack can upload a malicious package under the same name to a secondary.',
    )
    index_url: IndexUrl | None = Field(
        None,
        alias='index-url',
        description='The URL of the Python package index (by default: <https://pypi.org/simple>).\n\nAccepts either a repository compliant with [PEP 503](https://peps.python.org/pep-0503/) (the simple repository API), or a local directory laid out in the same format.\n\nThe index provided by this setting is given lower priority than any indexes specified via [`extra_index_url`](#extra-index-url).',
    )
    keyring_provider: KeyringProviderType | None = Field(
        None,
        alias='keyring-provider',
        description='Attempt to use `keyring` for authentication for index URLs.\n\nAt present, only `--keyring-provider subprocess` is supported, which configures uv to use the `keyring` CLI to handle authentication.',
    )
    link_mode: LinkMode | None = Field(
        None,
        alias='link-mode',
        description='The method to use when installing packages from the global cache.\n\nDefaults to `clone` (also known as Copy-on-Write) on macOS, and `hardlink` on Linux and Windows.',
    )
    no_annotate: bool | None = Field(
        None,
        alias='no-annotate',
        description='Exclude comment annotations indicating the source of each package from the output file generated by `uv pip compile`.',
    )
    no_binary: List[PackageNameSpecifier] | None = Field(
        None,
        alias='no-binary',
        description="Don't install pre-built wheels.\n\nThe given packages will be built and installed from source. The resolver will still use pre-built wheels to extract package metadata, if available.\n\nMultiple packages may be provided. Disable binaries for all packages with `:all:`. Clear previously specified packages with `:none:`.",
    )
    no_build: bool | None = Field(
        None,
        alias='no-build',
        description="Don't build source distributions.\n\nWhen enabled, resolving will not run arbitrary Python code. The cached wheels of already-built source distributions will be reused, but operations that require building distributions will exit with an error.\n\nAlias for `--only-binary :all:`.",
    )
    no_build_isolation: bool | None = Field(
        None,
        alias='no-build-isolation',
        description='Disable isolation when building source distributions.\n\nAssumes that build dependencies specified by [PEP 518](https://peps.python.org/pep-0518/) are already installed.',
    )
    no_build_isolation_package: List[PackageNameModel] | None = Field(
        None,
        alias='no-build-isolation-package',
        description="Disable isolation when building source distributions for a specific package.\n\nAssumes that the packages' build dependencies specified by [PEP 518](https://peps.python.org/pep-0518/) are already installed.",
    )
    no_deps: bool | None = Field(
        None,
        alias='no-deps',
        description='Ignore package dependencies, instead only add those packages explicitly listed on the command line to the resulting the requirements file.',
    )
    no_emit_package: List[PackageNameModel] | None = Field(
        None,
        alias='no-emit-package',
        description="Specify a package to omit from the output resolution. Its dependencies will still be included in the resolution. Equivalent to pip-compile's `--unsafe-package` option.",
    )
    no_header: bool | None = Field(
        None,
        alias='no-header',
        description='Exclude the comment header at the top of output file generated by `uv pip compile`.',
    )
    no_index: bool | None = Field(
        None,
        alias='no-index',
        description='Ignore all registry indexes (e.g., PyPI), instead relying on direct URL dependencies and those provided via `--find-links`.',
    )
    no_sources: bool | None = Field(
        None,
        alias='no-sources',
        description='Ignore the `tool.uv.sources` table when resolving dependencies. Used to lock against the standards-compliant, publishable package metadata, as opposed to using any local or Git sources.',
    )
    no_strip_extras: bool | None = Field(
        None,
        alias='no-strip-extras',
        description='Include extras in the output file.\n\nBy default, uv strips extras, as any packages pulled in by the extras are already included as dependencies in the output file directly. Further, output files generated with `--no-strip-extras` cannot be used as constraints files in `install` and `sync` invocations.',
    )
    no_strip_markers: bool | None = Field(
        None,
        alias='no-strip-markers',
        description='Include environment markers in the output file generated by `uv pip compile`.\n\nBy default, uv strips environment markers, as the resolution generated by `compile` is only guaranteed to be correct for the target environment.',
    )
    only_binary: List[PackageNameSpecifier] | None = Field(
        None,
        alias='only-binary',
        description="Only use pre-built wheels; don't build source distributions.\n\nWhen enabled, resolving will not run code from the given packages. The cached wheels of already-built source distributions will be reused, but operations that require building distributions will exit with an error.\n\nMultiple packages may be provided. Disable binaries for all packages with `:all:`. Clear previously specified packages with `:none:`.",
    )
    output_file: str | None = Field(
        None,
        alias='output-file',
        description='Write the requirements generated by `uv pip compile` to the given `requirements.txt` file.\n\nIf the file already exists, the existing versions will be preferred when resolving dependencies, unless `--upgrade` is also specified.',
    )
    prefix: str | None = Field(
        None,
        description='Install packages into `lib`, `bin`, and other top-level folders under the specified directory, as if a virtual environment were present at that location.\n\nIn general, prefer the use of `--python` to install into an alternate environment, as scripts and other artifacts installed via `--prefix` will reference the installing interpreter, rather than any interpreter added to the `--prefix` directory, rendering them non-portable.',
    )
    prerelease: PrereleaseMode | None = Field(
        None,
        description='The strategy to use when considering pre-release versions.\n\nBy default, uv will accept pre-releases for packages that _only_ publish pre-releases, along with first-party requirements that contain an explicit pre-release marker in the declared specifiers (`if-necessary-or-explicit`).',
    )
    python: str | None = Field(
        None,
        description='The Python interpreter into which packages should be installed.\n\nBy default, uv installs into the virtual environment in the current working directory or any parent directory. The `--python` option allows you to specify a different interpreter, which is intended for use in continuous integration (CI) environments or other automated workflows.\n\nSupported formats: - `3.10` looks for an installed Python 3.10 using `py --list-paths` on Windows, or `python3.10` on Linux and macOS. - `python3.10` or `python.exe` looks for a binary with the given name in `PATH`. - `/home/ferris/.local/bin/python3.10` uses the exact Python at the given path.',
    )
    python_platform: TargetTriple | None = Field(
        None,
        alias='python-platform',
        description='The platform for which requirements should be resolved.\n\nRepresented as a "target triple", a string that describes the target platform in terms of its CPU, vendor, and operating system name, like `x86_64-unknown-linux-gnu` or `aaarch64-apple-darwin`.',
    )
    python_version: PythonVersionModel1 | None = Field(
        None,
        alias='python-version',
        description='The minimum Python version that should be supported by the resolved requirements (e.g., `3.8` or `3.8.17`).\n\nIf a patch version is omitted, the minimum patch version is assumed. For example, `3.8` is mapped to `3.8.0`.',
    )
    reinstall: bool | None = Field(
        None,
        description="Reinstall all packages, regardless of whether they're already installed. Implies `refresh`.",
    )
    reinstall_package: List[PackageNameModel] | None = Field(
        None,
        alias='reinstall-package',
        description="Reinstall a specific package, regardless of whether it's already installed. Implies `refresh-package`.",
    )
    require_hashes: bool | None = Field(
        None,
        alias='require-hashes',
        description='Require a matching hash for each requirement.\n\nHash-checking mode is all or nothing. If enabled, _all_ requirements must be provided with a corresponding hash or set of hashes. Additionally, if enabled, _all_ requirements must either be pinned to exact versions (e.g., `==1.0.0`), or be specified via direct URL.\n\nHash-checking mode introduces a number of additional constraints:\n\n- Git dependencies are not supported. - Editable installs are not supported. - Local dependencies are not supported, unless they point to a specific wheel (`.whl`) or source archive (`.zip`, `.tar.gz`), as opposed to a directory.',
    )
    resolution: ResolutionMode | None = Field(
        None,
        description='The strategy to use when selecting between the different compatible versions for a given package requirement.\n\nBy default, uv will use the latest compatible version of each package (`highest`).',
    )
    strict: bool | None = Field(
        None,
        description='Validate the Python environment, to detect packages with missing dependencies and other issues.',
    )
    system: bool | None = Field(
        None,
        description='Install packages into the system Python environment.\n\nBy default, uv installs into the virtual environment in the current working directory or any parent directory. The `--system` option instructs uv to instead use the first Python found in the system `PATH`.\n\nWARNING: `--system` is intended for use in continuous integration (CI) environments and should be used with caution, as it can modify the system Python installation.',
    )
    target: str | None = Field(
        None,
        description='Install packages into the specified directory, rather than into the virtual or system Python environment. The packages will be installed at the top-level of the directory.',
    )
    universal: bool | None = Field(
        None,
        description='Perform a universal resolution, attempting to generate a single `requirements.txt` output file that is compatible with all operating systems, architectures, and Python implementations.\n\nIn universal mode, the current Python version (or user-provided `--python-version`) will be treated as a lower bound. For example, `--universal --python-version 3.7` would produce a universal resolution for Python 3.7 and later.',
    )
    upgrade: bool | None = Field(
        None,
        description='Allow package upgrades, ignoring pinned versions in any existing output file.',
    )
    upgrade_package: List[Requirement] | None = Field(
        None,
        alias='upgrade-package',
        description='Allow upgrades for a specific package, ignoring pinned versions in any existing output file.\n\nAccepts both standalone package names (`ruff`) and version specifiers (`ruff<0.5.0`).',
    )
    verify_hashes: bool | None = Field(
        None,
        alias='verify-hashes',
        description='Validate any hashes provided in the requirements file.\n\nUnlike `--require-hashes`, `--verify-hashes` does not require that all requirements have hashes; instead, it will limit itself to verifying the hashes of those requirements that do include them.',
    )


class Ruff(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    allowed_confusables: List[constr(min_length=1, max_length=1)] | None = Field(
        None,
        alias='allowed-confusables',
        description='A list of allowed "confusable" Unicode characters to ignore when enforcing `RUF001`, `RUF002`, and `RUF003`.',
    )
    analyze: AnalyzeOptions | None = Field(
        None, description='Options to configure import map generation.',
    )
    builtins: List[str] | None = Field(
        None,
        description='A list of builtins to treat as defined references, in addition to the system builtins.',
    )
    cache_dir: str | None = Field(
        None,
        alias='cache-dir',
        description='A path to the cache directory.\n\nBy default, Ruff stores cache results in a `.ruff_cache` directory in the current project root.\n\nHowever, Ruff will also respect the `RUFF_CACHE_DIR` environment variable, which takes precedence over that default.\n\nThis setting will override even the `RUFF_CACHE_DIR` environment variable, if set.',
    )
    dummy_variable_rgx: str | None = Field(
        None,
        alias='dummy-variable-rgx',
        description='A regular expression used to identify "dummy" variables, or those which should be ignored when enforcing (e.g.) unused-variable rules. The default expression matches `_`, `__`, and `_var`, but not `_var_`.',
    )
    exclude: List[str] | None = Field(
        None,
        description="A list of file patterns to exclude from formatting and linting.\n\nExclusions are based on globs, and can be either:\n\n- Single-path patterns, like `.mypy_cache` (to exclude any directory named `.mypy_cache` in the tree), `foo.py` (to exclude any file named `foo.py`), or `foo_*.py` (to exclude any file matching `foo_*.py` ). - Relative patterns, like `directory/foo.py` (to exclude that specific file) or `directory/*.py` (to exclude any Python files in `directory`). Note that these paths are relative to the project root (e.g., the directory containing your `pyproject.toml`).\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).\n\nNote that you'll typically want to use [`extend-exclude`](#extend-exclude) to modify the excluded paths.",
    )
    explicit_preview_rules: bool | None = Field(
        None,
        alias='explicit-preview-rules',
        description='Whether to require exact codes to select preview rules. When enabled, preview rules will not be selected by prefixes â the full code of each preview rule will be required to enable the rule.',
    )
    extend: str | None = Field(
        None,
        description='A path to a local `pyproject.toml` file to merge into this configuration. User home directory and environment variables will be expanded.\n\nTo resolve the current `pyproject.toml` file, Ruff will first resolve this base configuration file, then merge in any properties defined in the current configuration file.',
    )
    extend_exclude: List[str] | None = Field(
        None,
        alias='extend-exclude',
        description='A list of file patterns to omit from formatting and linting, in addition to those specified by [`exclude`](#exclude).\n\nExclusions are based on globs, and can be either:\n\n- Single-path patterns, like `.mypy_cache` (to exclude any directory named `.mypy_cache` in the tree), `foo.py` (to exclude any file named `foo.py`), or `foo_*.py` (to exclude any file matching `foo_*.py` ). - Relative patterns, like `directory/foo.py` (to exclude that specific file) or `directory/*.py` (to exclude any Python files in `directory`). Note that these paths are relative to the project root (e.g., the directory containing your `pyproject.toml`).\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    extend_fixable: List[RuleSelector] | None = Field(
        None,
        alias='extend-fixable',
        description='A list of rule codes or prefixes to consider fixable, in addition to those specified by [`fixable`](#lint_fixable).',
    )
    extend_ignore: List[RuleSelector] | None = Field(
        None,
        alias='extend-ignore',
        description='A list of rule codes or prefixes to ignore, in addition to those specified by `ignore`.',
    )
    extend_include: List[str] | None = Field(
        None,
        alias='extend-include',
        description='A list of file patterns to include when linting, in addition to those specified by [`include`](#include).\n\nInclusion are based on globs, and should be single-path patterns, like `*.pyw`, to include any file with the `.pyw` extension.\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    extend_per_file_ignores: Dict[str, Any] | None = Field(
        None,
        alias='extend-per-file-ignores',
        description='A list of mappings from file pattern to rule codes or prefixes to exclude, in addition to any rules excluded by [`per-file-ignores`](#lint_per-file-ignores).',
    )
    extend_safe_fixes: List[RuleSelector] | None = Field(
        None,
        alias='extend-safe-fixes',
        description='A list of rule codes or prefixes for which unsafe fixes should be considered safe.',
    )
    extend_select: List[RuleSelector] | None = Field(
        None,
        alias='extend-select',
        description='A list of rule codes or prefixes to enable, in addition to those specified by [`select`](#lint_select).',
    )
    extend_unfixable: List[RuleSelector] | None = Field(
        None,
        alias='extend-unfixable',
        description='A list of rule codes or prefixes to consider non-auto-fixable, in addition to those specified by [`unfixable`](#lint_unfixable).',
    )
    extend_unsafe_fixes: List[RuleSelector] | None = Field(
        None,
        alias='extend-unsafe-fixes',
        description='A list of rule codes or prefixes for which safe fixes should be considered unsafe.',
    )
    external: List[str] | None = Field(
        None,
        description='A list of rule codes or prefixes that are unsupported by Ruff, but should be preserved when (e.g.) validating `# noqa` directives. Useful for retaining `# noqa` directives that cover plugins not yet implemented by Ruff.',
    )
    fix: bool | None = Field(
        None,
        description='Enable fix behavior by-default when running `ruff` (overridden by the `--fix` and `--no-fix` command-line flags). Only includes automatic fixes unless `--unsafe-fixes` is provided.',
    )
    fix_only: bool | None = Field(
        None,
        alias='fix-only',
        description='Like [`fix`](#fix), but disables reporting on leftover violation. Implies [`fix`](#fix).',
    )
    fixable: List[RuleSelector] | None = Field(
        None,
        description='A list of rule codes or prefixes to consider fixable. By default, all rules are considered fixable.',
    )
    flake8_annotations: Flake8AnnotationsOptions | None = Field(
        None,
        alias='flake8-annotations',
        description='Options for the `flake8-annotations` plugin.',
    )
    flake8_bandit: Flake8BanditOptions | None = Field(
        None,
        alias='flake8-bandit',
        description='Options for the `flake8-bandit` plugin.',
    )
    flake8_boolean_trap: Flake8BooleanTrapOptions | None = Field(
        None,
        alias='flake8-boolean-trap',
        description='Options for the `flake8-boolean-trap` plugin.',
    )
    flake8_bugbear: Flake8BugbearOptions | None = Field(
        None,
        alias='flake8-bugbear',
        description='Options for the `flake8-bugbear` plugin.',
    )
    flake8_builtins: Flake8BuiltinsOptions | None = Field(
        None,
        alias='flake8-builtins',
        description='Options for the `flake8-builtins` plugin.',
    )
    flake8_comprehensions: Flake8ComprehensionsOptions | None = Field(
        None,
        alias='flake8-comprehensions',
        description='Options for the `flake8-comprehensions` plugin.',
    )
    flake8_copyright: Flake8CopyrightOptions | None = Field(
        None,
        alias='flake8-copyright',
        description='Options for the `flake8-copyright` plugin.',
    )
    flake8_errmsg: Flake8ErrMsgOptions | None = Field(
        None,
        alias='flake8-errmsg',
        description='Options for the `flake8-errmsg` plugin.',
    )
    flake8_gettext: Flake8GetTextOptions | None = Field(
        None,
        alias='flake8-gettext',
        description='Options for the `flake8-gettext` plugin.',
    )
    flake8_implicit_str_concat: Flake8ImplicitStrConcatOptions | None = Field(
        None,
        alias='flake8-implicit-str-concat',
        description='Options for the `flake8-implicit-str-concat` plugin.',
    )
    flake8_import_conventions: Flake8ImportConventionsOptions | None = Field(
        None,
        alias='flake8-import-conventions',
        description='Options for the `flake8-import-conventions` plugin.',
    )
    flake8_pytest_style: Flake8PytestStyleOptions | None = Field(
        None,
        alias='flake8-pytest-style',
        description='Options for the `flake8-pytest-style` plugin.',
    )
    flake8_quotes: Flake8QuotesOptions | None = Field(
        None,
        alias='flake8-quotes',
        description='Options for the `flake8-quotes` plugin.',
    )
    flake8_self: Flake8SelfOptions | None = Field(
        None, alias='flake8-self', description='Options for the `flake8_self` plugin.',
    )
    flake8_tidy_imports: Flake8TidyImportsOptions | None = Field(
        None,
        alias='flake8-tidy-imports',
        description='Options for the `flake8-tidy-imports` plugin.',
    )
    flake8_type_checking: Flake8TypeCheckingOptions | None = Field(
        None,
        alias='flake8-type-checking',
        description='Options for the `flake8-type-checking` plugin.',
    )
    flake8_unused_arguments: Flake8UnusedArgumentsOptions | None = Field(
        None,
        alias='flake8-unused-arguments',
        description='Options for the `flake8-unused-arguments` plugin.',
    )
    force_exclude: bool | None = Field(
        None,
        alias='force-exclude',
        description="Whether to enforce [`exclude`](#exclude) and [`extend-exclude`](#extend-exclude) patterns, even for paths that are passed to Ruff explicitly. Typically, Ruff will lint any paths passed in directly, even if they would typically be excluded. Setting `force-exclude = true` will cause Ruff to respect these exclusions unequivocally.\n\nThis is useful for [`pre-commit`](https://pre-commit.com/), which explicitly passes all changed files to the [`ruff-pre-commit`](https://github.com/astral-sh/ruff-pre-commit) plugin, regardless of whether they're marked as excluded by Ruff's own settings.",
    )
    format: FormatOptions | None = Field(
        None, description='Options to configure code formatting.',
    )
    ignore: List[RuleSelector] | None = Field(
        None,
        description='A list of rule codes or prefixes to ignore. Prefixes can specify exact rules (like `F841`), entire categories (like `F`), or anything in between.\n\nWhen breaking ties between enabled and disabled rules (via `select` and `ignore`, respectively), more specific prefixes override less specific prefixes.',
    )
    ignore_init_module_imports: bool | None = Field(
        None,
        alias='ignore-init-module-imports',
        description="Avoid automatically removing unused imports in `__init__.py` files. Such imports will still be flagged, but with a dedicated message suggesting that the import is either added to the module's `__all__` symbol, or re-exported with a redundant alias (e.g., `import os as os`).\n\nThis option is enabled by default, but you can opt-in to removal of imports via an unsafe fix.",
    )
    include: List[str] | None = Field(
        None,
        description='A list of file patterns to include when linting.\n\nInclusion are based on globs, and should be single-path patterns, like `*.pyw`, to include any file with the `.pyw` extension. `pyproject.toml` is included here not for configuration but because we lint whether e.g. the `[project]` matches the schema.\n\nNotebook files (`.ipynb` extension) are included by default on Ruff 0.6.0+.\n\nFor more information on the glob syntax, refer to the [`globset` documentation](https://docs.rs/globset/latest/globset/#syntax).',
    )
    indent_width: IndentWidth | None = Field(
        None,
        alias='indent-width',
        description='The number of spaces per indentation level (tab).\n\nUsed by the formatter and when enforcing long-line violations (like `E501`) to determine the visual width of a tab.\n\nThis option changes the number of spaces the formatter inserts when using soft-tabs (`indent-style = space`).\n\nPEP 8 recommends using 4 spaces per [indentation level](https://peps.python.org/pep-0008/#indentation).',
    )
    isort: IsortOptions | None = Field(
        None, description='Options for the `isort` plugin.',
    )
    line_length: LineLength | None = Field(
        None,
        alias='line-length',
        description="The line length to use when enforcing long-lines violations (like `E501`) and at which `isort` and the formatter prefers to wrap lines.\n\nThe length is determined by the number of characters per line, except for lines containing East Asian characters or emojis. For these lines, the [unicode width](https://unicode.org/reports/tr11/) of each character is added up to determine the length.\n\nThe value must be greater than `0` and less than or equal to `320`.\n\nNote: While the formatter will attempt to format lines such that they remain within the `line-length`, it isn't a hard upper bound, and formatted lines may exceed the `line-length`.\n\nSee [`pycodestyle.max-line-length`](#lint_pycodestyle_max-line-length) to configure different lengths for `E501` and the formatter.",
    )
    lint: LintOptions | None = None
    logger_objects: List[str] | None = Field(
        None,
        alias='logger-objects',
        description='A list of objects that should be treated equivalently to a `logging.Logger` object.\n\nThis is useful for ensuring proper diagnostics (e.g., to identify `logging` deprecations and other best-practices) for projects that re-export a `logging.Logger` object from a common module.\n\nFor example, if you have a module `logging_setup.py` with the following contents: ```python import logging\n\nlogger = logging.getLogger(__name__) ```\n\nAdding `"logging_setup.logger"` to `logger-objects` will ensure that `logging_setup.logger` is treated as a `logging.Logger` object when imported from other modules (e.g., `from logging_setup import logger`).',
    )
    mccabe: McCabeOptions | None = Field(
        None, description='Options for the `mccabe` plugin.',
    )
    namespace_packages: List[str] | None = Field(
        None,
        alias='namespace-packages',
        description='Mark the specified directories as namespace packages. For the purpose of module resolution, Ruff will treat those directories and all their subdirectories as if they contained an `__init__.py` file.',
    )
    output_format: OutputFormat | None = Field(
        None,
        alias='output-format',
        description='The style in which violation messages should be formatted: `"full"` (default) (shows source), `"concise"`, `"grouped"` (group messages by file), `"json"` (machine-readable), `"junit"` (machine-readable XML), `"github"` (GitHub Actions annotations), `"gitlab"` (GitLab CI code quality report), `"pylint"` (Pylint text format) or `"azure"` (Azure Pipeline logging commands).',
    )
    pep8_naming: Pep8NamingOptions | None = Field(
        None, alias='pep8-naming', description='Options for the `pep8-naming` plugin.',
    )
    per_file_ignores: Dict[str, Any] | None = Field(
        None,
        alias='per-file-ignores',
        description="A list of mappings from file pattern to rule codes or prefixes to exclude, when considering any matching files. An initial '!' negates the file pattern.",
    )
    preview: bool | None = Field(
        None,
        description='Whether to enable preview mode. When preview mode is enabled, Ruff will use unstable rules, fixes, and formatting.',
    )
    pycodestyle: PycodestyleOptions | None = Field(
        None, description='Options for the `pycodestyle` plugin.',
    )
    pydocstyle: PydocstyleOptions | None = Field(
        None, description='Options for the `pydocstyle` plugin.',
    )
    pyflakes: PyflakesOptions | None = Field(
        None, description='Options for the `pyflakes` plugin.',
    )
    pylint: PylintOptions | None = Field(
        None, description='Options for the `pylint` plugin.',
    )
    pyupgrade: PyUpgradeOptions | None = Field(
        None, description='Options for the `pyupgrade` plugin.',
    )
    required_version: RequiredVersion | None = Field(
        None,
        alias='required-version',
        description='Enforce a requirement on the version of Ruff, to enforce at runtime. If the version of Ruff does not meet the requirement, Ruff will exit with an error.\n\nUseful for unifying results across many environments, e.g., with a `pyproject.toml` file.\n\nAccepts a [PEP 440](https://peps.python.org/pep-0440/) specifier, like `==0.3.1` or `>=0.3.1`.',
    )
    respect_gitignore: bool | None = Field(
        None,
        alias='respect-gitignore',
        description='Whether to automatically exclude files that are ignored by `.ignore`, `.gitignore`, `.git/info/exclude`, and global `gitignore` files. Enabled by default.',
    )
    select: List[RuleSelector] | None = Field(
        None,
        description='A list of rule codes or prefixes to enable. Prefixes can specify exact rules (like `F841`), entire categories (like `F`), or anything in between.\n\nWhen breaking ties between enabled and disabled rules (via `select` and `ignore`, respectively), more specific prefixes override less specific prefixes.',
    )
    show_fixes: bool | None = Field(
        None,
        alias='show-fixes',
        description='Whether to show an enumeration of all fixed lint violations (overridden by the `--show-fixes` command-line flag).',
    )
    src: List[str] | None = Field(
        None,
        description='The directories to consider when resolving first- vs. third-party imports.\n\nWhen omitted, the `src` directory will typically default to including both:\n\n1. The directory containing the nearest `pyproject.toml`, `ruff.toml`, or `.ruff.toml` file (the "project root"). 2. The `"src"` subdirectory of the project root.\n\nThese defaults ensure that Ruff supports both flat layouts and `src` layouts out-of-the-box. (If a configuration file is explicitly provided (e.g., via the `--config` command-line flag), the current working directory will be considered the project root.)\n\nAs an example, consider an alternative project structure, like:\n\n```text my_project âââ pyproject.toml âââ lib âââ my_package âââ __init__.py âââ foo.py âââ bar.py ```\n\nIn this case, the `./lib` directory should be included in the `src` option (e.g., `src = ["lib"]`), such that when resolving imports, `my_package.foo` is considered first-party.\n\nThis field supports globs. For example, if you have a series of Python packages in a `python_modules` directory, `src = ["python_modules/*"]` would expand to incorporate all packages in that directory. User home directory and environment variables will also be expanded.',
    )
    target_version: PythonVersion | None = Field(
        None,
        alias='target-version',
        description='The minimum Python version to target, e.g., when considering automatic code upgrades, like rewriting type annotations. Ruff will not propose changes using features that are not available in the given version.\n\nFor example, to represent supporting Python >=3.10 or ==3.10 specify `target-version = "py310"`.\n\nIf you\'re already using a `pyproject.toml` file, we recommend `project.requires-python` instead, as it\'s based on Python packaging standards, and will be respected by other tools. For example, Ruff treats the following as identical to `target-version = "py38"`:\n\n```toml [project] requires-python = ">=3.8" ```\n\nIf both are specified, `target-version` takes precedence over `requires-python`.\n\nNote that a stub file can [sometimes make use of a typing feature](https://typing.readthedocs.io/en/latest/spec/distributing.html#syntax) before it is available at runtime, as long as the stub does not make use of new *syntax*. For example, a type checker will understand `int | str` in a stub as being a `Union` type annotation, even if the type checker is run using Python 3.9, despite the fact that the `|` operator can only be used to create union types at runtime on Python 3.10+. As such, Ruff will often recommend newer features in a stub file than it would for an equivalent runtime file with the same target version.',
    )
    task_tags: List[str] | None = Field(
        None,
        alias='task-tags',
        description='A list of task tags to recognize (e.g., "TODO", "FIXME", "XXX").\n\nComments starting with these tags will be ignored by commented-out code detection (`ERA`), and skipped by line-length rules (`E501`) if [`ignore-overlong-task-comments`](#lint_pycodestyle_ignore-overlong-task-comments) is set to `true`.',
    )
    typing_modules: List[str] | None = Field(
        None,
        alias='typing-modules',
        description='A list of modules whose exports should be treated equivalently to members of the `typing` module.\n\nThis is useful for ensuring proper type annotation inference for projects that re-export `typing` and `typing_extensions` members from a compatibility module. If omitted, any members imported from modules apart from `typing` and `typing_extensions` will be treated as ordinary Python objects.',
    )
    unfixable: List[RuleSelector] | None = Field(
        None, description='A list of rule codes or prefixes to consider non-fixable.',
    )
    unsafe_fixes: bool | None = Field(
        None,
        alias='unsafe-fixes',
        description='Enable application of unsafe fixes. If excluded, a hint will be displayed when unsafe fixes are available. If set to false, the hint will be hidden.',
    )


class Group(DataModel):
    """This represents a single dependency group."""

    model_config = ConfigDict(
        extra='forbid',
    )
    optional: bool | None = Field(
        None, description='Whether the dependency group is optional or not',
    )
    dependencies: Dict[constr(pattern=r'^[a-zA-Z-_.0-9]+$'), PoetryDependencyAny] = (
        Field(..., description='The dependencies of this dependency group')
    )


class PartialPoetry(DataModel):
    model_config = ConfigDict(
        extra='allow',
    )
    package_mode: bool | None = Field(
        True,
        alias='package-mode',
        description='Whether Poetry operates in package mode or not.',
    )
    name: PoetryName | None = None
    version: PoetryVersion | None = None
    description: PoetryDescription | None = None
    keywords: List[str] | None = None
    homepage: AnyUrl | None = Field(
        None, description='Homepage URL for the project.',
    )
    repository: AnyUrl | None = Field(
        None, description='Repository URL for the project.',
    )
    documentation: AnyUrl | None = Field(
        None, description='Documentation URL for the project.',
    )
    license: str | None = Field(None, description='License name.')
    authors: PoetryAuthors | None = None
    maintainers: PoetryMaintainers | None = None
    readme: str | List[str] | None = None
    classifiers: List | None = Field(
        None, description='A list of trove classifiers.',
    )
    packages: List[Package] | None = Field(
        None, description='A list of packages to include in the final distribution.',
    )
    include: List[PoetryIncludePath | Include] | None = Field(
        None, description='A list of files and folders to include.',
    )
    exclude: List | None = Field(
        None, description='A list of files and folders to exclude.',
    )
    dependencies: Dependencies | None = Field(
        None,
        description='This is a hash of package name (keys) and version constraints (values) that are required to run this package.',
    )
    dev_dependencies: Dict[constr(pattern='^[a-zA-Z-_.0-9]+$'), PoetryDependencyAny] | None = Field(
        None,
        alias='dev-dependencies',
        description='This is a hash of package name (keys) and version constraints (values) that this package requires for developing it (testing tools and such).',
    )
    extras: Dict[constr(pattern='^[a-zA-Z-_.0-9]+$'), List[str]] | None = None
    group: Dict[constr(pattern='^[a-zA-Z-_.0-9]+$'), Group] | None = Field(
        None, description='This represents groups of dependencies',
    )
    build: PoetryBuildSection | None = None
    scripts: Dict[constr(pattern='^[a-zA-Z-_.0-9]+$'), PoetryScriptLegacy | PoetryScriptTable] | None = Field(None, description='A hash of scripts to be installed.')
    plugins: Dict[constr(pattern='^dotenv$'), Plugins1] | Dict[constr(pattern='^[a-zA-Z-_.0-9]+$'), Dict[constr(pattern='^[a-zA-Z-_.0-9]+$'), str]] | None = Field(None, description='A hash of hashes representing plugins')
    urls: Dict[constr(pattern='^.+$'), str] | None = None


class Uv(DataModel):
    """Metadata and configuration for uv."""

    allow_insecure_host: List[TrustedHost] | None = Field(
        None,
        alias='allow-insecure-host',
        description="Allow insecure connections to host.\n\nExpects to receive either a hostname (e.g., `localhost`), a host-port pair (e.g., `localhost:8080`), or a URL (e.g., `https://localhost`).\n\nWARNING: Hosts included in this list will not be verified against the system's certificate store. Only use `--allow-insecure-host` in a secure network with verified sources, as it bypasses SSL verification and could expose you to MITM attacks.",
    )
    cache_dir: str | None = Field(
        None,
        alias='cache-dir',
        description='Path to the cache directory.\n\nDefaults to `$HOME/Library/Caches/uv` on macOS, `$XDG_CACHE_HOME/uv` or `$HOME/.cache/uv` on Linux, and `%LOCALAPPDATA%\\uv\\cache` on Windows.',
    )
    compile_bytecode: bool | None = Field(
        None,
        alias='compile-bytecode',
        description='Compile Python files to bytecode after installation.\n\nBy default, uv does not compile Python (`.py`) files to bytecode (`__pycache__/*.pyc`); instead, compilation is performed lazily the first time a module is imported. For use-cases in which start time is critical, such as CLI applications and Docker containers, this option can be enabled to trade longer installation times for faster start times.\n\nWhen enabled, uv will process the entire site-packages directory (including packages that are not being modified by the current operation) for consistency. Like pip, it will also ignore errors.',
    )
    concurrent_builds: conint(ge=1) | None = Field(
        None,
        alias='concurrent-builds',
        description='The maximum number of source distributions that uv will build concurrently at any given time.\n\nDefaults to the number of available CPU cores.',
    )
    concurrent_downloads: conint(ge=1) | None = Field(
        None,
        alias='concurrent-downloads',
        description='The maximum number of in-flight concurrent downloads that uv will perform at any given time.',
    )
    concurrent_installs: conint(ge=1) | None = Field(
        None,
        alias='concurrent-installs',
        description='The number of threads used when installing and unzipping packages.\n\nDefaults to the number of available CPU cores.',
    )
    config_settings: ConfigSettingsModel | None = Field(
        None,
        alias='config-settings',
        description='Settings to pass to the [PEP 517](https://peps.python.org/pep-0517/) build backend, specified as `KEY=VALUE` pairs.',
    )
    constraint_dependencies: List[str] | None = Field(
        None,
        alias='constraint-dependencies',
        description='PEP 508-style requirements, e.g., `ruff==0.5.0`, or `ruff @ https://...`.',
    )
    dev_dependencies: List[str] | None = Field(
        None,
        alias='dev-dependencies',
        description='PEP 508-style requirements, e.g., `ruff==0.5.0`, or `ruff @ https://...`.',
    )
    environments: List[str] | None = Field(
        None,
        description="A list of environment markers, e.g., `python_version >= '3.6'`.",
    )
    exclude_newer: ExcludeNewer | None = Field(
        None,
        alias='exclude-newer',
        description="Limit candidate packages to those that were uploaded prior to the given date.\n\nAccepts both [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339.html) timestamps (e.g., `2006-12-02T02:07:43Z`) and local dates in the same format (e.g., `2006-12-02`) in your system's configured time zone.",
    )
    extra_index_url: List[IndexUrl] | None = Field(
        None,
        alias='extra-index-url',
        description="Extra URLs of package indexes to use, in addition to `--index-url`.\n\nAccepts either a repository compliant with [PEP 503](https://peps.python.org/pep-0503/) (the simple repository API), or a local directory laid out in the same format.\n\nAll indexes provided via this flag take priority over the index specified by [`index_url`](#index-url). When multiple indexes are provided, earlier values take priority.\n\nTo control uv's resolution strategy when multiple indexes are present, see [`index_strategy`](#index-strategy).",
    )
    find_links: List[FlatIndexLocation] | None = Field(
        None,
        alias='find-links',
        description='Locations to search for candidate distributions, in addition to those found in the registry indexes.\n\nIf a path, the target must be a directory that contains packages as wheel files (`.whl`) or source distributions (`.tar.gz` or `.zip`) at the top level.\n\nIf a URL, the page must contain a flat list of links to package files adhering to the formats described above.',
    )
    index_strategy: IndexStrategy | None = Field(
        None,
        alias='index-strategy',
        description='The strategy to use when resolving against multiple index URLs.\n\nBy default, uv will stop at the first index on which a given package is available, and limit resolutions to those present on that first index (`first-match`). This prevents "dependency confusion" attacks, whereby an attack can upload a malicious package under the same name to a secondary.',
    )
    index_url: IndexUrl | None = Field(
        None,
        alias='index-url',
        description='The URL of the Python package index (by default: <https://pypi.org/simple>).\n\nAccepts either a repository compliant with [PEP 503](https://peps.python.org/pep-0503/) (the simple repository API), or a local directory laid out in the same format.\n\nThe index provided by this setting is given lower priority than any indexes specified via [`extra_index_url`](#extra-index-url).',
    )
    keyring_provider: KeyringProviderType | None = Field(
        None,
        alias='keyring-provider',
        description='Attempt to use `keyring` for authentication for index URLs.\n\nAt present, only `--keyring-provider subprocess` is supported, which configures uv to use the `keyring` CLI to handle authentication.',
    )
    link_mode: LinkMode | None = Field(
        None,
        alias='link-mode',
        description='The method to use when installing packages from the global cache.\n\nDefaults to `clone` (also known as Copy-on-Write) on macOS, and `hardlink` on Linux and Windows.',
    )
    managed: bool | None = Field(
        None,
        description='Whether the project is managed by uv. If `false`, uv will ignore the project when `uv run` is invoked.',
    )
    native_tls: bool | None = Field(
        None,
        alias='native-tls',
        description="Whether to load TLS certificates from the platform's native certificate store.\n\nBy default, uv loads certificates from the bundled `webpki-roots` crate. The `webpki-roots` are a reliable set of trust roots from Mozilla, and including them in uv improves portability and performance (especially on macOS).\n\nHowever, in some cases, you may want to use the platform's native certificate store, especially if you're relying on a corporate trust root (e.g., for a mandatory proxy) that's included in your system's certificate store.",
    )
    no_binary: bool | None = Field(
        None,
        alias='no-binary',
        description="Don't install pre-built wheels.\n\nThe given packages will be built and installed from source. The resolver will still use pre-built wheels to extract package metadata, if available.",
    )
    no_binary_package: List[PackageNameModel] | None = Field(
        None,
        alias='no-binary-package',
        description="Don't install pre-built wheels for a specific package.",
    )
    no_build: bool | None = Field(
        None,
        alias='no-build',
        description="Don't build source distributions.\n\nWhen enabled, resolving will not run arbitrary Python code. The cached wheels of already-built source distributions will be reused, but operations that require building distributions will exit with an error.",
    )
    no_build_isolation: bool | None = Field(
        None,
        alias='no-build-isolation',
        description='Disable isolation when building source distributions.\n\nAssumes that build dependencies specified by [PEP 518](https://peps.python.org/pep-0518/) are already installed.',
    )
    no_build_isolation_package: List[PackageNameModel] | None = Field(
        None,
        alias='no-build-isolation-package',
        description="Disable isolation when building source distributions for a specific package.\n\nAssumes that the packages' build dependencies specified by [PEP 518](https://peps.python.org/pep-0518/) are already installed.",
    )
    no_build_package: List[PackageNameModel] | None = Field(
        None,
        alias='no-build-package',
        description="Don't build source distributions for a specific package.",
    )
    no_cache: bool | None = Field(
        None,
        alias='no-cache',
        description='Avoid reading from or writing to the cache, instead using a temporary directory for the duration of the operation.',
    )
    no_index: bool | None = Field(
        None,
        alias='no-index',
        description='Ignore all registry indexes (e.g., PyPI), instead relying on direct URL dependencies and those provided via `--find-links`.',
    )
    no_sources: bool | None = Field(
        None,
        alias='no-sources',
        description='Ignore the `tool.uv.sources` table when resolving dependencies. Used to lock against the standards-compliant, publishable package metadata, as opposed to using any local or Git sources.',
    )
    offline: bool | None = Field(
        None,
        description='Disable network access, relying only on locally cached data and locally available files.',
    )
    override_dependencies: List[str] | None = Field(
        None,
        alias='override-dependencies',
        description='PEP 508-style requirements, e.g., `ruff==0.5.0`, or `ruff @ https://...`.',
    )
    package: bool | None = Field(
        None,
        description='Whether the project should be considered a Python package, or a non-package ("virtual") project.\n\nPackages are built and installed into the virtual environment in editable mode and thus require a build backend, while virtual projects are _not_ built or installed; instead, only their dependencies are included in the virtual environment.\n\nCreating a package requires that a `build-system` is present in the `pyproject.toml`, and that the project adheres to a structure that adheres to the build backend\'s expectations (e.g., a `src` layout).',
    )
    pip: PipOptions | None = None
    prerelease: PrereleaseMode | None = Field(
        None,
        description='The strategy to use when considering pre-release versions.\n\nBy default, uv will accept pre-releases for packages that _only_ publish pre-releases, along with first-party requirements that contain an explicit pre-release marker in the declared specifiers (`if-necessary-or-explicit`).',
    )
    preview: bool | None = Field(
        None, description='Whether to enable experimental, preview features.',
    )
    python_downloads: PythonDownloads | None = Field(
        None, alias='python-downloads', description='Whether to allow Python downloads.',
    )
    python_preference: PythonPreference | None = Field(
        None,
        alias='python-preference',
        description='Whether to prefer using Python installations that are already present on the system, or those that are downloaded and installed by uv.',
    )
    reinstall: bool | None = Field(
        None,
        description="Reinstall all packages, regardless of whether they're already installed. Implies `refresh`.",
    )
    reinstall_package: List[PackageNameModel] | None = Field(
        None,
        alias='reinstall-package',
        description="Reinstall a specific package, regardless of whether it's already installed. Implies `refresh-package`.",
    )
    resolution: ResolutionMode | None = Field(
        None,
        description='The strategy to use when selecting between the different compatible versions for a given package requirement.\n\nBy default, uv will use the latest compatible version of each package (`highest`).',
    )
    sources: Dict[str, Any] | None = Field(
        None,
        description='The sources to use (e.g., workspace members, Git repositories, local paths) when resolving dependencies.',
    )
    upgrade: bool | None = Field(
        None,
        description='Allow package upgrades, ignoring pinned versions in any existing output file.',
    )
    upgrade_package: List[Requirement] | None = Field(
        None,
        alias='upgrade-package',
        description='Allow upgrades for a specific package, ignoring pinned versions in any existing output file.\n\nAccepts both standalone package names (`ruff`) and version specifiers (`ruff<0.5.0`).',
    )
    workspace: ToolUvWorkspace | None = Field(
        None, description='The workspace definition for the project, if any.',
    )


class Tool(DataModel):
    """A table for tool configurations.

    Every tool that is used by the project can have its own sub-table for its configuration.

    """

    black: PartialBlack | None = None
    cibuildwheel: PartialCibuildwheel | None = None
    mypy: PartialMypy | None = None
    ruff: Ruff | None = None
    hatch: Hatch | None = None
    scikit_build: PartialScikitBuild | None = Field(None, alias='scikit-build')
    setuptools: PartialSetuptools | None = None
    setuptools_scm: PartialSetuptoolsScm | None = None
    poetry: PartialPoetry | None = None
    pdm: PartialPdm | None = None
    pyright: PartialPyright | None = None
    tox: Tox | None = Field(
        default_factory=Tox,
        description='Schema for the [tool.tox] section in pyproject.toml',
        title='Tox configuration in pyproject.toml',
    )
    uv: Uv | None = None


class PyProject(DataModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    build_system: BuildSystem | None = Field(None, alias='build-system')
    tool: Tool | None = Field(
        None,
        description='A table for tool configurations.\n\nEvery tool that is used by the project can have its own sub-table for its configuration.\n',
        examples=[{'tool': {'isort': {'profile': 'black'}}}],
        title='Tool-specific configuration',
    )
    project: Project | Project1 | None = Field(None, title='Project metadata')
    dependency_groups: Dict[Annotated[str,StringConstraints(pattern='^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9._-]*[a-zA-Z0-9])$')], List[str | DependencyGroups]] | None = Field(None, alias='dependency-groups', title='PEP 735 dependency groups')
