# AUTOGENERATED! DO NOT EDIT! File to edit: 14scop.ipynb (unless otherwise specified).

__all__ = ["Alldiff", "Constraint", "Linear", "Model", "Parameters", "Quadratic", "Variable", "plot_scop"]

# Cell
import platform
import re
import subprocess  # noqa: S404
import sys
from pathlib import Path

# 以下非標準ファイル
import plotly.graph_objs as go

_trans = str.maketrans(r"-+*/'(){}^=<>$ | #?,\ ", "_" * 22)  # 文字列変換用


# Cell
def plot_scop(file_name: str = "scop_out.txt"):
    out = Path(file_name).read_text(encoding="utf-8").splitlines()
    x, y1, y2 = [], [], []
    for line in out[5:]:
        sep = re.split(r"[=()/]", line)
        # print(sep)
        if sep[0] == "# penalty ":
            break
        if sep[0] == "penalty ":
            hard, soft, cpu = map(float, [sep[1], sep[2], sep[6]])
            x.append(cpu)
            y1.append(hard)
            y2.append(soft)

    fig = go.Figure()
    fig.add_trace(go.Scatter(x=x, y=y1, mode="markers+lines", name="hard", marker={"size": 10, "color": "red"}))
    fig.add_trace(go.Scatter(x=x, y=y2, name="soft", mode="markers+lines", marker={"size": 8, "color": "blue"}))
    fig.update_layout(title="SCOP performance", xaxis_title="CPU time", yaxis_title="Penalty")
    return fig


# Cell
class Parameters:
    """SCOP parameter class to control the operation of SCOP.

    - TimeLimit: Limits the total time expended (in seconds). Positive integer. Default = 600.
    - OutputFlag: Controls the output log. Boolean. Default = False.
    - RandomSeed: Sets the random seed number. Integer. Default = 1.
    - Target: Sets the target penalty value;
            optimization will terminate if the solver determines that the optimum penalty value
            for the model is worse than the specified "Target." Non-negative integer. Default = 0.
    - Initial: True if you want to solve the problem starting with an initial solution obtained
               before, False otherwise. Default = False.
    """

    def __init__(self):
        self.TimeLimit = 600
        self.OutputFlag = 0
        self.RandomSeed = 1
        self.Target = 0
        self.Initial = False

    def __str__(self):
        return (
            f" TimeLimit = {self.TimeLimit} \n OutputFlag = {self.OutputFlag} \n RandomSeed = {self.RandomSeed} \n"
            f" Target = {self.Target} \n Initial = {self.Initial}"
        )


# Cell
class Variable:
    """SCOP variable class. Variables are associated with a particular model.

    You can create a variable object by adding a variable to a model (using Model.addVariable or Model.addVariables)
    instead of by using a Variable constructor.
    """

    ID = 0  # variable ID for anonymous variables

    def __init__(self, name="", domain: list | None = None):
        if not name:
            name = f"__x{Variable.ID}"
            Variable.ID += 1
        if not isinstance(name, str):
            msg = "Variable name must be a string"
            raise TypeError(msg)
        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)
        # list(domain); domain name is converted to a string
        self.domain = [str(d) for d in domain or []]
        self.value = None  # optimal value

    def __str__(self):
        return f"variable {self.name!s}:{self.domain!s} = {self.value!s}"


# Cell
class Model:
    """SCOP model class.

    Attributes:
    - constraints: Set of constraint objects in the model.
    - variables: Set of variable objects in the model.
    - Params:  Object including all the parameters of the model.
    - varDict: Dictionary that maps variable names to the variable object.
    """

    def __init__(self, name=""):
        self.name = name
        self.constraints = []  # set of constraints is maintained by a list
        self.variables = []  # set of variables is maintained by a list
        self.Params = Parameters()
        self.varDict = {}  # dictionary that maps variable names to their domains
        self.Status = 10  # unsolved

    def __str__(self):
        """
        return the information of the problem
        constraints are expanded and are shown in a readable format
        """
        ret = [
            "Model:" + str(self.name),
            f"number of variables = {len(self.variables)} ",
            f"number of constraints= {len(self.constraints)} ",
        ]
        ret.extend(str(v) for v in self.variables)
        ret.extend(f"{str(c)[:-1]} :LHS ={c.lhs!s} " for c in self.constraints)
        return " \n".join(ret)

    def update(self) -> str:
        """Prepare a string representing the current model in the scop input format"""
        f = []
        # variable declarations
        for var in self.variables:
            domain = ",".join(str(i) for i in var.domain)
            f.append(f"variable {var.name} in {{ {domain} }} \n")
        # target value declaration
        f.append(f"target = {self.Params.Target} \n")
        # constraint declarations
        f.extend(str(con) for con in self.constraints)
        return " ".join(f)

    def addVariable(self, name="", domain: list | None = None):
        """Add a variable to the model.

        Arguments:
        - name: Name for new variable. A string object.
        - domain: Domain (list of values) of new variable. Each value must be a string or numeric object.

        Return value:
        New variable object.

        Example usage:
        x = model.addVariable("var")                      # domain  is set to []
        x = model.addVariable(name="var",domain=[1,2,3])  # arguments by name
        x = model.addVariable("var",["A","B","C"])        # arguments by position
        """
        var = Variable(name, domain)
        # keep variable names using the dictionary varDict
        # to check the validity of constraints later
        # check the duplicated name
        if var.name in self.varDict:
            msg = f"duplicate key '{var.name}' found in variable name"
            raise ValueError(msg)
        self.variables.append(var)
        self.varDict[var.name] = var
        return var

    def addVariables(self, names: list, domain: list | None = None):
        """Add variables and their (identical) domain.

        Arguments:
        - names: list of new variables. A list of string objects.
        - domain: Domain (list of values) of new variables. Each value must be a string or numeric object.

        Return value:
        List of new variable objects.

        Example usage:
        varlist=["var1","var2","var3"]
        x = model.addVariables(varlist)                      # domain  is set to []
        x = model.addVariables(names=varlist,domain=[1,2,3]  # arguments by name
        x = model.addVariables(varlist,["A","B","C"]         # arguments by position
        """
        if not isinstance(names, list):
            msg = "The first argument (names) must be a list."
            raise TypeError(msg)
        return [self.addVariable(var, domain) for var in names]

    def addConstraint(self, con):
        """Add a constraint to the model.

        Argument:
        - con: A constraint object (Linear, Quadratic or AllDiff).

        Example usage:
        model.addConstraint(L)
        """
        if not isinstance(con, Constraint):
            msg = f"error: {con!r} should be a subclass of Constraint"
            raise TypeError(msg)

        # check the feasibility of the constraint added in the class con
        try:
            if con.feasible(self.varDict):
                self.constraints.append(con)
        except NameError:
            msg = f"Constraint {con!r} has an error "
            raise NameError(msg) from None

    # def addConstraints(self,*cons):
    # for c in cons:
    # self.addConstraint(c)

    def optimize(self):  # noqa: C901 PLR0912 PLR0914 PLR0915
        """Optimize the model using scop.exe in the same directory.

        Example usage:
        model.optimize()
        """
        time = self.Params.TimeLimit
        seed = self.Params.RandomSeed
        log = self.Params.OutputFlag
        solver_dir = Path(__file__).parent

        f = self.update()
        Path("scop_input.txt").write_text(f, encoding="utf-8")

        if log >= 100:  # noqa: PLR2004
            print("scop input: \n")
            print(f)
            print("\n")
        if log:
            print("solving using parameters: \n ")
            print(f"  TimeLimit ={time} second \n")
            print(f"  RandomSeed= {seed} \n")
            print(f"  OutputFlag= {log} \n")
        #         if platform.system() == "Windows":
        #             cmd = "scop -time "+str(time)+" -seed "+str(seed) #solver call for win
        #         elif platform.system()== "Darwin":
        #             cmd = "./scop -time "+str(time)+" -seed "+str(seed) #solver call for mac
        #         elif platform.system() == "Linux":
        #             cmd = "./scop-linux -time "+str(time)+" -seed "+str(seed) #solver call for linux

        # トライアル版の場合は以下を生かす
        if platform.system() == "Windows":
            cmd = "scop-win -time " + str(time) + " -seed " + str(seed)  # solver call for win
        elif platform.system() == "Darwin":
            cmd = "./scop-mac -time " + str(time) + " -seed " + str(seed)  # solver call for mac
        elif platform.system() == "Linux":
            cmd = "./scop-linux -time " + str(time) + " -seed " + str(seed)  # solver call for linux

        if self.Params.Initial:
            cmd += " -initsolfile scop_best_data.txt"

        try:
            if platform.system() == "Windows":  # Winの場合にはコマンドをsplit!
                pipe = subprocess.Popen(  # noqa: S602
                    cmd.split(),
                    stdout=subprocess.PIPE,
                    stdin=subprocess.PIPE,
                    shell=True,
                    cwd=solver_dir,
                )
            else:
                pipe = subprocess.Popen(  # noqa: S602
                    cmd,
                    stdout=subprocess.PIPE,
                    stdin=subprocess.PIPE,
                    shell=True,
                    cwd=solver_dir,
                )
            print("\n ================ Now solving the problem ================ \n")
            # pipe = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE,stdin=subprocess.PIPE)
        except OSError:
            print(f"error: could not execute command {cmd!r}")
            print("please check that the solver is in the path")
            self.Status = 7  # execution failed
            return None, None

        out, err = pipe.communicate(f.encode())  # get the result
        if err is not None:
            if int(sys.version_info[0]) >= 3:  # noqa: PLR2004
                err = str(err, encoding="utf-8")
            Path("scop_error.txt").write_text(err, encoding="utf-8")

        if int(sys.version_info[0]) >= 3:  # noqa: PLR2004
            out = str(out, encoding="utf-8")

        if log:
            print(out, "\n")
        # print ("out=",out)
        # print ("err=",err)
        # print("Return Code=",pipe.returncode)

        Path("scop_out.txt").write_text(out, encoding="utf-8")

        # check the return code
        self.Status = pipe.returncode
        if self.Status != 0:  # if the return code is not "optimal", then return
            print("Status=", self.Status)
            print("Output=", out)
            return None, None

        # extract the solution and the violated constraints
        s0 = "[best solution]"
        s1 = "penalty"
        s2 = "[Violated constraints]"
        i0 = out.find(s0) + len(s0)
        i1 = out.find(s1, i0)
        i2 = out.find(s2, i1) + len(s2)

        data = out[i0:i1].strip()

        # save the best solution
        Path("scop_best_data.txt").write_text(data.lstrip(), encoding="utf-8")

        sol = {}
        if data:
            for s in data.split("\n"):
                name, value = s.split(":")
                sol[name] = value.strip()  # remove redundant string

        data = out[i2:].strip()
        violated = {}
        if data:
            for s in data.split("\n"):
                try:
                    name, value = s.split(":")
                except ValueError:
                    print("Error String=", s)

                try:
                    temp = int(value)
                except ValueError:
                    violated[name] = value
                else:
                    violated[name] = temp

        # set the optimal solution to the variable
        for name, value in sol.items():
            if name in self.varDict:
                self.varDict[name].value = value
            else:
                msg = f"Solution {name} is not in variable list"
                raise NameError(msg)

        # evaluate the left hand sides of the constraints
        for con in self.constraints:
            if isinstance(con, Linear):
                lhs = 0
                for coeff, var, domain in con.terms:
                    if var.value == domain:
                        lhs += coeff

                con.lhs = lhs
            if isinstance(con, Quadratic):
                lhs = 0
                # print con.terms
                for coeff, var1, domain1, var2, domain2 in con.terms:
                    if var1.value == domain1 and var2.value == domain2:
                        lhs += coeff

                con.lhs = lhs
            if isinstance(con, Alldiff):
                var_set = set()
                lhs = 0
                for v in con.variables:
                    index = v.domain.index(v.value)
                    # print v,index
                    if index in var_set:
                        lhs += 1
                    var_set.add(index)
                # print var_set
                con.lhs = lhs
        # return dictionaries containing the solution and the violated constraints
        return sol, violated


# Cell
class Constraint:
    """Constraint base class"""

    ID = 0

    def __init__(self, name=None, weight=1):
        if not name:
            name = f"__CON[{Constraint.ID}]"
            Constraint.ID += 1
        if not isinstance(name, str):
            msg = "Constraint name must be a string"
            raise TypeError(msg)
        # convert illegal characters into _ (underscore)
        self.name = str(name).translate(_trans)
        self.weight = str(weight)

    def setWeight(self, weight):
        self.weight = str(weight)


# Cell
class Linear(Constraint):
    """Linear constraint constructor.

    Arguments:
    - name: Name of linear constraint.
    - weight (optional): Positive integer representing importance of constraint.
    - rhs: Right-hand-side constant of linear constraint.
    - direction: Direction (or sense) of linear constraint; "<=" (default) or ">=" or "=".

    Attributes:
    - name: Name of linear constraint.
    - weight (optional): Positive integer representing importance of constraint.
    - rhs: Right-hand-side constant of linear constraint.
    - lhs: Left-hand-side constant of linear constraint.
    - direction: Direction (or sense) of linear constraint; "<=" (default) or ">=" or "=".
    - terms: List of terms in left-hand-side of constraint. Each term is a tuple of coefficient,variable and its value.
    """

    def __init__(self, name=None, weight=1, rhs=0, direction="<="):
        """Constructor of linear constraint class"""
        super().__init__(name, weight)
        # self.name = name
        # self.weight = str(weight)
        if not isinstance(rhs, int):
            msg = "Right-hand-side must be an integer."
            raise TypeError(msg)
        self.rhs = rhs
        if direction in {"<=", ">=", "="}:
            self.direction = direction
        else:
            msg = "direction setting error;direction should be one of '<=', '>=', or '='"
            raise NameError(msg)
        self.terms = []
        self.lhs = 0

    def __str__(self):
        """Return the information of the linear constraint

        the constraint is expanded and is shown in a readable format
        """
        f = [f"{self.name}: weight= {self.weight} type=linear"]
        for coeff, var, value in self.terms:
            f.append(f"{coeff!s}({var.name},{value!s})")
        f.append(self.direction + str(self.rhs) + "\n")
        return " ".join(f)

    def addTerms(self, coeffs, vars, values):  # noqa: A002
        """Add new terms into left-hand-side of linear constraint.

        Arguments:
        - coeffs: Coefficients for new terms; either a list of coefficients or a single coefficient.
                  The three arguments must have the same size.
        - vars: Variables for new terms; either a list of variables or a single variable.
                The three arguments must have the same size.
        - values: Values for new terms; either a list of values or a single value.
                  The three arguments must have the same size.

        Example usage:

        L.addTerms(1, y, "A")
        L.addTerms([2, 3, 1], [y, y, z], ["C", "D", "C"]) #2 X[y,"C"]+3 X[y,"D"]+1 X[z,"C"]
        """
        if not isinstance(coeffs, list):
            if not isinstance(coeffs, int):  # 整数の場合だけ追加する．
                msg = "Coefficient must be an integer."
                raise TypeError(msg)
            self.terms.append((coeffs, vars, str(values)))
        elif not isinstance(coeffs, list) or not isinstance(vars, list) or not isinstance(values, list):
            msg = "coeffs, vars, values must be lists"
            raise TypeError(msg)
        elif len(coeffs) != len(vars) or len(coeffs) != len(values):
            msg = "length of coeffs, vars, values must be identical"
            raise TypeError(msg)
        else:
            for i in range(len(coeffs)):
                self.terms.append((coeffs[i], vars[i], str(values[i])))

    def setRhs(self, rhs=0):
        if not isinstance(rhs, int):
            msg = "Right-hand-side must be an integer."
            raise TypeError(msg)
        self.rhs = rhs

    def setDirection(self, direction="<="):
        if direction in {"<=", ">=", "="}:
            self.direction = direction
        else:
            msg = "direction setting error; direction should be one of '<=', '>=', or '='"
            raise NameError(msg)

    def feasible(self, allvars):
        """
        return True if the constraint is defined correctly
        """
        for _coeff, var, value in self.terms:
            if var.name not in allvars:
                msg = f"no variable in the problem instance named {var.name!r}"
                raise NameError(msg)
            if value not in allvars[var.name].domain:
                msg = f"no value {value!r} for the variable named {var.name!r}"
                raise NameError(msg)
        return True


# Cell
class Quadratic(Constraint):
    """Quadratic constraint constructor.

    Arguments:
    - name: Name of quadratic constraint.
    - weight (optional): Positive integer representing importance of constraint.
    - rhs: Right-hand-side constant of linear constraint.
    - direction: Direction (or sense) of linear constraint; "<=" (default) or ">=" or "=".

    Attributes:
    - name: Name of quadratic constraint.
    - weight (optional): Positive integer representing importance of constraint.
    - rhs: Right-hand-side constant of linear constraint.
    - lhs: Left-hand-side constant of linear constraint.
    - direction: Direction (or sense) of linear constraint; "<=" (default) or ">=" or "=".
    - terms: List of terms in left-hand-side of constraint.
             Each term is a tuple of coefficient, variable1, value1, variable2 and value2.
    """

    def __init__(self, name=None, weight=1, rhs=0, direction="<="):
        super().__init__(name, weight)
        if not isinstance(rhs, int):
            msg = "Right-hand-side must be an integer."
            raise TypeError(msg)
        self.rhs = rhs
        if direction in {"<=", ">=", "="}:
            self.direction = direction
        else:
            msg = "direction setting error;direction should be one of '<=', '>=', or '='"
            raise NameError(msg)
        self.terms = []
        self.lhs = 0

    def __str__(self):
        """Return the information of the quadratic constraint

        the constraint is expanded and is shown in a readable format
        """
        f = [f"{self.name}: weight={self.weight} type=quadratic"]
        for coeff, var1, value1, var2, value2 in self.terms:
            f.append(f"{coeff}({var1.name},{value1})({var2.name},{value2})")
        f.append(self.direction + str(self.rhs) + "\n")
        return " ".join(f)

    def addTerms(self, coeffs, vars, values, vars2, values2):  # noqa: A002
        """Add new terms into left-hand-side of quadratic constraint.

        Arguments:
        - coeffs: Coefficients for new terms; either a list of coefficients or a single coefficient.
                  The five arguments must have the same size.
        - vars: Variables for new terms; either a list of variables or a single variable.
                The five arguments must have the same size.
        - values: Values for new terms; either a list of values or a single value.
                  The five arguments must have the same size.
        - vars2: Variables for new terms; either a list of variables or a single variable.
                 The five arguments must have the same size.
        - values2: Values for new terms; either a list of values or a single value.
                   The five arguments must have the same size.

        Example usage:

        L.addTerms(1.0, y, "A", z, "B")

        L.addTerms([2, 3, 1], [y, y, z], ["C", "D", "C"], [x, x, y], ["A", "B", "C"])
                  #2 X[y,"C"] X[x,"A"]+3 X[y,"D"] X[x,"B"]+1 X[z,"C"] X[y,"C"]
        """
        if not isinstance(coeffs, list):
            if not isinstance(coeffs, int):  # 整数の場合だけ追加する．
                msg = "Coefficient must be an integer."
                raise TypeError(msg)
            self.terms.append((coeffs, vars, str(values), vars2, str(values2)))
        elif (
            not isinstance(coeffs, list)
            or not isinstance(vars, list)
            or not isinstance(values, list)
            or not isinstance(vars2, list)
            or not isinstance(values2, list)
        ):
            msg = "coeffs, vars, values must be lists"
            raise TypeError(msg)
        elif (
            len(coeffs) != len(vars)
            or len(coeffs) != len(values)
            or len(values) != len(vars)
            or len(coeffs) != len(vars2)
            or len(coeffs) != len(values2)
        ):
            msg = "length of coeffs, vars, values must be identical"
            raise TypeError(msg)
        else:
            for i in range(len(coeffs)):
                self.terms.append((coeffs[i], vars[i], str(values[i]), vars2[i], str(values2[i])))

    def setRhs(self, rhs=0):
        if not isinstance(rhs, int):
            msg = "Right-hand-side must be an integer."
            raise TypeError(msg)
        self.rhs = rhs

    def setDirection(self, direction="<="):
        if direction in {"<=", ">=", "="}:
            self.direction = direction
        else:
            msg = "direction setting error;direction should be one of '<=', '>=', or '='"
            raise NameError(msg)

    def feasible(self, allvars):
        """Return True if the constraint is defined correctly"""
        for _coef, var1, value1, var2, value2 in self.terms:
            if var1.name not in allvars:
                msg = f"no variable in the problem instance named {var1.name!r}"
                raise NameError(msg)
            if var2.name not in allvars:
                msg = f"no variable in the problem instance named {var2.name!r}"
                raise NameError(msg)
            if value1 not in allvars[var1.name].domain:
                msg = f"no value {value1!r} for the variable named {var1.name!r}"
                raise NameError(msg)
            if value2 not in allvars[var2.name].domain:
                msg = f"no value {value2!r} for the variable named {var2.name!r}"
                raise NameError(msg)
        return True


# Cell
class Alldiff(Constraint):
    """Alldiff type constraint constructor.

    Arguments:
    - name: Name of all-different type constraint.
    - varlist (optional): List of variables that must have different value indices.
    - weight (optional): Positive integer representing importance of constraint.

    Attributes:
    - name: Name of all-different type  constraint.
    - varlist (optional): List of variables that must have different value indices.
    - lhs: Left-hand-side constant of linear constraint.

    - weight (optional): Positive integer representing importance of constraint.
    """

    def __init__(self, name=None, varlist=None, weight=1):
        # call the super class (Constraint) to initialize Alldiff
        super().__init__(name, weight)
        self.lhs = 0
        if varlist is None:
            self.variables = set()
        else:
            for var in varlist:
                if not isinstance(var, Variable):
                    msg = f"error: {var!r} should be a subclass of Variable"
                    raise TypeError(msg)
            self.variables = set(varlist)

    def __str__(self):
        """Return the information of the alldiff constraint"""
        f = [f"{self.name}: weight= {self.weight} type=alldiff "]
        f.extend(var.name for var in self.variables)
        f.append("; \n")
        return " ".join(f)

    def addVariable(self, var):
        """Add new variable into all-different type constraint.

        Arguments:
        - var: Variable object added to all-different type constraint.

        Example usage:

        AD.addVariable( x )
        """
        if not isinstance(var, Variable):
            msg = f"error: {var!r} should be a subclass of Variable"
            raise TypeError(msg)

        if var in self.variables:
            print(f"duplicate variable name error when adding variable {var!r}")
            return None
        return self.variables.add(var)

    def addVariables(self, varlist):
        """Add variables into all-different type constraint.

        Arguments:
        - varlist: List or tuple of variable objects added to all-different type constraint.

        Example usage:

        AD.addVariables( x, y, z )

        AD.addVariables( [x1,x2,x2] )
        """
        for var in varlist:
            self.addVariable(var)

    def feasible(self, allvars):
        """Return True if the constraint is defined correctly"""
        for var in self.variables:
            if var.name not in allvars:
                msg = f"no variable in the problem instance named {var.name!r}"
                raise NameError(msg)
        return True
